[
  {
    "identifier": "curve25519-dalek",
    "content": "",
    "code_name": "",
    "children": [
      {
        "identifier": "curve25519-dalek/src",
        "content": "",
        "code_name": "",
        "children": [
          {
            "identifier": "curve25519-dalek/src/edwards",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/edwards/affine.rs",
                "content": "",
                "code_name": "",
                "children": [
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/ct_eq",
                    "content": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/field.rs/ct_eq"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/compress",
                    "content": "    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                      "/curve25519-dalek/src/field.rs/is_negative"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn compress(self) -> CompressedEdwardsY {\n        let mut s = self.y.to_bytes();\n        s[31] ^= self.x.is_negative().unwrap_u8() << 7;\n        CompressedEdwardsY(s)\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/identity",
                    "content": "    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }",
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn identity() -> AffinePoint {\n        AffinePoint {\n            x: FieldElement::ZERO,\n            y: FieldElement::ONE,\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/default",
                    "content": "    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/edwards/affine.rs/identity"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn default() -> AffinePoint {\n        AffinePoint::identity()\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/mul",
                    "content": "    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/edwards/affine.rs/to_edwards"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn mul(self, rhs: AffinePoint) -> EdwardsPoint {\n        self * &rhs\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/conditional_select",
                    "content": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: FieldElement::conditional_select(&a.x, &b.x, choice),\n            y: FieldElement::conditional_select(&a.y, &b.y, choice),\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/eq",
                    "content": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/edwards/affine.rs/ct_eq"
                    ],
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/edwards/affine.rs/to_edwards",
                    "content": "    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }",
                    "code_name": "lib.rs",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn to_edwards(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: self.x,\n            Y: self.y,\n            Z: FieldElement::ONE,\n            T: &self.x * &self.y,\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  }
                ],
                "file_type": "folder",
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/window.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/window.rs/select",
                "content": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 128);\n\n        self.0[x / 2]\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/window.rs/select",
                "content": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn select(&self, x: usize) -> T {\n        debug_assert_eq!(x & 1, 1);\n        debug_assert!(x < 16);\n\n        self.0[x / 2]\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/window.rs/from",
                "content": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                  "/curve25519-dalek/src/edwards.rs/as_affine_niels",
                  "/curve25519-dalek/src/edwards.rs/as_projective_niels",
                  "/curve25519-dalek/src/edwards.rs/double"
                ],
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 8];\n        let A2 = A.double();\n        for i in 0..7 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n        NafLookupTable5(Ai)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/window.rs/from",
                "content": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                  "/curve25519-dalek/src/edwards.rs/double",
                  "/curve25519-dalek/src/edwards.rs/as_projective_niels",
                  "/curve25519-dalek/src/edwards.rs/as_affine_niels"
                ],
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn from(A: &'a EdwardsPoint) -> Self {\n        let mut Ai = [A.as_projective_niels(); 64];\n        let A2 = A.double();\n        for i in 0..63 {\n            Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n        }\n        // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n        NafLookupTable8(Ai)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/window.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"NafLookupTable5({:?})\", self.0)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/window.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
                "code_name": "diagnostics.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        writeln!(f, \"NafLookupTable8([\")?;\n        for i in 0..64 {\n            writeln!(f, \"\\t{:?},\", &self.0[i])?;\n        }\n        write!(f, \"])\")\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/backend",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/backend/serial",
                "content": "",
                "code_name": "",
                "children": [
                  {
                    "identifier": "curve25519-dalek/src/backend/serial/curve_models",
                    "content": "",
                    "code_name": "",
                    "children": [
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                            "content": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/square"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.Z,\n            Y: &self.Y * &self.Z,\n            Z: self.Z.square(),\n            T: &self.X * &self.Y,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/is_valid",
                            "content": "    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/square"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn is_valid(&self) -> bool {\n        // Curve equation is    -x^2 + y^2 = 1 + d*x^2*y^2,\n        // homogenized as (-X^2 + Y^2)*Z^2 = Z^4 + d*X^2*Y^2\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ = self.Z.square();\n        let ZZZZ = ZZ.square();\n        let lhs = &(&YY - &XX) * &ZZ;\n        let rhs = &ZZZZ + &(&constants::EDWARDS_D * &(&XX * &YY));\n\n        lhs == rhs\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                            "content": "    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
                            "content": "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn identity() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::ONE,\n            Y_minus_X: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T2d: FieldElement::ZERO,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/add",
                            "content": "    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn add(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PP = &Y_plus_X * &other.Y_plus_X;\n        let MM = &Y_minus_X * &other.Y_minus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PP - &MM,\n            Y: &PP + &MM,\n            Z: &ZZ2 + &TT2d,\n            T: &ZZ2 - &TT2d,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                            "content": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn as_extended(&self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: &self.X * &self.T,\n            Y: &self.Y * &self.Z,\n            Z: &self.Z * &self.T,\n            T: &self.X * &self.Y,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/neg",
                            "content": "    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn neg(self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: self.Y_minus_X,\n            Y_minus_X: self.Y_plus_X,\n            Z: self.Z,\n            T2d: -(&self.T2d),\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
                            "content": "    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/square2",
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/square"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn double(&self) -> CompletedPoint {\n        // Double()\n        let XX = self.X.square();\n        let YY = self.Y.square();\n        let ZZ2 = self.Z.square2();\n        let X_plus_Y = &self.X + &self.Y;\n        let X_plus_Y_sq = X_plus_Y.square();\n        let YY_plus_XX = &YY + &XX;\n        let YY_minus_XX = &YY - &XX;\n\n        CompletedPoint {\n            X: &X_plus_Y_sq - &YY_plus_XX,\n            Y: YY_plus_XX,\n            Z: YY_minus_XX,\n            T: &ZZ2 - &YY_minus_XX,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/conditional_select",
                            "content": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::conditional_select(&a.y_plus_x, &b.y_plus_x, choice),\n            y_minus_x: FieldElement::conditional_select(&a.y_minus_x, &b.y_minus_x, choice),\n            xy2d: FieldElement::conditional_select(&a.xy2d, &b.xy2d, choice),\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"CompletedPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectiveNielsPoint{{\\n\\tY_plus_X: {:?},\\n\\tY_minus_X: {:?},\\n\\tZ: {:?},\\n\\tT2d: {:?}\\n}}\",\n            &self.Y_plus_X, &self.Y_minus_X, &self.Z, &self.T2d\n        )\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/conditional_select",
                            "content": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        ProjectiveNielsPoint {\n            Y_plus_X: FieldElement::conditional_select(&a.Y_plus_X, &b.Y_plus_X, choice),\n            Y_minus_X: FieldElement::conditional_select(&a.Y_minus_X, &b.Y_minus_X, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T2d: FieldElement::conditional_select(&a.T2d, &b.T2d, choice),\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
                            "content": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/conditional_assign",
                            "content": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.y_plus_x.conditional_assign(&other.y_plus_x, choice);\n        self.y_minus_x.conditional_assign(&other.y_minus_x, choice);\n        self.xy2d.conditional_assign(&other.xy2d, choice);\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"ProjectivePoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z\n        )\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/conditional_assign",
                            "content": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_assign(&mut self, other: &Self, choice: Choice) {\n        self.Y_plus_X.conditional_assign(&other.Y_plus_X, choice);\n        self.Y_minus_X.conditional_assign(&other.Y_minus_X, choice);\n        self.Z.conditional_assign(&other.Z, choice);\n        self.T2d.conditional_assign(&other.T2d, choice);\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/sub",
                            "content": "    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn sub(self, other: &'a ProjectiveNielsPoint) -> CompletedPoint {\n        let Y_plus_X = &self.Y + &self.X;\n        let Y_minus_X = &self.Y - &self.X;\n        let PM = &Y_plus_X * &other.Y_minus_X;\n        let MP = &Y_minus_X * &other.Y_plus_X;\n        let TT2d = &self.T * &other.T2d;\n        let ZZ = &self.Z * &other.Z;\n        let ZZ2 = &ZZ + &ZZ;\n\n        CompletedPoint {\n            X: &PM - &MP,\n            Y: &PM + &MP,\n            Z: &ZZ2 - &TT2d,\n            T: &ZZ2 + &TT2d,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"AffineNielsPoint{{\\n\\ty_plus_x: {:?},\\n\\ty_minus_x: {:?},\\n\\txy2d: {:?}\\n}}\",\n            &self.y_plus_x, &self.y_minus_x, &self.xy2d\n        )\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
                            "content": "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn identity() -> AffineNielsPoint {\n        AffineNielsPoint {\n            y_plus_x: FieldElement::ONE,\n            y_minus_x: FieldElement::ONE,\n            xy2d: FieldElement::ZERO,\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/default",
                            "content": "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn default() -> AffineNielsPoint {\n        AffineNielsPoint::identity()\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/curve_models/mod.rs/default",
                            "content": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity"
                            ],
                            "code_name": "Makefile",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn default() -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint::identity()\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      }
                    ],
                    "file_type": "folder",
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/serial/scalar_mul",
                    "content": "",
                    "code_name": "",
                    "children": [
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs/mul",
                            "content": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                              "/curve25519-dalek/src/scalar.rs/as_radix_16",
                              "/curve25519-dalek/src/edwards.rs/identity",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    // Construct a lookup table of [P,2P,3P,4P,5P,6P,7P,8P]\n    let lookup_table = LookupTable::<ProjectiveNielsPoint>::from(point);\n    // Setting s = scalar, compute\n    //\n    //    s = s_0 + s_1*16^1 + ... + s_63*16^63,\n    //\n    // with `-8 ≤ s_i < 8` for `0 ≤ i < 63` and `-8 ≤ s_63 ≤ 8`.\n    // This decomposition requires s < 2^255, which is guaranteed by Scalar invariant #1.\n    let scalar_digits = scalar.as_radix_16();\n    // Compute s*P as\n    //\n    //    s*P = P*(s_0 +   s_1*16^1 +   s_2*16^2 + ... +   s_63*16^63)\n    //    s*P =  P*s_0 + P*s_1*16^1 + P*s_2*16^2 + ... + P*s_63*16^63\n    //    s*P = P*s_0 + 16*(P*s_1 + 16*(P*s_2 + 16*( ... + P*s_63)...))\n    //\n    // We sum right-to-left.\n\n    // Unwrap first loop iteration to save computing 16*identity\n    let mut tmp2;\n    let mut tmp3 = EdwardsPoint::identity();\n    let mut tmp1 = &tmp3 + &lookup_table.select(scalar_digits[63]);\n    // Now tmp1 = s_63*P in P1xP1 coords\n    for i in (0..63).rev() {\n        tmp2 = tmp1.as_projective(); // tmp2 =    (prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  2*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  2*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  4*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  4*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 =  8*(prev) in P1xP1 coords\n        tmp2 = tmp1.as_projective(); // tmp2 =  8*(prev) in P2 coords\n        tmp1 = tmp2.double();        // tmp1 = 16*(prev) in P1xP1 coords\n        tmp3 = tmp1.as_extended();   // tmp3 = 16*(prev) in P3 coords\n        tmp1 = &tmp3 + &lookup_table.select(scalar_digits[i]);\n        // Now tmp1 = s_i*P + 16*(prev) in P1xP1 coords\n    }\n    tmp1.as_extended()\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs/optional_multiscalar_mul",
                            "content": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/edwards.rs/identity",
                              "/curve25519-dalek/src/edwards.rs/mul_by_pow_2",
                              "/curve25519-dalek/src/scalar.rs/to_radix_2w_size_hint"
                            ],
                            "code_name": "README.md",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::Identity;\n\n        let mut scalars = scalars.into_iter();\n        let size = scalars.by_ref().size_hint().0;\n\n        // Digit width in bits. As digit width grows,\n        // number of point additions goes down, but amount of\n        // buckets and bucket additions grows exponentially.\n        let w = if size < 500 {\n            6\n        } else if size < 800 {\n            7\n        } else {\n            8\n        };\n\n        let max_digit: usize = 1 << w;\n        let digits_count: usize = Scalar::to_radix_2w_size_hint(w);\n        let buckets_count: usize = max_digit / 2; // digits are signed+centered hence 2^w/2, excluding 0-th bucket\n\n        // Collect optimized scalars and points in buffers for repeated access\n        // (scanning the whole set per digit position).\n        let scalars = scalars.map(|s| s.borrow().as_radix_2w(w));\n\n        let points = points\n            .into_iter()\n            .map(|p| p.map(|P| P.as_projective_niels()));\n\n        let scalars_points = scalars\n            .zip(points)\n            .map(|(s, maybe_p)| maybe_p.map(|p| (s, p)))\n            .collect::<Option<Vec<_>>>()?;\n\n        // Prepare 2^w/2 buckets.\n        // buckets[i] corresponds to a multiplication factor (i+1).\n        let mut buckets: Vec<_> = (0..buckets_count)\n            .map(|_| EdwardsPoint::identity())\n            .collect();\n\n        let mut columns = (0..digits_count).rev().map(|digit_index| {\n            // Clear the buckets when processing another digit.\n            for bucket in &mut buckets {\n                *bucket = EdwardsPoint::identity();\n            }\n\n            // Iterate over pairs of (point, scalar)\n            // and add/sub the point to the corresponding bucket.\n            // Note: if we add support for precomputed lookup tables,\n            // we'll be adding/subtracting point premultiplied by `digits[i]` to buckets[0].\n            for (digits, pt) in scalars_points.iter() {\n                // Widen digit so that we don't run into edge cases when w=8.\n                let digit = digits[digit_index] as i16;\n                match digit.cmp(&0) {\n                    Ordering::Greater => {\n                        let b = (digit - 1) as usize;\n                        buckets[b] = (&buckets[b] + pt).as_extended();\n                    }\n                    Ordering::Less => {\n                        let b = (-digit - 1) as usize;\n                        buckets[b] = (&buckets[b] - pt).as_extended();\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            // Add the buckets applying the multiplication factor to each bucket.\n            // The most efficient way to do that is to have a single sum with two running sums:\n            // an intermediate sum from last bucket to the first, and a sum of intermediate sums.\n            //\n            // For example, to add buckets 1*A, 2*B, 3*C we need to add these points:\n            //   C\n            //   C B\n            //   C B A   Sum = C + (C+B) + (C+B+A)\n            let mut buckets_intermediate_sum = buckets[buckets_count - 1];\n            let mut buckets_sum = buckets[buckets_count - 1];\n            for i in (0..(buckets_count - 1)).rev() {\n                buckets_intermediate_sum += buckets[i];\n                buckets_sum += buckets_intermediate_sum;\n            }\n\n            buckets_sum\n        });\n\n        // Take the high column as an initial value to avoid wasting time doubling the identity element in `fold()`.\n        let hi_column = columns.next().expect(\"should have more than zero digits\");\n\n        Some(columns.fold(hi_column, |total, p| total.mul_by_pow_2(w as u32) + p))\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs/mul",
                            "content": "pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
                              "/curve25519-dalek/src/window.rs/select",
                              "/curve25519-dalek/src/window.rs/select",
                              "/curve25519-dalek/src/scalar.rs/non_adjacent_form",
                              "/curve25519-dalek/src/window.rs/from",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity"
                            ],
                            "code_name": "pippenger.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    let a_naf = a.non_adjacent_form(5);\n\n    #[cfg(feature = \"precomputed-tables\")]\n    let b_naf = b.non_adjacent_form(8);\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let b_naf = b.non_adjacent_form(5);\n\n    // Find starting index\n    let mut i: usize = 255;\n    for j in (0..256).rev() {\n        i = j;\n        if a_naf[i] != 0 || b_naf[i] != 0 {\n            break;\n        }\n    }\n\n    let table_A = NafLookupTable5::<ProjectiveNielsPoint>::from(A);\n    #[cfg(feature = \"precomputed-tables\")]\n    let table_B = &constants::AFFINE_ODD_MULTIPLES_OF_BASEPOINT;\n    #[cfg(not(feature = \"precomputed-tables\"))]\n    let table_B =\n        &NafLookupTable5::<ProjectiveNielsPoint>::from(&constants::ED25519_BASEPOINT_POINT);\n\n    let mut r = ProjectivePoint::identity();\n    loop {\n        let mut t = r.double();\n\n        match a_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_A.select(a_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_A.select(-a_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        match b_naf[i].cmp(&0) {\n            Ordering::Greater => t = &t.as_extended() + &table_B.select(b_naf[i] as usize),\n            Ordering::Less => t = &t.as_extended() - &table_B.select(-b_naf[i] as usize),\n            Ordering::Equal => {}\n        }\n\n        r = t.as_projective();\n\n        if i == 0 {\n            break;\n        }\n        i -= 1;\n    }\n\n    r.as_extended()\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/optional_mixed_multiscalar_mul",
                            "content": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/window.rs/from",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double"
                            ],
                            "code_name": "CLAUDE.md",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        let static_nafs = static_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n        let dynamic_nafs: Vec<_> = dynamic_scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect::<Vec<_>>();\n\n        let dynamic_lookup_tables = dynamic_points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let sp = self.static_lookup_tables.len();\n        let dp = dynamic_lookup_tables.len();\n        assert!(sp >= static_nafs.len());\n        assert_eq!(dp, dynamic_nafs.len());\n\n        // We could save some doublings by looking for the highest\n        // nonzero NAF coefficient, but since we might have a lot of\n        // them to search, it's not clear it's worthwhile to check.\n        let mut S = ProjectivePoint::identity();\n        for j in (0..256).rev() {\n            let mut R: CompletedPoint = S.double();\n\n            for i in 0..dp {\n                let t_ij = dynamic_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &dynamic_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &dynamic_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            #[allow(clippy::needless_range_loop)]\n            for i in 0..static_nafs.len() {\n                let t_ij = static_nafs[i][j];\n                match t_ij.cmp(&0) {\n                    Ordering::Greater => {\n                        R = &R.as_extended() + &self.static_lookup_tables[i].select(t_ij as usize)\n                    }\n                    Ordering::Less => {\n                        R = &R.as_extended() - &self.static_lookup_tables[i].select(-t_ij as usize)\n                    }\n                    Ordering::Equal => {}\n                }\n            }\n\n            S = R.as_projective();\n        }\n\n        Some(S.as_extended())\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/is_empty",
                            "content": "    fn is_empty(&self) -> bool {\n        self.static_lookup_tables.is_empty()\n    }",
                            "code_name": "CLAUDE.md",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn is_empty(&self) -> bool {\n        self.static_lookup_tables.is_empty()\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/len",
                            "content": "    fn len(&self) -> usize {\n        self.static_lookup_tables.len()\n    }",
                            "code_name": "CLAUDE.md",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn len(&self) -> usize {\n        self.static_lookup_tables.len()\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/new",
                            "content": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/window.rs/from"
                            ],
                            "code_name": "CLAUDE.md",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self {\n            static_lookup_tables: static_points\n                .into_iter()\n                .map(|P| NafLookupTable8::<AffineNielsPoint>::from(P.borrow()))\n                .collect(),\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs/multiscalar_mul",
                            "content": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/edwards.rs/mul_by_pow_2",
                              "/curve25519-dalek/src/edwards.rs/identity"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        use crate::backend::serial::curve_models::ProjectiveNielsPoint;\n        use crate::traits::Identity;\n        use crate::window::LookupTable;\n\n        let lookup_tables: Vec<_> = points\n            .into_iter()\n            .map(|point| LookupTable::<ProjectiveNielsPoint>::from(point.borrow()))\n            .collect();\n\n        // This puts the scalar digits into a heap-allocated Vec.\n        // To ensure that these are erased, pass ownership of the Vec into a\n        // Zeroizing wrapper.\n        #[cfg_attr(not(feature = \"zeroize\"), allow(unused_mut))]\n        let mut scalar_digits: Vec<_> = scalars\n            .into_iter()\n            .map(|s| s.borrow().as_radix_16())\n            .collect();\n\n        let mut Q = EdwardsPoint::identity();\n        for j in (0..64).rev() {\n            Q = Q.mul_by_pow_2(4);\n            let it = scalar_digits.iter().zip(lookup_tables.iter());\n            for (s_i, lookup_table_i) in it {\n                // R_i = s_{i,j} * P_i\n                let R_i = lookup_table_i.select(s_i[j]);\n                // Q = Q + R_i\n                Q = (&Q + &R_i).as_extended();\n            }\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // zeroize::Zeroize::zeroize(&mut scalar_digits);\n\n        Q\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs/optional_multiscalar_mul",
                            "content": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/identity",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                              "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                              "/curve25519-dalek/src/window.rs/from"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::backend::serial::curve_models::{\n            CompletedPoint, ProjectiveNielsPoint, ProjectivePoint,\n        };\n        use crate::traits::Identity;\n        use crate::window::NafLookupTable5;\n\n        let nafs: Vec<_> = scalars\n            .into_iter()\n            .map(|c| c.borrow().non_adjacent_form(5))\n            .collect();\n\n        let lookup_tables = points\n            .into_iter()\n            .map(|P_opt| P_opt.map(|P| NafLookupTable5::<ProjectiveNielsPoint>::from(&P)))\n            .collect::<Option<Vec<_>>>()?;\n\n        let mut r = ProjectivePoint::identity();\n\n        for i in (0..256).rev() {\n            let mut t: CompletedPoint = r.double();\n\n            for (naf, lookup_table) in nafs.iter().zip(lookup_tables.iter()) {\n                match naf[i].cmp(&0) {\n                    Ordering::Greater => {\n                        t = &t.as_extended() + &lookup_table.select(naf[i] as usize)\n                    }\n                    Ordering::Less => t = &t.as_extended() - &lookup_table.select(-naf[i] as usize),\n                    Ordering::Equal => {}\n                }\n            }\n\n            r = t.as_projective();\n        }\n\n        Some(r.as_extended())\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      }
                    ],
                    "file_type": "folder",
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/serial/u64",
                    "content": "",
                    "code_name": "",
                    "children": [
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_spec_fits_u64",
                                "content": "pub proof fn load8_at_spec_fits_u64(input: &[u8], i: usize)\n    requires\n        i + 7 < input.len()\n    ensures\n        load8_at_spec(input, i) <= u64::MAX\n{\n    lemma2_to64();\n    lemma2_to64_rest();\n\n    assert forall |j: nat| 0 <= j < 8 implies #[trigger] pow2(j * 8) * input[i + j] <= pow2((j + 1) * 8) - pow2(j * 8) by {\n        // sanity check, holds for all u8\n        assert(input[i + j] <= pow2(8) - 1);\n        mul_le(pow2(j * 8), pow2(j * 8), input[i + j] as nat, (pow2(8) - 1) as nat);\n        assert(pow2(j * 8) * (pow2(8) - 1) == pow2((j + 1) * 8) - pow2(j * 8)) by {\n            lemma_mul_is_distributive_sub(pow2(j * 8) as int, pow2(8) as int, 1);\n            lemma_pow2_adds(j * 8, 8);\n        }\n\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/load8_at_spec",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_at_spec_fits_u64(input: &[u8], i: usize)\n    requires\n        i + 7 < input.len()\n    ensures\n        load8_at_spec(input, i) <= u64::MAX\n{\n    lemma2_to64();\n    lemma2_to64_rest();\n\n    assert forall |j: nat| 0 <= j < 8 implies #[trigger] pow2(j * 8) * input[i + j] <= pow2((j + 1) * 8) - pow2(j * 8) by {\n        // sanity check, holds for all u8\n        assert(input[i + j] <= pow2(8) - 1);\n        mul_le(pow2(j * 8), pow2(j * 8), input[i + j] as nat, (pow2(8) - 1) as nat);\n        assert(pow2(j * 8) * (pow2(8) - 1) == pow2((j + 1) * 8) - pow2(j * 8)) by {\n            lemma_mul_is_distributive_sub(pow2(j * 8) as int, pow2(8) as int, 1);\n            lemma_pow2_adds(j * 8, 8);\n        }\n\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma_base",
                                "content": "pub proof fn load8_lemma_base(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64\n    ensures\n        a + (b * pow2(j)) == pow2(k) * (a / pow2(k) + (b * pow2(j)) as nat / pow2(k)) + (a % pow2(k) + (b * pow2(j)) as nat % pow2(k)),\n        pow2(k) > 0,\n{\n    let cb = (b * pow2(j)) as nat;\n\n    // No div by 0\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert( a == pow2(k) * (a / pow2(k)) + a % pow2(k)) by {\n        lemma_fundamental_div_mod(a as int, pow2(k) as int);\n    }\n\n    assert( cb == pow2(k) * (cb / pow2(k)) + cb % pow2(k)) by {\n        lemma_fundamental_div_mod(cb as int, pow2(k) as int);\n    }\n\n    assert(a + cb == pow2(k) * (a / pow2(k) + cb / pow2(k)) + (a % pow2(k) + cb % pow2(k))) by {\n        lemma_mul_is_distributive_add( pow2(k) as int, (a / pow2(k)) as int, (cb / pow2(k)) as int);\n        lemma_mul_is_associative(\n            (pow2(k) * (a / pow2(k) + cb / pow2(k))) as int,\n            (a % pow2(k)) as int,\n            (cb % pow2(k)) as int\n        );\n    }\n\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_lemma_base(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64\n    ensures\n        a + (b * pow2(j)) == pow2(k) * (a / pow2(k) + (b * pow2(j)) as nat / pow2(k)) + (a % pow2(k) + (b * pow2(j)) as nat % pow2(k)),\n        pow2(k) > 0,\n{\n    let cb = (b * pow2(j)) as nat;\n\n    // No div by 0\n    assert(pow2(k) > 0) by {\n        lemma_pow2_pos(k);\n    }\n\n    assert( a == pow2(k) * (a / pow2(k)) + a % pow2(k)) by {\n        lemma_fundamental_div_mod(a as int, pow2(k) as int);\n    }\n\n    assert( cb == pow2(k) * (cb / pow2(k)) + cb % pow2(k)) by {\n        lemma_fundamental_div_mod(cb as int, pow2(k) as int);\n    }\n\n    assert(a + cb == pow2(k) * (a / pow2(k) + cb / pow2(k)) + (a % pow2(k) + cb % pow2(k))) by {\n        lemma_mul_is_distributive_add( pow2(k) as int, (a / pow2(k)) as int, (cb / pow2(k)) as int);\n        lemma_mul_is_associative(\n            (pow2(k) * (a / pow2(k) + cb / pow2(k))) as int,\n            (a % pow2(k)) as int,\n            (cb % pow2(k)) as int\n        );\n    }\n\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/rec_version_is_exec",
                                "content": "pub proof fn rec_version_is_exec(input: &[u8], i: usize)\n    ensures\n        load8_at_or_version_rec(input, i, 7)\n        ==\n        (input[i as int] as u64)\n        | ((input[i + 1] as u64) << 8)\n        | ((input[i + 2] as u64) << 16)\n        | ((input[i + 3] as u64) << 24)\n        | ((input[i + 4] as u64) << 32)\n        | ((input[i + 5] as u64) << 40)\n        | ((input[i + 6] as u64) << 48)\n        | ((input[i + 7] as u64) << 56)\n{\n    assert(load8_at_or_version_rec(input, i, 0) == (input[i as int] as u64));\n\n    assert forall |j: nat| 1 <= j <= 7 implies\n        #[trigger] load8_at_or_version_rec(input, i, j) ==\n        load8_at_or_version_rec(input, i, (j - 1) as nat)\n        | ((input[i + j] as u64) << 8 * j)\n    by {\n        reveal_with_fuel(load8_at_or_version_rec, 1);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_or_version_rec"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn rec_version_is_exec(input: &[u8], i: usize)\n    ensures\n        load8_at_or_version_rec(input, i, 7)\n        ==\n        (input[i as int] as u64)\n        | ((input[i + 1] as u64) << 8)\n        | ((input[i + 2] as u64) << 16)\n        | ((input[i + 3] as u64) << 24)\n        | ((input[i + 4] as u64) << 32)\n        | ((input[i + 5] as u64) << 40)\n        | ((input[i + 6] as u64) << 48)\n        | ((input[i + 7] as u64) << 56)\n{\n    assert(load8_at_or_version_rec(input, i, 0) == (input[i as int] as u64));\n\n    assert forall |j: nat| 1 <= j <= 7 implies\n        #[trigger] load8_at_or_version_rec(input, i, j) ==\n        load8_at_or_version_rec(input, i, (j - 1) as nat)\n        | ((input[i + j] as u64) << 8 * j)\n    by {\n        reveal_with_fuel(load8_at_or_version_rec, 1);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec",
                                "content": "pub proof fn plus_version_is_spec(input: &[u8], i: usize)\n    ensures\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n        load8_at_spec(input, i)\n{\n    assert(load8_at_plus_version_rec(input, i, 0) == input[i as int] as u64);\n\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert((input[i as int] as u64) == pow2(0 * 8) * input[i + 0]) by {\n            lemma2_to64();\n        }\n    plus_version_is_spec_lemma(input, i, 1);\n    plus_version_is_spec_lemma(input, i, 2);\n    plus_version_is_spec_lemma(input, i, 3);\n    plus_version_is_spec_lemma(input, i, 4);\n    plus_version_is_spec_lemma(input, i, 5);\n    plus_version_is_spec_lemma(input, i, 6);\n    plus_version_is_spec_lemma(input, i, 7);\n\n    // suffices to prove this, the _lemma results then give the spec formulation for free\n    assert(\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n         (input[i as int] as u64)\n        + ((input[i + 1] as u64) << 8)\n        + ((input[i + 2] as u64) << 16)\n        + ((input[i + 3] as u64) << 24)\n        + ((input[i + 4] as u64) << 32)\n        + ((input[i + 5] as u64) << 40)\n        + ((input[i + 6] as u64) << 48)\n        + ((input[i + 7] as u64) << 56)\n    ) by {\n        assert forall |j: nat| 1 <= j <= 7 implies\n        #[trigger] load8_at_plus_version_rec(input, i, j)\n        ==\n        load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n        by {\n            reveal_with_fuel(load8_at_plus_version_rec, 1);\n\n            assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8) <= u64::MAX) by {\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) <= pow2(8 * j) - 1 ) by {\n                    load8_at_plus_version_rec_is_bounded(input, i, (j - 1) as nat);\n                }\n\n                assert((input[i + j] as u64) << j * 8 <= u8::MAX * pow2(j * 8) ) by {\n                    // input[k] < MAX8 => input[k] * 2^(8j) < MAX8 * 2^(8j)\n                    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n                }\n\n                assert(\n                    load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n                    <=\n                    pow2(8 * (j + 1)) - 1\n                ) by {\n                    lemma_mul_is_distributive_add(1, u8::MAX as int, pow2(j * 8) as int);\n                }\n            }\n\n        }\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/load8_at_spec",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec_is_bounded",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec_lemma"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn plus_version_is_spec(input: &[u8], i: usize)\n    ensures\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n        load8_at_spec(input, i)\n{\n    assert(load8_at_plus_version_rec(input, i, 0) == input[i as int] as u64);\n\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert((input[i as int] as u64) == pow2(0 * 8) * input[i + 0]) by {\n            lemma2_to64();\n        }\n    plus_version_is_spec_lemma(input, i, 1);\n    plus_version_is_spec_lemma(input, i, 2);\n    plus_version_is_spec_lemma(input, i, 3);\n    plus_version_is_spec_lemma(input, i, 4);\n    plus_version_is_spec_lemma(input, i, 5);\n    plus_version_is_spec_lemma(input, i, 6);\n    plus_version_is_spec_lemma(input, i, 7);\n\n    // suffices to prove this, the _lemma results then give the spec formulation for free\n    assert(\n        load8_at_plus_version_rec(input, i, 7)\n        ==\n         (input[i as int] as u64)\n        + ((input[i + 1] as u64) << 8)\n        + ((input[i + 2] as u64) << 16)\n        + ((input[i + 3] as u64) << 24)\n        + ((input[i + 4] as u64) << 32)\n        + ((input[i + 5] as u64) << 40)\n        + ((input[i + 6] as u64) << 48)\n        + ((input[i + 7] as u64) << 56)\n    ) by {\n        assert forall |j: nat| 1 <= j <= 7 implies\n        #[trigger] load8_at_plus_version_rec(input, i, j)\n        ==\n        load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n        by {\n            reveal_with_fuel(load8_at_plus_version_rec, 1);\n\n            assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8) <= u64::MAX) by {\n                assert(load8_at_plus_version_rec(input, i, (j - 1) as nat) <= pow2(8 * j) - 1 ) by {\n                    load8_at_plus_version_rec_is_bounded(input, i, (j - 1) as nat);\n                }\n\n                assert((input[i + j] as u64) << j * 8 <= u8::MAX * pow2(j * 8) ) by {\n                    // input[k] < MAX8 => input[k] * 2^(8j) < MAX8 * 2^(8j)\n                    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n                }\n\n                assert(\n                    load8_at_plus_version_rec(input, i, (j - 1) as nat) + ((input[i + j] as u64) << j * 8)\n                    <=\n                    pow2(8 * (j + 1)) - 1\n                ) by {\n                    lemma_mul_is_distributive_add(1, u8::MAX as int, pow2(j * 8) as int);\n                }\n            }\n\n        }\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec",
                                "content": "pub open spec fn load8_at_plus_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    }\n    else {\n        // k > 0\n        (load8_at_plus_version_rec(input, i, (k - 1) as nat) + ((input[i + k] as u64) << k * 8)) as u64\n    }\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn load8_at_plus_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    }\n    else {\n        // k > 0\n        (load8_at_plus_version_rec(input, i, (k - 1) as nat) + ((input[i + k] as u64) << k * 8)) as u64\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_versions_equivalent",
                                "content": "pub proof fn load8_at_versions_equivalent(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7\n    ensures\n        load8_at_or_version_rec(input, i, k) == load8_at_plus_version_rec(input, i, k)\n    decreases k\n{\n    if (k == 0){\n        // trivial\n    }\n    else {\n        load8_at_versions_equivalent(input, i, (k - 1) as nat);\n        let prev = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n        assert(prev < (1u64 << 8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n            shift_is_pow2(8 * k);\n        }\n        bit_or_is_plus(prev, input[i + k], (8 * k) as u64);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/bit_or_is_plus",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec_is_bounded",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_or_version_rec"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_at_versions_equivalent(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7\n    ensures\n        load8_at_or_version_rec(input, i, k) == load8_at_plus_version_rec(input, i, k)\n    decreases k\n{\n    if (k == 0){\n        // trivial\n    }\n    else {\n        load8_at_versions_equivalent(input, i, (k - 1) as nat);\n        let prev = load8_at_plus_version_rec(input, i, (k - 1) as nat);\n        assert(prev < (1u64 << 8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n            shift_is_pow2(8 * k);\n        }\n        bit_or_is_plus(prev, input[i + k], (8 * k) as u64);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma2",
                                "content": "pub proof fn load8_lemma2(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        j < k < 64\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        (b * pow2(j)) as nat / pow2(k)\n        ==\n        b as nat / pow2((k - j) as nat)\n\n{\n    let cb = (b * pow2(j)) as nat;\n\n    // a + cb == pow2(k) * (a / pow2(k) + cb / pow2(k)) + (a % pow2(k) + cb % pow2(k)),\n    load8_lemma_base(a, b, j, k);\n\n    let d = (k - j) as nat;\n\n    // 2^k = 2^j * 2^(k - j)\n    lemma_pow2_adds(j, d);\n    // 2^x > 0\n    lemma_pow2_pos(j);\n    lemma_pow2_pos(d);\n\n    assert(\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        ((a + b * pow2(j)) as nat / pow2(j)) / pow2(d)\n    ) by {\n        lemma_div_denominator((a + cb) as int, pow2(j) as int, pow2(d) as int );\n    }\n\n    assert((b * pow2(j)) as nat / pow2(j) == b) by {\n        lemma_div_multiples_vanish(b as int, pow2(j) as int);\n    }\n\n    assert((a + b * pow2(j)) as nat / pow2(j) == b) by {\n        // == a / pow2(j) + (b * pow2(j)) as nat / pow2(j)\n        load8_lemma1(a, b, j, j);\n        assert( a / pow2(j) == 0 ) by {\n            lemma_basic_div(a as int, pow2(j) as int);\n        }\n    }\n\n    assert(cb / pow2(k) == b as nat / pow2(d)) by {\n        lemma_div_denominator(cb as int, pow2(j) as int, pow2(d) as int )\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma1",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma_base"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_lemma2(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        j < k < 64\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        (b * pow2(j)) as nat / pow2(k)\n        ==\n        b as nat / pow2((k - j) as nat)\n\n{\n    let cb = (b * pow2(j)) as nat;\n\n    // a + cb == pow2(k) * (a / pow2(k) + cb / pow2(k)) + (a % pow2(k) + cb % pow2(k)),\n    load8_lemma_base(a, b, j, k);\n\n    let d = (k - j) as nat;\n\n    // 2^k = 2^j * 2^(k - j)\n    lemma_pow2_adds(j, d);\n    // 2^x > 0\n    lemma_pow2_pos(j);\n    lemma_pow2_pos(d);\n\n    assert(\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        ((a + b * pow2(j)) as nat / pow2(j)) / pow2(d)\n    ) by {\n        lemma_div_denominator((a + cb) as int, pow2(j) as int, pow2(d) as int );\n    }\n\n    assert((b * pow2(j)) as nat / pow2(j) == b) by {\n        lemma_div_multiples_vanish(b as int, pow2(j) as int);\n    }\n\n    assert((a + b * pow2(j)) as nat / pow2(j) == b) by {\n        // == a / pow2(j) + (b * pow2(j)) as nat / pow2(j)\n        load8_lemma1(a, b, j, j);\n        assert( a / pow2(j) == 0 ) by {\n            lemma_basic_div(a as int, pow2(j) as int);\n        }\n    }\n\n    assert(cb / pow2(k) == b as nat / pow2(d)) by {\n        lemma_div_denominator(cb as int, pow2(j) as int, pow2(d) as int )\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/bit_or_is_plus",
                                "content": "pub proof fn bit_or_is_plus(a: u64, b: u8, k: u64)\n    by (bit_vector)\n    requires\n        k + 8 <= 64,\n        a < 1u64 << k\n    ensures\n        a | ((b as u64) << (k as u64)) == a + ((b as u64) << (k as u64)),\n        a + ((b as u64) << (k as u64)) <= u64::MAX\n{\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn bit_or_is_plus(a: u64, b: u8, k: u64)\n    by (bit_vector)\n    requires\n        k + 8 <= 64,\n        a < 1u64 << k\n    ensures\n        a | ((b as u64) << (k as u64)) == a + ((b as u64) << (k as u64)),\n        a + ((b as u64) << (k as u64)) <= u64::MAX\n{\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec_is_bounded",
                                "content": "pub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1))\n    decreases k\n{\n\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    }\n    else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(\n                            c as int,\n                            pow2(8) as int,\n                            pow2(8 * k) as int\n                        );\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(\n                            pow2(8 * k) as int,\n                            pow2(56) as int,\n                            pow2(8) as int\n                        );\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k +1))) by {\n            // x + c * x == c ( x + 1 )\n            assert( pow2(8 * k) + c * pow2(8 * k) == pow2(8 *k) * (c + 1) ) by {\n                lemma_mul_is_distributive_add( pow2(8 * k) as int, c as int, 1 );\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality(\n                    (c + 1) as int,\n                    pow2(8) as int,\n                    pow2(8 * k) as int\n                );\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_plus_version_rec"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_at_plus_version_rec_is_bounded(input: &[u8], i: usize, k: nat)\n    requires\n        k <= 7\n    ensures\n        load8_at_plus_version_rec(input, i, k) < pow2(8 * (k + 1))\n    decreases k\n{\n\n    assert(u8::MAX < pow2(8)) by {\n        lemma2_to64();\n    }\n\n    if (k == 0) {\n        // just needs the the pre-if assert\n    }\n    else {\n        // k > 0\n        // Let f(k) := load8_at_plus_version_rec(input, i, k)\n        // IH: f(k - 1) < pow2(8 * k)\n        assert(load8_at_plus_version_rec(input, i, (k - 1) as nat) < pow2(8 * k)) by {\n            load8_at_plus_version_rec_is_bounded(input, i, (k - 1) as nat);\n        }\n\n        let c = (input[i + k] as u64);\n        assert(c < pow2(8));\n\n        // f(k) = f(k - 1) + c * pow2(8 * k)\n        assert(c << (8 * k) == c * pow2(8 * k)) by {\n            assert((input[i + k] as u64) * pow2(8 * k) <= u64::MAX) by {\n                assert(u64::MAX == pow2(64) - 1) by {\n                    lemma2_to64_rest();\n                }\n                assert(c * pow2(8 * k) < pow2(64)) by {\n                    assert(c * pow2(8 * k) < pow2(8) * pow2(8 * k)) by {\n                        lemma_mul_strict_inequality(\n                            c as int,\n                            pow2(8) as int,\n                            pow2(8 * k) as int\n                        );\n                    }\n                    assert(pow2(8) * pow2(8 * k) <= pow2(64)) by {\n                        assert(pow2(8 * k) <= pow2(56)) by {\n                            if (k < 7) {\n                                lemma_pow2_strictly_increases(8 * k, 56);\n                            }\n                        }\n                        lemma_pow2_pos(8);\n                        lemma_mul_inequality(\n                            pow2(8 * k) as int,\n                            pow2(56) as int,\n                            pow2(8) as int\n                        );\n                        lemma_pow2_adds(8, 56);\n                    }\n                }\n            }\n            lemma_u64_shl_is_mul(c, (8 * k) as u64);\n        }\n\n        // f(k - 1) < 1 * 2^(8k)\n        // c <= 2^8 - 1\n        // f(k -1) + c * 2^8k < 2^8 * 2^8k = 2^(8 * (k + 1))\n\n        assert(load8_at_plus_version_rec(input, i, k) < pow2(8 * k) + c * pow2(8 * k));\n\n        assert(pow2(8 * k) + c * pow2(8 * k) <= pow2(8 * (k +1))) by {\n            // x + c * x == c ( x + 1 )\n            assert( pow2(8 * k) + c * pow2(8 * k) == pow2(8 *k) * (c + 1) ) by {\n                lemma_mul_is_distributive_add( pow2(8 * k) as int, c as int, 1 );\n            }\n            assert(c + 1 <= pow2(8));\n\n            assert(pow2(8 * k) * (c + 1) <= pow2(8 * (k + 1))) by {\n                lemma_mul_inequality(\n                    (c + 1) as int,\n                    pow2(8) as int,\n                    pow2(8 * k) as int\n                );\n                lemma_pow2_adds(8, 8 * k);\n                lemma_mul_is_distributive_add(8, 1, k as int);\n            }\n        }\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma1",
                                "content": "pub proof fn load8_lemma1(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        k <= j\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        a / pow2(k) + (b * pow2(j)) as nat / pow2(k)\n\n{\n    let cb = (b * pow2(j)) as nat;\n\n    load8_lemma_base(a, b, j, k);\n\n    assert(cb % pow2(k) == 0) by {\n            lemma_pow2_adds((j - k) as nat, k);\n            lemma_mul_is_associative(b as int, pow2((j - k) as nat) as int, pow2(k) as int);\n            lemma_mod_multiples_basic(b * pow2((j - k) as nat), pow2(k) as int);\n        }\n\n    assert((a % pow2(k) + cb % pow2(k)) < pow2(k)) by {\n        lemma_mod_division_less_than_divisor(a as int, pow2(k) as int);\n    }\n\n    lemma_div_multiples_vanish_fancy(\n        (a / pow2(k) + cb / pow2(k)) as int,\n        (a % pow2(k) + cb % pow2(k)) as int,\n        pow2(k) as int\n    );\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma_base"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_lemma1(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        k <= j\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        a / pow2(k) + (b * pow2(j)) as nat / pow2(k)\n\n{\n    let cb = (b * pow2(j)) as nat;\n\n    load8_lemma_base(a, b, j, k);\n\n    assert(cb % pow2(k) == 0) by {\n            lemma_pow2_adds((j - k) as nat, k);\n            lemma_mul_is_associative(b as int, pow2((j - k) as nat) as int, pow2(k) as int);\n            lemma_mod_multiples_basic(b * pow2((j - k) as nat), pow2(k) as int);\n        }\n\n    assert((a % pow2(k) + cb % pow2(k)) < pow2(k)) by {\n        lemma_mod_division_less_than_divisor(a as int, pow2(k) as int);\n    }\n\n    lemma_div_multiples_vanish_fancy(\n        (a / pow2(k) + cb / pow2(k)) as int,\n        (a % pow2(k) + cb % pow2(k)) as int,\n        pow2(k) as int\n    );\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_or_version_rec",
                                "content": "pub open spec fn load8_at_or_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    }\n    else {\n        // k > 0\n        load8_at_or_version_rec(input, i, (k - 1) as nat) | ((input[i + k] as u64) << k * 8)\n    }\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn load8_at_or_version_rec(input: &[u8], i: usize, k: nat) -> u64\n    decreases k\n{\n    if (k == 0) {\n        (input[i as int] as u64)\n    }\n    else {\n        // k > 0\n        load8_at_or_version_rec(input, i, (k - 1) as nat) | ((input[i + k] as u64) << k * 8)\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec_lemma",
                                "content": "pub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1))\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7){\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(\n                u8::MAX * pow2(j * 8)\n                ==\n                (pow2(8) - 1) * pow2(j * 8)\n                ==\n                pow2(8 * (j + 1)) - pow2(j * 8)\n            ) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64(); // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn plus_version_is_spec_lemma(input: &[u8], i: usize, j: nat)\n    requires\n        1 <= j <= 7\n    ensures\n        (input[i + j] as u64) << 8 * j == pow2(j * 8) * input[i + j],\n        input[i + j] * pow2(j * 8) <= u64::MAX,\n        pow2(8 * (j + 1)) - 1 <= pow2(64) - 1,\n        pow2(8) * pow2(8 * j) == pow2(8 * (j + 1))\n{\n    assert(pow2(64) - 1 == u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n    assert(u8::MAX + 1 == pow2(8)) by {\n        lemma2_to64();\n    }\n\n    assert(pow2(8 * (j + 1)) - 1 <= pow2(64) - 1) by {\n        if (j < 7){\n            lemma_pow2_strictly_increases(8 * (j + 1), 64);\n        }\n    }\n\n    lemma_pow2_adds(8, j * 8);\n\n    lemma_mul_inequality(input[i + j] as int, u8::MAX as int, pow2(j * 8) as int);\n\n    assert((input[i + j] as u64) * pow2(j * 8) <= u64::MAX) by {\n        assert(u8::MAX * pow2(j * 8) <= pow2(64) - 1) by {\n            assert(\n                u8::MAX * pow2(j * 8)\n                ==\n                (pow2(8) - 1) * pow2(j * 8)\n                ==\n                pow2(8 * (j + 1)) - pow2(j * 8)\n            ) by {\n                assert(pow2(8) >= 1) by {\n                    lemma2_to64();\n                }\n                lemma_mul_is_distributive_sub(pow2(8) as int, 1, pow2(j * 8) as int);\n            }\n            assert(pow2(j * 8) > 1) by {\n                lemma2_to64(); // pow2(0)\n                lemma_pow2_strictly_increases(0, j * 8)\n            }\n        }\n    }\n    lemma_u64_shl_is_mul((input[i + j] as u64), (j * 8) as u64);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma",
                                "content": "pub proof fn load8_lemma(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        k < 64\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        a / pow2(k) + (b * pow2(j)) as nat / pow2(k)\n{\n    if ( k <= j) {\n        load8_lemma1(a, b, j, k);\n    }\n    else {\n        // j < k\n        load8_lemma2(a, b, j, k);\n\n        assert(a / pow2(k) == 0) by {\n            lemma_pow2_strictly_increases(j, k);\n            lemma_basic_div(a as int, pow2(k) as int);\n        }\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma1",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_lemma2"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn load8_lemma(a: nat, b: u8, j: nat, k: nat)\n    requires\n        a < pow2(j),\n        j + 8 <= 64,\n        k < 64\n    ensures\n        (a + b * pow2(j)) as nat / pow2(k)\n        ==\n        a / pow2(k) + (b * pow2(j)) as nat / pow2(k)\n{\n    if ( k <= j) {\n        load8_lemma1(a, b, j, k);\n    }\n    else {\n        // j < k\n        load8_lemma2(a, b, j, k);\n\n        assert(a / pow2(k) == 0) by {\n            lemma_pow2_strictly_increases(j, k);\n            lemma_basic_div(a as int, pow2(k) as int);\n        }\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/load8_at_spec",
                                "content": "pub open spec fn load8_at_spec(input: &[u8], i: usize) -> nat\n{\n    (\n    pow2(0 * 8) * input[i + 0] +\n    pow2(1 * 8) * input[i + 1] +\n    pow2(2 * 8) * input[i + 2] +\n    pow2(3 * 8) * input[i + 3] +\n    pow2(4 * 8) * input[i + 4] +\n    pow2(5 * 8) * input[i + 5] +\n    pow2(6 * 8) * input[i + 6] +\n    pow2(7 * 8) * input[i + 7]\n    ) as nat\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn load8_at_spec(input: &[u8], i: usize) -> nat\n{\n    (\n    pow2(0 * 8) * input[i + 0] +\n    pow2(1 * 8) * input[i + 1] +\n    pow2(2 * 8) * input[i + 2] +\n    pow2(3 * 8) * input[i + 3] +\n    pow2(4 * 8) * input[i + 4] +\n    pow2(5 * 8) * input[i + 5] +\n    pow2(6 * 8) * input[i + 6] +\n    pow2(7 * 8) * input[i + 7]\n    ) as nat\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pre_reduce_limbs",
                                "content": "pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5]\n{\n    let r = [\n        (sixteen_p_vec[0] - limbs[0]) as u64,\n        (sixteen_p_vec[1] - limbs[1]) as u64,\n        (sixteen_p_vec[2] - limbs[2]) as u64,\n        (sixteen_p_vec[3] - limbs[3]) as u64,\n        (sixteen_p_vec[4] - limbs[4]) as u64,\n    ];\n    r\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5]\n{\n    let r = [\n        (sixteen_p_vec[0] - limbs[0]) as u64,\n        (sixteen_p_vec[1] - limbs[1]) as u64,\n        (sixteen_p_vec[2] - limbs[2]) as u64,\n        (sixteen_p_vec[3] - limbs[3]) as u64,\n        (sixteen_p_vec[4] - limbs[4]) as u64,\n    ];\n    r\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                                "content": "pub proof fn l51_bit_mask_lt()\n    ensures\n        mask51 == low_bits_mask(51),\n        mask51 < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(mask51 < (1u64 << 51) as nat) by (compute);\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn l51_bit_mask_lt()\n    ensures\n        mask51 == low_bits_mask(51),\n        mask51 < (1u64 << 51) as nat,\n{\n    lemma2_to64_rest();\n    assert(mask51 < (1u64 << 51) as nat) by (compute);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/main",
                                "content": "fn main() {}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_negate",
                                "content": "pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5]\n{\n    let r = spec_reduce(pre_reduce_limbs(limbs));\n    r\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pre_reduce_limbs",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce"
                                ],
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5]\n{\n    let r = spec_reduce(pre_reduce_limbs(limbs));\n    r\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                                "content": "pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat_32_u8",
                                "content": "pub open spec fn as_nat_32_u8(limbs: [u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (limbs[0] as nat) +\n    pow2( 1 * 8) * (limbs[ 1] as nat) +\n    pow2( 2 * 8) * (limbs[ 2] as nat) +\n    pow2( 3 * 8) * (limbs[ 3] as nat) +\n    pow2( 4 * 8) * (limbs[ 4] as nat) +\n    pow2( 5 * 8) * (limbs[ 5] as nat) +\n    pow2( 6 * 8) * (limbs[ 6] as nat) +\n    pow2( 7 * 8) * (limbs[ 7] as nat) +\n    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn as_nat_32_u8(limbs: [u8; 32]) -> nat {\n    // Verus error: `core::iter::range::impl&%15::fold` is not supported\n    // we write them out manually\n    (limbs[0] as nat) +\n    pow2( 1 * 8) * (limbs[ 1] as nat) +\n    pow2( 2 * 8) * (limbs[ 2] as nat) +\n    pow2( 3 * 8) * (limbs[ 3] as nat) +\n    pow2( 4 * 8) * (limbs[ 4] as nat) +\n    pow2( 5 * 8) * (limbs[ 5] as nat) +\n    pow2( 6 * 8) * (limbs[ 6] as nat) +\n    pow2( 7 * 8) * (limbs[ 7] as nat) +\n    pow2( 8 * 8) * (limbs[ 8] as nat) +\n    pow2( 9 * 8) * (limbs[ 9] as nat) +\n    pow2(10 * 8) * (limbs[10] as nat) +\n    pow2(11 * 8) * (limbs[11] as nat) +\n    pow2(12 * 8) * (limbs[12] as nat) +\n    pow2(13 * 8) * (limbs[13] as nat) +\n    pow2(14 * 8) * (limbs[14] as nat) +\n    pow2(15 * 8) * (limbs[15] as nat) +\n    pow2(16 * 8) * (limbs[16] as nat) +\n    pow2(17 * 8) * (limbs[17] as nat) +\n    pow2(18 * 8) * (limbs[18] as nat) +\n    pow2(19 * 8) * (limbs[19] as nat) +\n    pow2(20 * 8) * (limbs[20] as nat) +\n    pow2(21 * 8) * (limbs[21] as nat) +\n    pow2(22 * 8) * (limbs[22] as nat) +\n    pow2(23 * 8) * (limbs[23] as nat) +\n    pow2(24 * 8) * (limbs[24] as nat) +\n    pow2(25 * 8) * (limbs[25] as nat) +\n    pow2(26 * 8) * (limbs[26] as nat) +\n    pow2(27 * 8) * (limbs[27] as nat) +\n    pow2(28 * 8) * (limbs[28] as nat) +\n    pow2(29 * 8) * (limbs[29] as nat) +\n    pow2(30 * 8) * (limbs[30] as nat) +\n    pow2(31 * 8) * (limbs[31] as nat)\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
                                "content": "pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                                "content": "pub open spec fn as_nat(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn as_nat(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                                "content": "pub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19\n{\n    lemma2_to64(); // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn pow255_gt_19()\n    ensures\n        pow2(255) > 19\n{\n    lemma2_to64(); // 2^5\n    lemma_pow2_strictly_increases(5, 255);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val",
                                "content": "pub open spec fn c2_val(a: [u64;5]) -> u128{\n    (c2_0_val(a) + ((c1_val(a) >> 51) as u64) as u128) as u128\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_0_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c2_val(a: [u64;5]) -> u128{\n    (c2_0_val(a) + ((c1_val(a) >> 51) as u64) as u128) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val",
                                "content": "pub open spec fn c3_val(a: [u64;5]) -> u128{\n    (c3_0_val(a) + ((c2_val(a) >> 51) as u64) as u128) as u128\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c3_val(a: [u64;5]) -> u128{\n    (c3_0_val(a) + ((c2_val(a) >> 51) as u64) as u128) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/a2_0_val",
                                "content": "pub open spec fn a2_0_val(a: [u64; 5]) -> u64 {\n    (c2_val(a) as u64) & mask51\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn a2_0_val(a: [u64; 5]) -> u64 {\n    (c2_val(a) as u64) & mask51\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/a0_0_val",
                                "content": "pub open spec fn a0_0_val(a: [u64; 5]) -> u64 {\n    (c0_val(a) as u64) & mask51\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn a0_0_val(a: [u64; 5]) -> u64 {\n    (c0_val(a) as u64) & mask51\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/a3_0_val",
                                "content": "pub open spec fn a3_0_val(a: [u64; 5]) -> u64 {\n    (c3_val(a) as u64) & mask51\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn a3_0_val(a: [u64; 5]) -> u64 {\n    (c3_val(a) as u64) & mask51\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_0_val",
                                "content": "pub open spec fn c3_0_val(a: [u64;5]) -> u128{\n    (a[4] * (19 * a[4]) + 2*( a[0] *  a[3] + a[1] * a[2])) as u128\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c3_0_val(a: [u64;5]) -> u128{\n    (a[4] * (19 * a[4]) + 2*( a[0] *  a[3] + a[1] * a[2])) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_shift_bounded",
                                "content": "pub proof fn c_i_shift_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51),\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        (c0_val(a) >> 51) <= (u64::MAX as u128),\n        (c1_val(a) >> 51) <= (u64::MAX as u128),\n        (c2_val(a) >> 51) <= (u64::MAX as u128),\n        (c3_val(a) >> 51) <= (u64::MAX as u128),\n        (c4_val(a) >> 51) <= (u64::MAX as u128)\n\n{\n    c_i_0_bounded(a, bound);\n\n    lemma_shr_51_fits_u64(c0_val(a));\n    lemma_shr_51_fits_u64(c1_val(a));\n    lemma_shr_51_fits_u64(c2_val(a));\n    lemma_shr_51_fits_u64(c3_val(a));\n    lemma_shr_51_fits_u64(c4_val(a));\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_0_bounded",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_fits_u64"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn c_i_shift_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51),\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        (c0_val(a) >> 51) <= (u64::MAX as u128),\n        (c1_val(a) >> 51) <= (u64::MAX as u128),\n        (c2_val(a) >> 51) <= (u64::MAX as u128),\n        (c3_val(a) >> 51) <= (u64::MAX as u128),\n        (c4_val(a) >> 51) <= (u64::MAX as u128)\n\n{\n    c_i_0_bounded(a, bound);\n\n    lemma_shr_51_fits_u64(c0_val(a));\n    lemma_shr_51_fits_u64(c1_val(a));\n    lemma_shr_51_fits_u64(c2_val(a));\n    lemma_shr_51_fits_u64(c3_val(a));\n    lemma_shr_51_fits_u64(c4_val(a));\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_0_val",
                                "content": "pub open spec fn c0_0_val(a: [u64; 5]) -> u128 {\n    (a[0] *  a[0] + 2*( a[1] * (19 * a[4]) + a[2] * (19 * a[3]))) as u128\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c0_0_val(a: [u64; 5]) -> u128 {\n    (a[0] *  a[0] + 2*( a[1] * (19 * a[4]) + a[2] * (19 * a[3]))) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/term_product_bounds",
                                "content": "pub proof fn term_product_bounds(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        // c0\n        (a[0] as u128) * (a[0] as u128) < bound * bound,\n        (a[1] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[2] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c1\n        (a[3] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[1] as u128) < (bound * bound),\n        (a[2] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        // c2\n        (a[1] as u128) * (a[1] as u128) < (bound * bound),\n        (a[0] as u128) * (a[2] as u128) < (bound * bound),\n        (a[4] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c3\n        (a[4] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[3] as u128) < (bound * bound),\n        (a[1] as u128) * (a[2] as u128) < (bound * bound),\n        // c4\n        (a[2] as u128) * (a[2] as u128) < (bound * bound),\n        (a[0] as u128) * (a[4] as u128) < (bound * bound),\n        (a[1] as u128) * (a[3] as u128) < (bound * bound)\n{\n    let bound19 = (19 * bound) as u64;\n\n    let a3_19 = (19 * a[3]) as u64;\n    let a4_19 = (19 * a[4]) as u64;\n\n    assert(bound * (19 * bound) == 19 * (bound * bound)) by {\n        lemma_mul_is_associative(19, bound as int, bound as int);\n    }\n\n    // c0\n    lemma_m(a[0], a[0], bound, bound);\n    lemma_m(a[1], a4_19, bound, bound19);\n    lemma_m(a[2], a3_19, bound, bound19);\n\n    // c1\n    lemma_m(a[3], a3_19, bound, bound19);\n    lemma_m(a[0],  a[1], bound, bound);\n    lemma_m(a[2], a4_19, bound, bound19);\n\n    // c2\n    lemma_m(a[1],  a[1], bound, bound);\n    lemma_m(a[0],  a[2], bound, bound);\n    lemma_m(a[4], a3_19, bound, bound19);\n\n    // c3\n    lemma_m(a[4], a4_19, bound, bound19);\n    lemma_m(a[0],  a[3], bound, bound);\n    lemma_m(a[1],  a[2], bound, bound);\n\n    // c4\n    lemma_m(a[2],  a[2], bound, bound);\n    lemma_m(a[0],  a[4], bound, bound);\n    lemma_m(a[1],  a[3], bound, bound);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/lemma_m"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn term_product_bounds(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        // c0\n        (a[0] as u128) * (a[0] as u128) < bound * bound,\n        (a[1] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[2] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c1\n        (a[3] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[1] as u128) < (bound * bound),\n        (a[2] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        // c2\n        (a[1] as u128) * (a[1] as u128) < (bound * bound),\n        (a[0] as u128) * (a[2] as u128) < (bound * bound),\n        (a[4] as u128) * ((19 * a[3]) as u128) < 19 * (bound * bound),\n        // c3\n        (a[4] as u128) * ((19 * a[4]) as u128) < 19 * (bound * bound),\n        (a[0] as u128) * (a[3] as u128) < (bound * bound),\n        (a[1] as u128) * (a[2] as u128) < (bound * bound),\n        // c4\n        (a[2] as u128) * (a[2] as u128) < (bound * bound),\n        (a[0] as u128) * (a[4] as u128) < (bound * bound),\n        (a[1] as u128) * (a[3] as u128) < (bound * bound)\n{\n    let bound19 = (19 * bound) as u64;\n\n    let a3_19 = (19 * a[3]) as u64;\n    let a4_19 = (19 * a[4]) as u64;\n\n    assert(bound * (19 * bound) == 19 * (bound * bound)) by {\n        lemma_mul_is_associative(19, bound as int, bound as int);\n    }\n\n    // c0\n    lemma_m(a[0], a[0], bound, bound);\n    lemma_m(a[1], a4_19, bound, bound19);\n    lemma_m(a[2], a3_19, bound, bound19);\n\n    // c1\n    lemma_m(a[3], a3_19, bound, bound19);\n    lemma_m(a[0],  a[1], bound, bound);\n    lemma_m(a[2], a4_19, bound, bound19);\n\n    // c2\n    lemma_m(a[1],  a[1], bound, bound);\n    lemma_m(a[0],  a[2], bound, bound);\n    lemma_m(a[4], a3_19, bound, bound19);\n\n    // c3\n    lemma_m(a[4], a4_19, bound, bound19);\n    lemma_m(a[0],  a[3], bound, bound);\n    lemma_m(a[1],  a[2], bound, bound);\n\n    // c4\n    lemma_m(a[2],  a[2], bound, bound);\n    lemma_m(a[0],  a[4], bound, bound);\n    lemma_m(a[1],  a[3], bound, bound);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_0_val",
                                "content": "pub open spec fn c1_0_val(a: [u64; 5]) -> u128 {\n    (a[3] *  (19 * a[3]) + 2 *( a[0] * a[1] + a[2] * (19 * a[4]))) as u128\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c1_0_val(a: [u64; 5]) -> u128 {\n    (a[3] *  (19 * a[3]) + 2 *( a[0] * a[1] + a[2] * (19 * a[4]))) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_0_val",
                                "content": "pub open spec fn c2_0_val(a: [u64;5]) -> u128{\n    (a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * (19 * a[3]))) as u128\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c2_0_val(a: [u64;5]) -> u128{\n    (a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * (19 * a[3]))) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_0_bounded",
                                "content": "pub proof fn c_i_0_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        c0_0_val(a) < 77 * (bound * bound),\n        c1_0_val(a) < 59 * (bound * bound),\n        c2_0_val(a) < 41 * (bound * bound),\n        c3_0_val(a) < 23 * (bound * bound),\n        c4_0_val(a) <  5 * (bound * bound)\n{\n    term_product_bounds(a, bound);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/term_product_bounds",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_0_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn c_i_0_bounded(a: [u64; 5], bound: u64)\n    requires\n        19 * bound <= u64::MAX,\n        forall |i: int| 0 <= i < 5 ==> a[i] < bound\n    ensures\n        c0_0_val(a) < 77 * (bound * bound),\n        c1_0_val(a) < 59 * (bound * bound),\n        c2_0_val(a) < 41 * (bound * bound),\n        c3_0_val(a) < 23 * (bound * bound),\n        c4_0_val(a) <  5 * (bound * bound)\n{\n    term_product_bounds(a, bound);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/lemma_reorder_mul",
                                "content": "pub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_reorder_mul(a: int, b: int)\n    ensures\n        2 * (a * (19 * b)) == 19 * (2 * (a * b))\n{\n    // 2*( a * (19 * b)) = (2 * a) * (19 * b)\n    lemma_mul_is_associative(2, a, 19 * b);\n    // (2 * a) * (19 * b) = (19 * b) * (2 * a) = 19 * (b * (2 * a))\n    lemma_mul_is_associative(19, b, 2 * a);\n    // (b * (2 * a)) = (b * (a * 2)) = 2 * (a * b)\n    lemma_mul_is_associative(b, a, 2);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/a1_0_val",
                                "content": "pub open spec fn a1_0_val(a: [u64; 5]) -> u64 {\n    (c1_val(a) as u64) & mask51\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn a1_0_val(a: [u64; 5]) -> u64 {\n    (c1_val(a) as u64) & mask51\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_0_val",
                                "content": "pub open spec fn c4_0_val(a: [u64;5]) -> u128{\n    (a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3])) as u128\n}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c4_0_val(a: [u64;5]) -> u128{\n    (a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3])) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val",
                                "content": "pub open spec fn c1_val(a: [u64; 5]) -> u128 {\n    (c1_0_val(a) + ((c0_val(a) >> 51) as u64) as u128) as u128\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_0_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c1_val(a: [u64; 5]) -> u128 {\n    (c1_0_val(a) + ((c0_val(a) >> 51) as u64) as u128) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/a4_0_val",
                                "content": "pub open spec fn a4_0_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) as u64) & mask51\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn a4_0_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) as u64) & mask51\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/carry_val",
                                "content": "pub open spec fn carry_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) >> 51) as u64\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn carry_val(a: [u64; 5]) -> u64 {\n    (c4_val(a) >> 51) as u64\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val",
                                "content": "pub open spec fn c4_val(a: [u64;5]) -> u128{\n    (c4_0_val(a) + ((c3_val(a) >> 51) as u64) as u128) as u128\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_0_val",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c4_val(a: [u64;5]) -> u128{\n    (c4_0_val(a) + ((c3_val(a) >> 51) as u64) as u128) as u128\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_val",
                                "content": "pub open spec fn c0_val(a: [u64; 5]) -> u128 {\n    c0_0_val(a)\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_0_val"
                                ],
                                "code_name": "field_core.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn c0_val(a: [u64; 5]) -> u128 {\n    c0_0_val(a)\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/lemma_as_nat_sub",
                                "content": "pub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] <= a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        lemma_mul_is_distributive_sub(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_sub(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_sub(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat"
                                ],
                                "code_name": "load8_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_as_nat_sub(a: [u64;5], b: [u64;5])\n    requires\n        forall |i:int| 0 <= i < 5 ==> b[i] <= a[i]\n    ensures\n        as_nat([\n            (a[0] - b[0]) as u64,\n            (a[1] - b[1]) as u64,\n            (a[2] - b[2]) as u64,\n            (a[3] - b[3]) as u64,\n            (a[4] - b[4]) as u64\n        ]) == as_nat(a) - as_nat(b)\n{\n    let c: [u64;5] = [\n        (a[0] - b[0]) as u64,\n        (a[1] - b[1]) as u64,\n        (a[2] - b[2]) as u64,\n        (a[3] - b[3]) as u64,\n        (a[4] - b[4]) as u64\n    ];\n    // distribute pow2\n    assert( as_nat(c) ==\n        (a[0] - b[0]) +\n        pow2(51) * a[1] - pow2(51) * b[1] +\n        pow2(102) * a[2] - pow2(102) * b[2] +\n        pow2(153) * a[3] - pow2(153) * b[3] +\n        pow2(204) * a[4] - pow2(204) * b[4]\n    ) by {\n        lemma_mul_is_distributive_sub(pow2(1 * 51) as int, a[1] as int, b[1] as int);\n        lemma_mul_is_distributive_sub(pow2(2 * 51) as int, a[2] as int, b[2] as int);\n        lemma_mul_is_distributive_sub(pow2(3 * 51) as int, a[3] as int, b[3] as int);\n        lemma_mul_is_distributive_sub(pow2(4 * 51) as int, a[4] as int, b[4] as int);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_k",
                                "content": "pub proof fn as_nat_k(a: [u64;5], k: u64)\n    requires\n        forall |i:int| 0 <= i < 5 ==> (k * a[i]) <= u64::MAX\n    ensures\n        as_nat([\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ]) == k * as_nat(a)\n{\n    let ka = [\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ];\n\n    assert(as_nat(ka) ==\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n    ) by {\n        lemma_mul_is_associative(pow2( 51) as int, a[1] as int, k as int);\n        lemma_mul_is_associative(pow2(102) as int, a[2] as int, k as int);\n        lemma_mul_is_associative(pow2(153) as int, a[3] as int, k as int);\n        lemma_mul_is_associative(pow2(204) as int, a[4] as int, k as int);\n    }\n\n    assert(\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n        ==\n        k * (\n            a[0] +\n            (pow2( 51) * a[1]) +\n            (pow2(102) * a[2]) +\n            (pow2(153) * a[3]) +\n            (pow2(204) * a[4])\n        )\n    ) by {\n        lemma_mul_is_distributive_add(k as int, a[0] as int, pow2( 51) * a[1]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1], pow2(102) * a[2]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2], pow2(153) * a[3]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2] + pow2(153) * a[3], (pow2(204) * a[4]));\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat"
                                ],
                                "code_name": "load8_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn as_nat_k(a: [u64;5], k: u64)\n    requires\n        forall |i:int| 0 <= i < 5 ==> (k * a[i]) <= u64::MAX\n    ensures\n        as_nat([\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ]) == k * as_nat(a)\n{\n    let ka = [\n            (k * a[0]) as u64,\n            (k * a[1]) as u64,\n            (k * a[2]) as u64,\n            (k * a[3]) as u64,\n            (k * a[4]) as u64\n            ];\n\n    assert(as_nat(ka) ==\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n    ) by {\n        lemma_mul_is_associative(pow2( 51) as int, a[1] as int, k as int);\n        lemma_mul_is_associative(pow2(102) as int, a[2] as int, k as int);\n        lemma_mul_is_associative(pow2(153) as int, a[3] as int, k as int);\n        lemma_mul_is_associative(pow2(204) as int, a[4] as int, k as int);\n    }\n\n    assert(\n        k * a[0] +\n        k * (pow2( 51) * a[1]) +\n        k * (pow2(102) * a[2]) +\n        k * (pow2(153) * a[3]) +\n        k * (pow2(204) * a[4])\n        ==\n        k * (\n            a[0] +\n            (pow2( 51) * a[1]) +\n            (pow2(102) * a[2]) +\n            (pow2(153) * a[3]) +\n            (pow2(204) * a[4])\n        )\n    ) by {\n        lemma_mul_is_distributive_add(k as int, a[0] as int, pow2( 51) * a[1]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1], pow2(102) * a[2]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2], pow2(153) * a[3]);\n        lemma_mul_is_distributive_add(k as int, a[0] + pow2( 51) * a[1] + pow2(102) * a[2] + pow2(153) * a[3], (pow2(204) * a[4]));\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "load8_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_squared",
                                "content": "pub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 == s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        mul_5_terms_other_way(\n            as_nat(v) as int,\n            v0 as int,\n            s1 * v1,\n            s2 * v2,\n            s3 * v3,\n            s4 * v4\n        );\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        mul_v0_and_reorder(\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        );\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        mul_si_vi_and_reorder(\n            s1 as int, v1 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        mul_si_vi_and_reorder(\n            s2 as int, v2 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        mul_si_vi_and_reorder(\n            s3 as int, v3 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        mul_si_vi_and_reorder(\n            s4 as int, v4 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n\n        // s1 terms\n        assert(\n            s1 * (v0 * v1) + s1 * (v0 * v1)\n            ==\n            s1 * (2 * (v0 * v1))\n        ) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(\n            s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2)\n            ==\n            s2 * (v1 * v1 + 2 * (v0 * v2))\n        ) by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(\n            s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3)\n            ==\n            s3 * (2 * (v1 * v2) + 2 * (v0 * v3))\n        ) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(\n            s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            ==\n            s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))\n        ) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(\n            s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4)\n            ==\n            s5 * (2 * (v2 * v3) + 2 * (v1 * v4))\n        ) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(\n            s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4)\n            ==\n            s6 * (v3 * v3 + 2 * (v2 * v4))\n        ) by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(\n            s7 * (v3 * v4) + s7 * (v3 * v4)\n            ==\n            s7 * (2 * (v3 * v4))\n        ) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        // s3 terms\n        assert(\n            s8 * c3_x19 + s3 * c3_base\n            ==\n            s3 * (s5 * c3_x19 + c3_base)\n        ) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(\n            s7 * c2_x19 + s2 * c2_base\n            ==\n            s2 * (s5 * c2_x19 + c2_base)\n        ) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(\n            s6 * c1_x19 + s1 * c1_base\n            ==\n            s1 * (s5 * c1_x19 + c1_base)\n        ) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(\n            s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19\n            ==\n            p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 )\n        ) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19, c0_x19 as int);\n        }\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_sum_factor",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_si_vi_and_reorder",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms_other_way",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_v0_and_reorder"
                                ],
                                "code_name": "load8_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn as_nat_squared(v: [u64; 5])\n    ensures\n        as_nat(v) * as_nat(v) ==\n        pow2(8 * 51) * (v[4] * v[4]) +\n        pow2(7 * 51) * (2 * (v[3] * v[4])) +\n        pow2(6 * 51) * (v[3] * v[3] + 2 * (v[2] * v[4])) +\n        pow2(5 * 51) * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])) +\n        pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n        pow2(3 * 51) * (2 * (v[1] * v[2]) + 2 * (v[0] * v[3])) +\n        pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] * v[2])) +\n        pow2(1 * 51) * (2 * (v[0] * v[1])) +\n                       (v[0] * v[0]),\n        // and the mod equality\n        (as_nat(v) * as_nat(v)) % p() ==\n        (\n            pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])) +\n            pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])) +\n            pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))) +\n            pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))) +\n                           (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4])))\n        ) as nat % p()\n{\n    let v0 = v[0];\n    let v1 = v[1];\n    let v2 = v[2];\n    let v3 = v[3];\n    let v4 = v[4];\n\n    let s1 = pow2(1 * 51);\n    let s2 = pow2(2 * 51);\n    let s3 = pow2(3 * 51);\n    let s4 = pow2(4 * 51);\n    let s5 = pow2(5 * 51);\n    let s6 = pow2(6 * 51);\n    let s7 = pow2(7 * 51);\n    let s8 = pow2(8 * 51);\n\n    assert(s1 * s1 == s2) by {\n        lemma_pow2_adds(51, 51)\n    }\n    assert(s1 * s2 == s2 * s1 == s3) by {\n        lemma_pow2_adds(51, 102)\n    }\n    assert(s1 * s3 == s3 * s1 == s4) by {\n        lemma_pow2_adds(51, 153)\n    }\n    assert(s1 * s4 == s4 * s1 == s5) by {\n        lemma_pow2_adds(51, 204)\n    }\n    assert(s2 * s2 == s4) by {\n        lemma_pow2_adds(102, 102)\n    }\n    assert(s2 * s3 == s3 * s2 == s5) by {\n        lemma_pow2_adds(102, 153)\n    }\n    assert(s2 * s4 == s4 * s2 == s6) by {\n        lemma_pow2_adds(102, 204)\n    }\n    assert(s3 * s3 == s6) by {\n        lemma_pow2_adds(153, 153)\n    }\n    assert(s3 * s4 == s4 * s3 == s7) by {\n        lemma_pow2_adds(153, 204)\n    }\n    assert(s4 * s4 == s8) by {\n        lemma_pow2_adds(204, 204)\n    }\n\n    assert(as_nat(v) * as_nat(v) ==\n        v0 * as_nat(v) +\n        (s1 * v1) * as_nat(v) +\n        (s2 * v2) * as_nat(v) +\n        (s3 * v3) * as_nat(v) +\n        (s4 * v4) * as_nat(v)\n    ) by {\n        // (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n        mul_5_terms_other_way(\n            as_nat(v) as int,\n            v0 as int,\n            s1 * v1,\n            s2 * v2,\n            s3 * v3,\n            s4 * v4\n        );\n    }\n\n    // because of the sheer number of possible associativity/distributivity groupings we have\n    // to help the solver along by intermittently asserting chunks\n    assert(v0 * as_nat(v) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n        v0 * v0\n    ) by {\n        mul_v0_and_reorder(\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        );\n    }\n\n    assert((s1 * v1) * as_nat(v) ==\n        s5 * (v1 * v4) +\n        s4 * (v1 * v3) +\n        s3 * (v1 * v2) +\n        s2 * (v1 * v1) +\n        s1 * (v0 * v1)\n    ) by {\n        mul_si_vi_and_reorder(\n            s1 as int, v1 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s2 * v2) * as_nat(v) ==\n        s6 * (v2 * v4) +\n        s5 * (v2 * v3) +\n        s4 * (v2 * v2) +\n        s3 * (v1 * v2) +\n        s2 * (v0 * v2)\n    ) by {\n        mul_si_vi_and_reorder(\n            s2 as int, v2 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s3 * v3) * as_nat(v) ==\n        s7 * (v3 * v4) +\n        s6 * (v3 * v3) +\n        s5 * (v2 * v3) +\n        s4 * (v1 * v3) +\n        s3 * (v0 * v3)\n    ) by {\n        mul_si_vi_and_reorder(\n            s3 as int, v3 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    assert((s4 * v4) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (v3 * v4) +\n        s6 * (v2 * v4) +\n        s5 * (v1 * v4) +\n        s4 * (v0 * v4)\n    ) by {\n        mul_si_vi_and_reorder(\n            s4 as int, v4 as int,\n            v0 as int,\n            s1 as int, v1 as int,\n            s2 as int, v2 as int,\n            s3 as int, v3 as int,\n            s4 as int, v4 as int\n        )\n    }\n\n    // we now mash them all together\n    assert(as_nat(v) * as_nat(v) ==\n        s8 * (v4 * v4) +\n        s7 * (2 * (v3 * v4)) +\n        s6 * (v3 * v3 + 2 * (v2 * v4)) +\n        s5 * (2 * (v2 * v3) + 2 * (v1 * v4)) +\n        s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4)) +\n        s3 * (2 * (v1 * v2) + 2 * (v0 * v3)) +\n        s2 * (v1 * v1 + 2 * (v0 * v2)) +\n        s1 * (2 * (v0 * v1)) +\n             (v0 * v0)\n    ) by {\n        // These assert(a + a = 2a) statements aren't strictly necessary, but they improve the solve time\n\n        // s1 terms\n        assert(\n            s1 * (v0 * v1) + s1 * (v0 * v1)\n            ==\n            s1 * (2 * (v0 * v1))\n        ) by {\n            assert(v0 * v1 + v0 * v1 == 2 * (v0 * v1));\n            lemma_mul_is_distributive_add(s1 as int, v0 * v1, v0 * v1);\n        }\n\n        // s2 terms\n        assert(\n            s2 * (v0 * v2) + s2 * (v1 * v1) + s2 * (v0 * v2)\n            ==\n            s2 * (v1 * v1 + 2 * (v0 * v2))\n        ) by {\n            assert(v0 * v2 + v0 * v2 == 2 * (v0 * v2));\n            lemma_mul_is_distributive_add(s2 as int, v0 * v2, v0 * v2);\n            lemma_mul_is_distributive_add(s2 as int, 2 * (v0 * v2), v1 * v1);\n        }\n\n        // s3 terms\n        assert(\n            s3 * (v0 * v3) + s3 * (v1 * v2) + s3 * (v1 * v2) + s3 * (v0 * v3)\n            ==\n            s3 * (2 * (v1 * v2) + 2 * (v0 * v3))\n        ) by {\n            assert(v1 * v2 + v1 * v2 == 2 * (v1 * v2));\n            assert(v0 * v3 + v0 * v3 == 2 * (v0 * v3));\n            lemma_mul_is_distributive_add(s3 as int, v1 * v2, v1 * v2);\n            lemma_mul_is_distributive_add(s3 as int, v0 * v3, v0 * v3);\n            lemma_mul_is_distributive_add(s3 as int, 2 * (v1 * v2), 2 * (v0 * v3));\n        }\n\n        // s4 terms\n        assert(\n            s4 * (v0 * v4) + s4 * (v1 * v3) + s4 * (v2 * v2) + s4 * (v1 * v3) + s4 * (v0 * v4)\n            ==\n            s4 * (v2 * v2 + 2 * (v1 * v3) + 2 * (v0 * v4))\n        ) by {\n            assert(v0 * v4 + v0 * v4 == 2 * (v0 * v4));\n            assert(v1 * v3 + v1 * v3 == 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v0 * v4, v0 * v4);\n            lemma_mul_is_distributive_add(s4 as int, v1 * v3, v1 * v3);\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2, 2 * (v1 * v3));\n            lemma_mul_is_distributive_add(s4 as int, v2 * v2 + 2 * (v1 * v3), 2 * (v0 * v4));\n        }\n\n        // s5 terms\n        assert(\n            s5 * (v1 * v4) + s5 * (v2 * v3) + s5 * (v2 * v3) + s5 * (v1 * v4)\n            ==\n            s5 * (2 * (v2 * v3) + 2 * (v1 * v4))\n        ) by {\n            assert(v1 * v4 + v1 * v4 == 2 * (v1 * v4));\n            assert(v2 * v3 + v2 * v3 == 2 * (v2 * v3));\n            lemma_mul_is_distributive_add(s5 as int, v1 * v4, v1 * v4);\n            lemma_mul_is_distributive_add(s5 as int, v2 * v3, v2 * v3);\n            lemma_mul_is_distributive_add(s5 as int, 2 * (v1 * v4), 2 * (v2 * v3));\n        }\n\n        // s6 terms\n        assert(\n            s6 * (v2 * v4) + s6 * (v3 * v3) + s6 * (v2 * v4)\n            ==\n            s6 * (v3 * v3 + 2 * (v2 * v4))\n        ) by {\n            assert(v2 * v4 + v2 * v4 == 2 * (v2 * v4));\n            lemma_mul_is_distributive_add(s6 as int, v2 * v4, v2 * v4);\n            lemma_mul_is_distributive_add(s6 as int, 2 * (v2 * v4), v3 * v3);\n        }\n\n        // s7 terms\n        assert(\n            s7 * (v3 * v4) + s7 * (v3 * v4)\n            ==\n            s7 * (2 * (v3 * v4))\n        ) by {\n            assert(v3 * v4 + v3 * v4 == 2 * (v3 * v4));\n            lemma_mul_is_distributive_add(s7 as int, v3 * v4, v3 * v4);\n        }\n    }\n\n    // This is the explicit version, now we can take everything mod p\n\n    // p well defined\n    pow255_gt_19();\n\n    // By definition, p = s^5 - 19\n    // equivalently,\n    // s^5 = (p + 19)\n    // s^6 = s * (p + 19)\n    // s^7 = s^2 * (p + 19)\n    // s^8 = s^3 * (p + 19)\n    assert(s5 == (p() + 19));\n\n    // we pack together terms to slim down expressions;\n\n    let c0_base = v0 *  v0;\n    let c0_x19 = 2 * (v2 * v3) + 2 * (v1 * v4);\n    let c0 = c0_base + 19 * c0_x19;\n\n    let c1_base = 2 * (v0 *  v1);\n    let c1_x19 = v3 * v3 + 2 * (v2 * v4);\n    let c1 = c1_base + 19 * c1_x19;\n\n    let c2_base = v1 * v1 + 2 * (v0 *  v2);\n    let c2_x19 = 2 * (v3 * v4);\n    let c2 = c2_base + 19 * c2_x19;\n\n    let c3_base = 2 * (v1 *  v2) + 2 * (v0 *  v3);\n    let c3_x19 = v4 * v4;\n    let c3 = c3_base + 19 * c3_x19;\n\n    let c4 = v2 *  v2 + 2 * (v1 *  v3) + 2 * (v0 *  v4);\n\n    // group in preparation for the substitution\n    assert(as_nat(v) * as_nat(v) ==\n        s4 * c4 +\n        s3 * (s5 * c3_x19 + c3_base) +\n        s2 * (s5 * c2_x19 + c2_base) +\n        s1 * (s5 * c1_x19 + c1_base) +\n             (s5 * c0_x19 + c0_base)\n    ) by {\n        // s3 terms\n        assert(\n            s8 * c3_x19 + s3 * c3_base\n            ==\n            s3 * (s5 * c3_x19 + c3_base)\n        ) by {\n            assert(s8 == (s3 * s5)) by {\n                lemma_pow2_adds(3 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s3 as int, s5 as int, c3_x19);\n            lemma_mul_is_distributive_add(s3 as int, s5 * c3_x19, c3_base)\n        }\n\n        // s2 terms\n        assert(\n            s7 * c2_x19 + s2 * c2_base\n            ==\n            s2 * (s5 * c2_x19 + c2_base)\n        ) by {\n            assert(s7 == (s2 * s5)) by {\n                lemma_pow2_adds(2 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s2 as int, s5 as int, c2_x19);\n            lemma_mul_is_distributive_add(s2 as int, s5 * c2_x19, c2_base)\n        }\n\n        // s1 terms\n        assert(\n            s6 * c1_x19 + s1 * c1_base\n            ==\n            s1 * (s5 * c1_x19 + c1_base)\n        ) by {\n            assert(s6 == (s1 * s5)) by {\n                lemma_pow2_adds(1 * 51, 5 * 51);\n            }\n            lemma_mul_is_associative(s1 as int, s5 as int, c1_x19);\n            lemma_mul_is_distributive_add(s1 as int, s5 * c1_x19, c1_base)\n        }\n    }\n\n    // Next we use the identity s5 = p + 19\n    assert(s5 * c3_x19 + c3_base == p() * c3_x19 + c3) by {\n        lemma_mul_is_distributive_add(c3_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c2_x19 + c2_base == p() * c2_x19 + c2) by {\n        lemma_mul_is_distributive_add(c2_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c1_x19 + c1_base == p() * c1_x19 + c1) by {\n        lemma_mul_is_distributive_add(c1_x19 as int, p() as int, 19);\n    }\n\n    assert(s5 * c0_x19 + c0_base == p() * c0_x19 + c0) by {\n        lemma_mul_is_distributive_add(c0_x19 as int, p() as int, 19);\n    }\n\n    // in summary, we can reorder and regroup terms to get X * p() + Y\n    assert(as_nat(v) * as_nat(v) ==\n        p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 ) +\n        (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        )\n    ) by {\n        lemma_mul_is_distributive_add(s3 as int, p() * c3_x19, c3 as int);\n        lemma_mul_is_distributive_add(s2 as int, p() * c2_x19, c2 as int);\n        lemma_mul_is_distributive_add(s1 as int, p() * c1_x19, c1 as int);\n\n        assert(\n            s3 * (p() * c3_x19) + s2 * (p() * c2_x19) + s1 * (p() * c1_x19) + p() * c0_x19\n            ==\n            p() * ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 )\n        ) by {\n            lemma_mul_is_associative(s3 as int, c3_x19 as int, p() as int);\n            lemma_mul_is_associative(s2 as int, c2_x19 as int, p() as int);\n            lemma_mul_is_associative(s1 as int, c1_x19 as int, p() as int);\n\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19, s2 * c2_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19, s1 * c1_x19);\n            lemma_mul_is_distributive_add(p() as int, s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19, c0_x19 as int);\n        }\n    }\n\n\n    let k = ( s3 * c3_x19 + s2 * c2_x19 + s1 * c1_x19 + c0_x19 );\n    let sum = (\n            s4 * c4 +\n            s3 * c3 +\n            s2 * c2 +\n            s1 * c1 +\n                 c0\n        );\n\n    assert(as_nat(v) * as_nat(v) == k * p() + sum);\n    assert(k * p() + sum == (k as nat) * p() + (sum as nat));\n\n    // Now, we simply move to mod p\n\n    assert((as_nat(v) * as_nat(v)) % p() == ((k as nat) * p() + (sum as nat)) % p() );\n    assert(\n        ((k as nat) * p() + (sum as nat)) % p() ==\n        (sum as nat) % p()\n    ) by {\n        lemma_mod_sum_factor(k as int, sum as int, p() as int);\n    }\n\n    // sanity check\n    assert(s4 * c4 == pow2(4 * 51) * (v[2] * v[2] + 2 * (v[1] * v[3]) + 2 * (v[0] * v[4])));\n    assert(s3 * c3 == pow2(3 * 51) * (2 * (v[1] *  v[2]) + 2 * (v[0] *  v[3]) + 19 * (v[4] * v[4])));\n    assert(s2 * c2 == pow2(2 * 51) * (v[1] * v[1] + 2 * (v[0] *  v[2]) + 19 * (2 * (v[3] * v[4]))));\n    assert(s1 * c1 == pow2(1 * 51) * (2 * (v[0] *  v[1]) + 19 * (v[3] * v[3] + 2 * (v[2] * v[4]))));\n    assert(c0 == (v[0] *  v[0] + 19 * (2 * (v[2] * v[3]) + 2 * (v[1] * v[4]))));\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/lemma_neg_no_underflow",
                                "content": "pub proof fn lemma_neg_no_underflow(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)\n    ensures\n        all_neg_limbs_positive(limbs)\n\n{\n    lemma2_to64_rest(); // pow2(51)\n    assert forall |i: int| 0 <= i < 5 implies limbs[i] < 16 * (pow2(51) - 19) by {\n        shift_is_pow2(51);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/all_neg_limbs_positive",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                                ],
                                "code_name": "variable_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_neg_no_underflow(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)\n    ensures\n        all_neg_limbs_positive(limbs)\n\n{\n    lemma2_to64_rest(); // pow2(51)\n    assert forall |i: int| 0 <= i < 5 implies limbs[i] < 16 * (pow2(51) - 19) by {\n        shift_is_pow2(51);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "variable_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/negate_proof",
                                "content": "pub proof fn negate_proof(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n        all_neg_limbs_positive(limbs)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_negate(limbs)[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, as_nat((c0, c, c, c, c)) = p, so\n        // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n        // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        as_nat(spec_negate(limbs)) == 16 * p() - as_nat(limbs) - p() * ((36028797018963952u64 - limbs[4]) as u64 >> 51),\n        (as_nat(spec_negate(limbs)) + as_nat(limbs)) % p() == 0\n{\n\n    lemma_reduce(pre_reduce_limbs(limbs));\n\n    let c0 = (pow2(51) - 19);\n    let c  = (pow2(51) - 1);\n    lemma2_to64_rest(); // get pow2(51)\n    // solver knows 36028797018963664u64 == 16 * c0\n    // solver knows 36028797018963952u64 == 16 * c;\n\n    lemma_neg_no_underflow(limbs);\n\n    // Introduce 16p as a vector\n    let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n    assert(as_nat(v) == 16 * p()) by {\n        // by definition of as_nat\n        assert( as_nat(v) ==\n            16 * c0 +\n            pow2(51) * (16 * c) +\n            pow2(102) * (16 * c) +\n            pow2(153) * (16 * c) +\n            pow2(204) * (16 * c)\n        );\n\n        // solver can reorder factors and pull out 16 on its own\n        // ...\n\n        // Write out `c`s and sum up powers\n        assert( p() ==\n            c0 +\n            pow2(51) * c +\n            pow2(102) * c +\n            pow2(153) * c +\n            pow2(204) * c\n        ) by {\n            lemma_pow2_adds(51, 51);\n            lemma_pow2_adds(51, 102);\n            lemma_pow2_adds(51, 153);\n            lemma_pow2_adds(51, 204);\n        }\n    }\n\n    let l0 = limbs[0];\n    let l1 = limbs[1];\n    let l2 = limbs[2];\n    let l3 = limbs[3];\n    let l4 = limbs[4];\n\n    assert(as_nat([\n        (16 * c0 - l0) as u64,\n        (16 * c - l1) as u64,\n        (16 * c - l2) as u64,\n        (16 * c - l3) as u64,\n        (16 * c - l4) as u64,\n        ]) == as_nat(v) - as_nat(limbs)\n    ) by {\n        lemma_as_nat_sub(v, limbs);\n    }\n\n    let k = (16 * c - l4) as u64 >> 51;\n\n    assert(\n        16 * p() - as_nat(limbs) - p() * k + as_nat(limbs)\n        ==\n        p() * (16 - k)\n    ) by {\n        lemma_mul_is_distributive_sub(p() as int, 16, k as int)\n    }\n\n    assert((p() * (16 - k)) as nat % p() == 0) by {\n        assert(k <= 16) by {\n            assert(k <= (16 * pow2(51)) as u64 >> 51) by {\n                lemma_shr_le_u64((16 * c - l4) as u64, (16 * pow2(51)) as u64, 51);\n            }\n            // 16 * 2^51 / 2^51 = 16\n            assert(((16 * 0x8000000000000) as u64 >> 51) == 16) by (compute);\n        }\n        lemma_mod_multiples_basic((16 - k) as int, p() as int);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/lemma_as_nat_sub",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_negate",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pre_reduce_limbs",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/lemma_neg_no_underflow",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shr_le_u64",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/all_neg_limbs_positive"
                                ],
                                "code_name": "variable_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn negate_proof(limbs: [u64; 5])\n    requires\n        forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),\n        all_neg_limbs_positive(limbs)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_negate(limbs)[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, as_nat((c0, c, c, c, c)) = p, so\n        // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n        // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        as_nat(spec_negate(limbs)) == 16 * p() - as_nat(limbs) - p() * ((36028797018963952u64 - limbs[4]) as u64 >> 51),\n        (as_nat(spec_negate(limbs)) + as_nat(limbs)) % p() == 0\n{\n\n    lemma_reduce(pre_reduce_limbs(limbs));\n\n    let c0 = (pow2(51) - 19);\n    let c  = (pow2(51) - 1);\n    lemma2_to64_rest(); // get pow2(51)\n    // solver knows 36028797018963664u64 == 16 * c0\n    // solver knows 36028797018963952u64 == 16 * c;\n\n    lemma_neg_no_underflow(limbs);\n\n    // Introduce 16p as a vector\n    let v = [(16 * c0) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64,(16 * c) as u64];\n\n    assert(as_nat(v) == 16 * p()) by {\n        // by definition of as_nat\n        assert( as_nat(v) ==\n            16 * c0 +\n            pow2(51) * (16 * c) +\n            pow2(102) * (16 * c) +\n            pow2(153) * (16 * c) +\n            pow2(204) * (16 * c)\n        );\n\n        // solver can reorder factors and pull out 16 on its own\n        // ...\n\n        // Write out `c`s and sum up powers\n        assert( p() ==\n            c0 +\n            pow2(51) * c +\n            pow2(102) * c +\n            pow2(153) * c +\n            pow2(204) * c\n        ) by {\n            lemma_pow2_adds(51, 51);\n            lemma_pow2_adds(51, 102);\n            lemma_pow2_adds(51, 153);\n            lemma_pow2_adds(51, 204);\n        }\n    }\n\n    let l0 = limbs[0];\n    let l1 = limbs[1];\n    let l2 = limbs[2];\n    let l3 = limbs[3];\n    let l4 = limbs[4];\n\n    assert(as_nat([\n        (16 * c0 - l0) as u64,\n        (16 * c - l1) as u64,\n        (16 * c - l2) as u64,\n        (16 * c - l3) as u64,\n        (16 * c - l4) as u64,\n        ]) == as_nat(v) - as_nat(limbs)\n    ) by {\n        lemma_as_nat_sub(v, limbs);\n    }\n\n    let k = (16 * c - l4) as u64 >> 51;\n\n    assert(\n        16 * p() - as_nat(limbs) - p() * k + as_nat(limbs)\n        ==\n        p() * (16 - k)\n    ) by {\n        lemma_mul_is_distributive_sub(p() as int, 16, k as int)\n    }\n\n    assert((p() * (16 - k)) as nat % p() == 0) by {\n        assert(k <= 16) by {\n            assert(k <= (16 * pow2(51)) as u64 >> 51) by {\n                lemma_shr_le_u64((16 * c - l4) as u64, (16 * pow2(51)) as u64, 51);\n            }\n            // 16 * 2^51 / 2^51 = 16\n            assert(((16 * 0x8000000000000) as u64 >> 51) == 16) by (compute);\n        }\n        lemma_mod_multiples_basic((16 - k) as int, p() as int);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/all_neg_limbs_positive",
                                "content": "pub open spec fn all_neg_limbs_positive(limbs: [u64; 5]) -> bool\n{\n    &&& 36028797018963664u64 >= limbs[0]\n    &&& 36028797018963952u64 >= limbs[1]\n    &&& 36028797018963952u64 >= limbs[2]\n    &&& 36028797018963952u64 >= limbs[3]\n    &&& 36028797018963952u64 >= limbs[4]\n}",
                                "code_name": "variable_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub open spec fn all_neg_limbs_positive(limbs: [u64; 5]) -> bool\n{\n    &&& 36028797018963664u64 >= limbs[0]\n    &&& 36028797018963952u64 >= limbs[1]\n    &&& 36028797018963952u64 >= limbs[2]\n    &&& 36028797018963952u64 >= limbs[3]\n    &&& 36028797018963952u64 >= limbs[4]\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_boundaries",
                                "content": "pub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_lt",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shifted_lt",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/masked_lt_51"
                                ],
                                "code_name": "vartime_double_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_boundaries(limbs: [u64; 5])\n    ensures\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) < (1u64 << 52),\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) < (1u64 << 52),\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) < (1u64 << 52),\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) < (1u64 << 52),\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) < (1u64 << 52)\n\n{\n    // \\A i. limbs[i] < 2^13\n    shifted_lt(limbs[0], 51);\n    shifted_lt(limbs[1], 51);\n    shifted_lt(limbs[2], 51);\n    shifted_lt(limbs[3], 51);\n    shifted_lt(limbs[4], 51);\n\n    // \\A i. limbs[i] & mask51 < 2^51\n    masked_lt_51(limbs[0]);\n    masked_lt_51(limbs[1]);\n    masked_lt_51(limbs[2]);\n    masked_lt_51(limbs[3]);\n    masked_lt_51(limbs[4]);\n\n    // Since 19 < 2^5 and (limbs[4] >> 51) < 2^13, their product is less than 2^18\n    assert((limbs[4] >> 51) * 19 < (1u64 << 18) as nat) by {\n        assert(19 < (1u64 << 5)) by (bit_vector);\n        shift_is_pow2(5);\n        shift_is_pow2(13);\n        shift_is_pow2(18);\n        lemma_pow2_adds(13, 5);\n        // If (limbs[4] >> 51) < 2^13 and 19 < 2^5 then their product is less than 2^18\n        mul_lt((limbs[4] >> 51) as nat, (1u64 << 13) as nat, 19nat, (1u64 << 5) as nat);\n    }\n\n    // The final values (limbs[i] += cX) are all bounded by 2^51 + eps, for eps \\in {2^18, 2^13}.\n    assert(((1u64 << 18)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n    assert(((1u64 << 13)) + (1u64 << 51) < (1u64 << 52)) by (bit_vector);\n\n    // In summary, they're all bounded by 2^52\n    // The solver can prove this automatically\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "vartime_double_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
                                "content": "pub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & mask51\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & mask51 == limbs[i] by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & mask51);\n    let b1 = (limbs[1] & mask51);\n    let b2 = (limbs[2] & mask51);\n    let b3 = (limbs[3] & mask51);\n    let b4 = (limbs[4] & mask51);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_boundaries",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_div_and_mod_51",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_two_factoring_51"
                                ],
                                "code_name": "vartime_double_base.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_reduce(limbs: [u64; 5])\n    ensures\n        forall|i: int| 0 <= i < 5 ==> spec_reduce(limbs)[i] < (1u64 << 52),\n        // Suppose l = (l0, l1, l2, l3, l4) are the input limbs.\n        // They represent a number\n        // e(l) =  l0 + l1 * 2^51 + l2 * 2^102 + l3 * 2^153 + l4 * 2^204\n        // in Z_p, for p = 2^255 - 19\n        // reduce(l) returns v = (v0, v1, v2, v3, v4), such that\n        // v0 = 19 * a4 + b0\n        // v1 =      a0 + b1\n        // v2 =      a1 + b2\n        // v3 =      a2 + b3\n        // v4 =      a3 + b4\n        // where ai = li >> 51 and bi = li & mask51\n        // we can reformulate this as ai = li / 2^51 (flooring division) and bi = li % 2^51\n        // Using the following identity connecting integer division and remainder:\n        // x = y * (x / y) + x % y\n        // we can see that li = ai * 2^51 + bi\n        // Plugging the above identities into the equations for v, we can observe that\n        // e(v) = e(l) - p * (l4 >> 51)\n        // IOW, e(reduce(l)) = e(l) (mod p)\n        // additionally, if all limbs are below 2^51, reduce(l) = l\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (spec_reduce(limbs) =~= limbs),\n        as_nat(spec_reduce(limbs)) == as_nat(limbs) - p() * (limbs[4] >> 51)\n{\n\n    // -----\n    // reduce identity for small limbs\n\n    // Can't seem to reference r within this proof block, we reconstruct it here\n    let rr: [u64; 5] = spec_reduce(limbs);\n\n    assert((forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) ==> (rr =~= limbs)) by {\n        if (forall|i: int| 0 <= i < 5 ==> #[trigger] limbs[i] < (1u64 << 51)) {\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] & mask51 == limbs[i] by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_low_bits_mask_is_mod(limbs[i], 51);\n                lemma_small_mod(limbs[i] as nat, pow2(51));\n            }\n            assert forall|i: int| 0 <= i < 5 implies #[trigger] limbs[i] >> 51 == 0 by {\n                l51_bit_mask_lt(); // mask51 = low_bits_mask(51)\n                shift_is_pow2(51);\n                lemma_u64_shr_is_div(limbs[i], 51);\n                lemma_basic_div(limbs[i] as int, pow2(51) as int);\n            }\n        }\n    }\n\n    // -- as_nat identity\n\n    // ai = limbs[i] / 2^52\n    let a0 = (limbs[0] >> 51);\n    let a1 = (limbs[1] >> 51);\n    let a2 = (limbs[2] >> 51);\n    let a3 = (limbs[3] >> 51);\n    let a4 = (limbs[4] >> 51);\n\n    // bi = limbs[i] % 2^52\n    let b0 = (limbs[0] & mask51);\n    let b1 = (limbs[1] & mask51);\n    let b2 = (limbs[2] & mask51);\n    let b3 = (limbs[3] & mask51);\n    let b4 = (limbs[4] & mask51);\n\n    lemma_boundaries(limbs);\n\n    // distribute\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(102) * a1 + pow2(102) * b2 +\n        pow2(153) * a2 + pow2(153) * b3 +\n        pow2(204) * a3 + pow2(204) * b4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, a0 as int, b1 as int);\n        lemma_mul_is_distributive_add(pow2(102) as int, a1 as int, b2 as int);\n        lemma_mul_is_distributive_add(pow2(153) as int, a2 as int, b3 as int);\n        lemma_mul_is_distributive_add(pow2(204) as int, a3 as int, b4 as int);\n    }\n\n    // factor out\n    assert(as_nat(rr) ==\n        19 *  a4 + b0 +\n        pow2(51) * a0 + pow2(51) * b1 +\n        pow2(51) * (pow2(51) * a1) + pow2(102) * b2 +\n        pow2(102) * (pow2(51) * a2) + pow2(153) * b3 +\n        pow2(153) * (pow2(51) * a3) + pow2(204) * b4\n    ) by {\n        lemma_two_factoring_51(51, a1);\n        lemma_two_factoring_51(102, a2);\n        lemma_two_factoring_51(153, a3);\n    }\n\n    // change groupings\n    assert(as_nat(rr) ==\n        (b0 + pow2(51) * a0) +\n        pow2(51) * (b1 + pow2(51) * a1) +\n        pow2(102) * (b2 + pow2(51) * a2) +\n        pow2(153) * (b3 + pow2(51) * a3) +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_mul_is_distributive_add(pow2( 51) as int, b1 as int, pow2(51) * a1);\n        lemma_mul_is_distributive_add(pow2(102) as int, b2 as int, pow2(51) * a2);\n        lemma_mul_is_distributive_add(pow2(153) as int, b3 as int, pow2(51) * a3);\n    }\n\n    // invoke div/mod identity\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * b4 + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a0, b0, limbs[0]);\n        lemma_div_and_mod_51(a1, b1, limbs[1]);\n        lemma_div_and_mod_51(a2, b2, limbs[2]);\n        lemma_div_and_mod_51(a3, b3, limbs[3]);\n    }\n\n    // Add missing limbs[4] parts\n    assert(as_nat(rr) ==\n        limbs[0] +\n        pow2(51) * limbs[1] +\n        pow2(102) * limbs[2] +\n        pow2(153) * limbs[3] +\n        pow2(204) * limbs[4] - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    ) by {\n        lemma_div_and_mod_51(a4, b4, limbs[4]);\n        assert(pow2(204) * limbs[4] == pow2(204) * b4 + pow2(204)* (pow2(51) * a4)) by {\n            lemma_mul_is_distributive_add(pow2(204) as int, pow2(51) * a4 as int, b4 as int);\n        }\n    }\n\n    // The solver can collect components of as_nat(limbs) automatically:\n    // as_nat(rr) == as_nat(limbs) - pow2(204) * (pow2(51) * a4 ) + 19 * a4\n    // ... as well as pull in minus\n    // as_nat(rr) == as_nat(limbs) - (pow2(204) * (pow2(51) * a4 ) - 19 * a4)\n\n    // collect components of p() * a4\n    assert(pow2(204) * (pow2(51) * a4) - 19 * a4 == p() * a4) by {\n        lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, a4 as int);\n        lemma_pow2_adds(204, 51);\n        lemma_mul_is_distributive_sub_other_way(a4 as int, pow2(255) as int, 19 );\n        pow255_gt_19(); // we need to prove 2^255 - 19 doesn't underflow\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_mul_sub",
                                "content": "pub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51) * cj_0\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}",
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_mul_sub(ci: int, cj: int, cj_0: int, k: nat)\n    ensures\n        pow2(k) * (ci - pow2(51) * (cj - cj_0)) == pow2(k) * ci - pow2(k + 51) * cj + pow2(k + 51) * cj_0\n{\n    // 2^k (ci - X) = 2^k ci - 2^k X\n    lemma_mul_is_distributive_sub(pow2(k) as int, ci, pow2(51) * (cj - cj_0));\n    // 2^k (2^51 * Y) = (2^k * 2^51) * Y\n    lemma_mul_is_associative(pow2(k) as int, pow2(51) as int, cj - cj_0);\n    // 2^k * 2^51 = 2^(k + 51)\n    lemma_pow2_adds(k, 51);\n    // 2^(k + 51) * (cj - cj_0) = 2^(k + 51) * cj - 2^(k + 51) * cj_0\n    lemma_mul_is_distributive_sub(pow2(k + 51) as int, cj, cj_0);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_le",
                                "content": "pub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b\n    ensures\n        (a >> 51) <= (b >> 51)\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest(); // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}",
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_shr_51_le(a: u128, b: u128)\n    requires\n        a <= b\n    ensures\n        (a >> 51) <= (b >> 51)\n{\n    lemma_pow2_pos(51);\n    lemma2_to64_rest(); // pow2(51) value\n    lemma_u128_shr_is_div(a, 51);\n    lemma_u128_shr_is_div(b, 51);\n    lemma_div_is_ordered(a as int, b as int, 51);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/masked_lt_51",
                                "content": "pub proof fn masked_lt_51(v: u64)\n    ensures\n        v & mask51 < (1u64 << 51),\n{\n    l51_bit_mask_lt(); // mask51 == low_bits_mask(51)\n    masked_lt(v, 51);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/masked_lt",
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt"
                                ],
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn masked_lt_51(v: u64)\n    ensures\n        v & mask51 < (1u64 << 51),\n{\n    l51_bit_mask_lt(); // mask51 == low_bits_mask(51)\n    masked_lt(v, 51);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_cast_then_mask_51",
                                "content": "pub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128)\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}",
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub broadcast proof fn lemma_cast_then_mask_51(x: u128)\n    ensures\n        #![trigger (x as u64) & mask51]\n        (x as u64) & mask51 == x & (mask51 as u128)\n{\n    assert((x as u64) & 2251799813685247u64 == x & (2251799813685247u64 as u128)) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_fits_u64",
                                "content": "pub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51\n    ensures\n        (a >> 51) <= (u64::MAX as u128)\n\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_le"
                                ],
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_shr_51_fits_u64(a: u128)\n    requires\n        a <= (u64::MAX as u128) << 51\n    ensures\n        (a >> 51) <= (u64::MAX as u128)\n\n{\n    assert(((u64::MAX as u128) << 51) >> 51 == (u64::MAX as u128)) by (compute);\n    lemma_shr_51_le(a, (u64::MAX as u128) << 51);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_add_then_shift",
                                "content": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                                ],
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_add_then_shift(a: u64, b: u64)\n    requires\n        a < (1u64 << 52),\n        b < (1u64 << 52)\n    ensures\n        (a + b) < (1u64 << 53),\n        ((a + b) as u64 >> 51) < 4\n{\n    lemma2_to64_rest();\n    assert((a + b) < 1u64 << 53) by {\n        assert((1u64 << 52) + (1u64 << 52) == 1u64 << 53) by (compute);\n    }\n    assert(1u64 << 53 == (1u64 << 51) * 4) by (bit_vector);\n    // 0 < b  /\\ a < b * c => a/b < c\n    lemma_multiply_divide_lt((a + b) as int, (1u64 << 51) as int, 4int);\n    shift_is_pow2(51);\n    shift_is_pow2(53);\n    assert((a + b) as u64 >> 51 == (a + b) as u64 / (pow2(51) as u64)) by {\n        lemma_u64_shr_is_div((a + b) as u64, 51);\n    }\n    assert(pow2(53) / pow2(51) == 4) by {\n        lemma_pow2_subtracts(51, 53);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_cast_then_mod_51",
                                "content": "pub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128)\n{\n    lemma2_to64_rest(); // pow2(51 | 64)\n    assert( (x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}",
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_cast_then_mod_51(x: u128)\n    ensures\n        (x as u64) % (pow2(51) as u64) == x % (pow2(51) as u128)\n{\n    lemma2_to64_rest(); // pow2(51 | 64)\n    assert( (x as u64) % 0x8000000000000 == x % 0x8000000000000) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_two_factoring_51",
                                "content": "pub proof fn lemma_two_factoring_51(k : nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai)\n{\n    lemma_two_factoring(k, 51, ai);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_two_factoring"
                                ],
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_two_factoring_51(k : nat, ai: u64)\n    ensures\n        pow2(k + 51) * ai == pow2(k) * (pow2(51) * ai)\n{\n    lemma_two_factoring(k, 51, ai);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_div_and_mod_51",
                                "content": "pub proof fn lemma_div_and_mod_51(ai:u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & mask51\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi\n{\n    l51_bit_mask_lt(); // mask51 == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_div_and_mod"
                                ],
                                "code_name": "negate_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_div_and_mod_51(ai:u64, bi: u64, v: u64)\n    requires\n        ai == v >> 51,\n        bi == v & mask51\n    ensures\n        ai == v / (pow2(51) as u64),\n        bi == v % (pow2(51) as u64),\n        v == ai * pow2(51) + bi\n{\n    l51_bit_mask_lt(); // mask51 == low_bits_mask(51)\n    lemma_div_and_mod(ai, bi, v, 51);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs/select",
                            "content": "pub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures reveal_choice(c) == RevealedChoice::Choice0 ==> res == a,\n            reveal_choice(c) == RevealedChoice::Choice1 ==> res == b\n{\n    u64::conditional_select(a, b, c)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs/reveal_choice"
                            ],
                            "code_name": "mul_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures reveal_choice(c) == RevealedChoice::Choice0 ==> res == a,\n            reveal_choice(c) == RevealedChoice::Choice1 ==> res == b\n{\n    u64::conditional_select(a, b, c)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs/reveal_choice",
                            "content": "pub uninterp spec fn reveal_choice(c: Choice) -> RevealedChoice;\n\npub assume_specification [Choice::from](u: u8) -> (c: Choice)\n    ensures u == 0 ==> reveal_choice(c) == RevealedChoice::Choice0,\n            u == 1 ==> reveal_choice(c) == RevealedChoice::Choice1;\n\n#[verifier::external_body]\n/// See https://docs.rs/subtle/latest/subtle/trait.ConditionallySelectable.html#tymethod.conditional_select\npub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures reveal_choice(c) == RevealedChoice::Choice0 ==> res == a,\n            reveal_choice(c) == RevealedChoice::Choice1 ==> res == b\n{\n    u64::conditional_select(a, b, c)\n}",
                            "code_name": "mul_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub uninterp spec fn reveal_choice(c: Choice) -> RevealedChoice;\n\npub assume_specification [Choice::from](u: u8) -> (c: Choice)\n    ensures u == 0 ==> reveal_choice(c) == RevealedChoice::Choice0,\n            u == 1 ==> reveal_choice(c) == RevealedChoice::Choice1;\n\n#[verifier::external_body]\n/// See https://docs.rs/subtle/latest/subtle/trait.ConditionallySelectable.html#tymethod.conditional_select\npub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures reveal_choice(c) == RevealedChoice::Choice0 ==> res == a,\n            reveal_choice(c) == RevealedChoice::Choice1 ==> res == b\n{\n    u64::conditional_select(a, b, c)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/lemma_m",
                                "content": "pub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128)\n{\n    mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_lt"
                                ],
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_m(x: u64, y: u64, bx: u64, by: u64)\n    requires\n        x < bx,\n        y < by\n    ensures\n        (x as u128) * (y as u128) < (bx as u128) * (by as u128)\n{\n    mul_lt(x as nat, bx as nat, y as nat, by as nat);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms_other_way",
                                "content": "pub proof fn mul_5_terms_other_way(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add_other_way(n, x1, x2);\n}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_5_terms_other_way(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        (x1 + x2 + x3 + x4 + x5) * n == x1 * n + x2 * n + x3 * n + x4 * n + x5 * n\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add_other_way(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add_other_way(n, x1, x2);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_quad_prod",
                                "content": "pub proof fn mul_quad_prod(a1: int, b1: int, a2: int, b2: int)\n    ensures\n        (a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2)\n{\n    // commutativity is baked-in\n\n    // (a1 * b1) * (a2 * b2) =  ((a1 * b1) * a2) * b2\n    lemma_mul_is_associative(a1 * b1, a2, b2);\n    // (a1 * b1) * a2 = a2 * (a1 * b1) = (a2 * a1) * b1\n    lemma_mul_is_associative(a2, a1, b1);\n    // ((a2 * a1) * b1) * b2 = (a2 * a1) * (b1 * b2)\n    lemma_mul_is_associative(a2 * a1, b1, b2);\n}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_quad_prod(a1: int, b1: int, a2: int, b2: int)\n    ensures\n        (a1 * b1) * (a2 * b2) == (a1 * a2) * (b1 * b2)\n{\n    // commutativity is baked-in\n\n    // (a1 * b1) * (a2 * b2) =  ((a1 * b1) * a2) * b2\n    lemma_mul_is_associative(a1 * b1, a2, b2);\n    // (a1 * b1) * a2 = a2 * (a1 * b1) = (a2 * a1) * b1\n    lemma_mul_is_associative(a2, a1, b1);\n    // ((a2 * a1) * b1) * b2 = (a2 * a1) * (b1 * b2)\n    lemma_mul_is_associative(a2 * a1, b1, b2);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_si_vi_and_reorder",
                                "content": "pub proof fn mul_si_vi_and_reorder(\n    si: int, vi: int,\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        (si     ) * (vi * v0) +\n        (si * s1) * (vi * v1) +\n        (si * s2) * (vi * v2) +\n        (si * s3) * (vi * v3) +\n        (si * s4) * (vi * v4)\n{\n    // n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n    mul_5_terms(\n        si * vi,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    assert(\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4)\n        ==\n        (si * vi) * v0 +\n        (si * vi) * (s1 * v1) +\n        (si * vi) * (s2 * v2) +\n        (si * vi) * (s3 * v3) +\n        (si * vi) * (s4 * v4)\n    );\n\n    lemma_mul_is_associative(si, vi, v0);\n    mul_quad_prod(si, vi, s1, v1);\n    mul_quad_prod(si, vi, s2, v2);\n    mul_quad_prod(si, vi, s3, v3);\n    mul_quad_prod(si, vi, s4, v4);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_quad_prod",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms"
                                ],
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_si_vi_and_reorder(\n    si: int, vi: int,\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        (si     ) * (vi * v0) +\n        (si * s1) * (vi * v1) +\n        (si * s2) * (vi * v2) +\n        (si * s3) * (vi * v3) +\n        (si * s4) * (vi * v4)\n{\n    // n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n    mul_5_terms(\n        si * vi,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    assert(\n        (si * vi) * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4)\n        ==\n        (si * vi) * v0 +\n        (si * vi) * (s1 * v1) +\n        (si * vi) * (s2 * v2) +\n        (si * vi) * (s3 * v3) +\n        (si * vi) * (s4 * v4)\n    );\n\n    lemma_mul_is_associative(si, vi, v0);\n    mul_quad_prod(si, vi, s1, v1);\n    mul_quad_prod(si, vi, s2, v2);\n    mul_quad_prod(si, vi, s3, v3);\n    mul_quad_prod(si, vi, s4, v4);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_lt",
                                "content": "pub proof fn mul_lt(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    }\n    else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1  as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_lt(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 < b1,\n        a2 < b2,\n    ensures\n        a1 * a2 < b1 * b2,\n{\n    if (a2 == 0) {\n        assert(b1 * b2 > 0) by {\n            // a * b != 0 <==> a != 0 /\\ b != 0\n            lemma_mul_nonzero(b1 as int, b2 as int);\n        }\n    }\n    else {\n        // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n        lemma_mul_strict_inequality(a1 as int, b1  as int, a2 as int);\n        // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n        lemma_mul_strict_inequality(a2 as int, b2 as int, b1 as int);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
                                "content": "pub proof fn mul_le(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1  as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_le(a1:nat, b1:nat, a2:nat, b2:nat)\n    requires\n        a1 <= b1,\n        a2 <= b2,\n    ensures\n        a1 * a2 <= b1 * b2,\n{\n    // a1 < b1 /\\ a2 > 0 ==> a1 * a2 < b1 * a2\n    lemma_mul_inequality(a1 as int, b1  as int, a2 as int);\n    // a2 < b2 /\\ b2 > 0 ==> a2 * b1 < b2 * b1\n    lemma_mul_inequality(a2 as int, b2 as int, b1 as int);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_v0_and_reorder",
                                "content": "pub proof fn mul_v0_and_reorder(\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        v0 * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n             (v0 * v0)\n{\n    mul_5_terms(\n        v0,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    lemma_mul_is_associative(v0, v1, s1);\n    lemma_mul_is_associative(v0, v2, s2);\n    lemma_mul_is_associative(v0, v3, s3);\n    lemma_mul_is_associative(v0, v4, s4);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms"
                                ],
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_v0_and_reorder(\n    v0: int,\n    s1: int, v1: int,\n    s2: int, v2: int,\n    s3: int, v3: int,\n    s4: int, v4: int\n)\n    ensures\n        v0 * (v0 + s1 * v1 + s2 * v2 + s3 * v3 + s4 * v4) ==\n        s4 * (v0 * v4) +\n        s3 * (v0 * v3) +\n        s2 * (v0 * v2) +\n        s1 * (v0 * v1) +\n             (v0 * v0)\n{\n    mul_5_terms(\n        v0,\n        v0,\n        s1 * v1,\n        s2 * v2,\n        s3 * v3,\n        s4 * v4\n    );\n\n    lemma_mul_is_associative(v0, v1, s1);\n    lemma_mul_is_associative(v0, v2, s2);\n    lemma_mul_is_associative(v0, v3, s3);\n    lemma_mul_is_associative(v0, v4, s4);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_5_terms",
                                "content": "pub proof fn mul_5_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add(n, x1, x2);\n}",
                                "code_name": "bit_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn mul_5_terms(n: int, x1: int, x2: int, x3: int, x4: int, x5: int)\n    ensures\n        n * (x1 + x2 + x3 + x4 + x5) == n * x1 + n * x2 + n * x3 + n * x4 + n * x5\n{\n    // N * ((((x0 + x1) + x2) + x3) + x4) = N * (((x0 + x1) + x2) + x3) + N * x4\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3 + x4, x5);\n    // N * (((x0 + x1) + x2) + x3) = N * ((x0 + x1) + x2) + N * x3\n    lemma_mul_is_distributive_add(n, x1 + x2 + x3, x4);\n    // N * ((x0 + x1) + x2) = N * (x0 + x1) + N * x2\n    lemma_mul_is_distributive_add(n, x1 + x2, x3);\n    // N * (x0 + x1) = N * x0 + N * x1\n    lemma_mul_is_distributive_add(n, x1, x2);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_zero_is_id",
                                "content": "pub broadcast proof fn shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v\n{\n    assert(v >> 0 == v) by (bit_vector);\n}",
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub broadcast proof fn shr_zero_is_id(v: u64)\n    ensures\n        #![trigger v >> 0]\n        v >> 0 == v\n{\n    assert(v >> 0 == v) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                                "content": "pub proof fn shift_is_pow2(k: nat)\n    requires\n        k < 64,\n    ensures\n        (1u64 << k) == pow2(k)\n{\n    pow2_le_max64(k);\n    lemma_u64_shl_is_mul(1u64, k as u64);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/pow2_le_max64"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shift_is_pow2(k: nat)\n    requires\n        k < 64,\n    ensures\n        (1u64 << k) == pow2(k)\n{\n    pow2_le_max64(k);\n    lemma_u64_shl_is_mul(1u64, k as u64);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_decomposition",
                                "content": "pub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n    }\n    else {\n        lemma2_to64_rest(); // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64); // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_zero_is_id"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shr_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64\n    ensures\n        (v >> (a + b)) == ((v >> a) >> b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shr_zero_is_id;\n    }\n    else {\n        lemma2_to64_rest(); // pow2(64)\n        lemma_pow2_strictly_increases(a, a + b);\n        lemma_pow2_strictly_increases(b, a + b);\n        lemma_pow2_strictly_increases(a + b, 64); // pow2(a + b) fits in u64\n\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // v >> a + b = v / 2^(a+b)\n        lemma_u64_shr_is_div(v, (a + b) as u64);\n        // v >> a = v / 2^a\n        lemma_u64_shr_is_div(v, a as u64);\n        // (v / 2^a) << b = (v / 2^a) / 2^b\n        lemma_u64_shr_is_div((v / (pow2(a) as u64)) as u64, b as u64);\n\n        // 2^k > 0\n        lemma_pow2_pos(a);\n        lemma_pow2_pos(b);\n\n        // v / 2^a / 2^b = v / 2^(a + b)\n        lemma_div_denominator(v as int, pow2(a) as int, pow2(b) as int);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_u64_max_shifting",
                                "content": "pub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_decomposition",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_u64_max_shifting(k:nat)\n    requires\n        1 <= k < 64\n    ensures\n        u64::MAX >> k < 1u64 << (64 - k)\n    decreases 64-k\n{\n    let M = u64::MAX;\n\n    // recursion base case\n    if (k == 63){\n        assert(u64::MAX >> 63 < 1u64 << 1) by (compute);\n    }\n    else {\n        // M >> (k + 1) < 1 << (63 - k)\n        lemma_u64_max_shifting(k + 1);\n\n        // M >> (k + 1) = (M >> k) >> 1\n        shr_decomposition(M, k, 1);\n\n        // precondition\n        lemma2_to64_rest(); // pow2(63)\n        lemma_pow2_strictly_increases((63 - k) as nat, (64 - k) as nat);\n\n        assert(1u64 * pow2((64 - k) as nat) <= 1u64 * pow2(63)) by {\n            if (k == 1) {\n                // 64 - k = 63\n                // tautology\n            }\n            else {\n                // 64 - k < 63\n                lemma_pow2_strictly_increases((64 - k) as nat, 63);\n            }\n            mul_le(1u64 as nat, 1u64 as nat, pow2((64 - k) as nat), pow2(63));\n        }\n        assert( 1u64 * pow2(63) <= u64::MAX) by (compute);\n\n        // 1 << 64 - k = (1 << 63 - k) << 1\n        shl_decomposition(1u64, (63 - k) as nat, 1);\n\n        // (M >> k) >> 1 = (M >> k) / pow2(1);\n        lemma_u64_shr_is_div( M >> k, 1);\n\n        // lemma_u64_shl_is_mul(x, n) precondition: x * pow2(n) <= u64::MAX\n        assert((1u64 << ((63 - k))) * pow2(1) <= u64::MAX) by {\n            shift_is_pow2((63 - k) as nat);\n            lemma_pow2_adds((63-k) as nat, 1);\n        }\n\n        // (1 << 63 - k) << 1 = (1 << 63 - k) * pow2(1);\n        lemma_u64_shl_is_mul( 1u64 << ((63 - k)), 1);\n\n        lemma2_to64(); // pow2(1) = 2\n\n        assert((1u64 << ((64 - k) as u64)) / 2 == (1u64 << ((63 - k) as u64))) by {\n            lemma_div_multiples_vanish((1u64 << (63 - k) as u64) as int, 2);\n        }\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shr_le_u64",
                                "content": "pub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64\n    ensures\n        (a >> k) <= (b >> k)\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}",
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_shr_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64\n    ensures\n        (a >> k) <= (b >> k)\n{\n    lemma_pow2_pos(k);\n    lemma_u64_shr_is_div(a, k as u64);\n    lemma_u64_shr_is_div(b, k as u64);\n    lemma_div_is_ordered(a as int, b as int, pow2(k) as int);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_nonincreasing",
                                "content": "pub proof fn shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64\n    ensures\n        v >> b <= v >> a\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    }\n    else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        shr_decomposition(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shr_le_u64",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shr_decomposition"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shr_nonincreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b <= 64\n    ensures\n        v >> b <= v >> a\n{\n    if (b == 64) {\n        assert(v >> 64 == 0) by (bit_vector);\n    }\n    else {\n        let d = (b - a) as u64;\n        // v >> b = (v >> (b - a)) >> a\n        shr_decomposition(v, d as nat, a);\n        assert(v >> d <= v) by (bit_vector);\n        // a <= b => a >> x <= b >> x\n        lemma_shr_le_u64(v >> d, v, a);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition",
                                "content": "pub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shl_decomposition(v: u64, a: nat, b: nat)\n    requires\n        (a + b) < 64,\n        v * pow2(a + b) <= u64::MAX\n    ensures\n        (v << (a + b)) == ((v << a) << b)\n{\n    if (a == 0 || b == 0) {\n        broadcast use shl_zero_is_id;\n    }\n    else {\n        // 2^(a + b) == 2^a * 2^b\n        lemma_pow2_adds(a, b);\n        // 2^a < 2^(a + b) ...\n        lemma_pow2_strictly_increases(a, a + b);\n        // ..., which implies v * 2^a < v * 2^(a + b) <= u64::MAX\n        mul_le(v as nat, v as nat, pow2(a), pow2(a + b));\n        // v << a + b = v * 2^(a+b)\n        lemma_u64_shl_is_mul(v, (a + b) as u64);\n        // v << a = v * 2^a\n        lemma_u64_shl_is_mul(v, a as u64);\n        // (v * 2^a) * 2^b = v * (2^a * 2^b)\n        lemma_mul_is_associative(v as int, pow2(a) as int, pow2(b) as int);\n        // (v * 2^a) << b = (v * 2^a) * 2^b\n        lemma_u64_shl_is_mul((v * pow2(a)) as u64, b as u64);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shifted_lt",
                                "content": "pub proof fn shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64\n    ensures\n        v >> k < 1u64 << (64 - k)\n{\n    if (k == 64) {\n        assert( v >> 64 == 0) by (bit_vector);\n        shl_zero_is_id(1u64);\n    }\n    else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shr_le_u64",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_u64_max_shifting"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shifted_lt(v: u64, k: nat)\n    requires\n        1 <= k <= 64\n    ensures\n        v >> k < 1u64 << (64 - k)\n{\n    if (k == 64) {\n        assert( v >> 64 == 0) by (bit_vector);\n        shl_zero_is_id(1u64);\n    }\n    else {\n        // (v >> k) <= (u64::MAX >> k)\n        lemma_shr_le_u64(v, u64::MAX, k);\n        // u64::MAX >> k < 1u64 << (64 - k)\n        lemma_u64_max_shifting(k);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_nondecreasing",
                                "content": "pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shl_le_u64",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_decomposition"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn shl_nondecreasing(v: u64, a: nat, b: nat)\n    requires\n        a <= b < 64,\n        v * pow2(b) <= u64::MAX\n    ensures\n        (v << a) <= (v << b)\n{\n    lemma2_to64(); // pow2(0)\n\n    if (a == b) {\n        // trivial\n    }\n    else if (a == 0) {\n        // a != b <=> b > 0\n        lemma_pow2_strictly_increases(0, b);\n        lemma_u64_shl_is_mul(v, 0);\n        lemma_u64_shl_is_mul(v, b as u64);\n        mul_le(v as nat, v as nat, pow2(0), pow2(b));\n    }\n    else {\n        // if a != 0 and a != b then 0 < d < b\n        let d = b - a;\n\n        // v << b = (v << (b - a)) << a\n        shl_decomposition(v, d as nat, a);\n\n        assert(v << d == v * pow2(d as nat)) by {\n            // we need the precond v * pow2(d) < M\n            lemma_pow2_strictly_increases(d as nat, b);\n            mul_le(v as nat, v as nat, pow2(d as nat), pow2(b));\n            lemma_u64_shl_is_mul(v, d as u64);\n        }\n\n        assert(v <= v << d) by {\n            shl_zero_is_id(v);\n            lemma_u64_shl_is_mul(v, 0);\n            lemma_pow2_strictly_increases(0, d as nat);\n            mul_le(v as nat, v as nat, pow2(0), pow2(d as nat));\n        }\n\n        lemma_pow2_adds(a, d as nat);\n\n        assert( (v << (d as u64)) * pow2(a) <= u64::MAX ) by {\n            lemma_mul_is_associative(v as int, pow2(d as nat) as int, pow2(a) as int);\n        }\n\n        // [v <= v << d] => [(v << a) <= (v << d) << a]\n        lemma_shl_le_u64(v, v << (d as u64), a);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shl_zero_is_id",
                                "content": "pub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v\n{\n    assert(v << 0 == v) by (bit_vector);\n}",
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub broadcast proof fn shl_zero_is_id(v: u64)\n    ensures\n        #![trigger v << 0]\n        v << 0 == v\n{\n    assert(v << 0 == v) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/lemma_shl_le_u64",
                                "content": "pub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k)\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le"
                                ],
                                "code_name": "as_nat_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_shl_le_u64(a: u64, b: u64, k: nat)\n    requires\n        a <= b,\n        k < 64,\n        (b * pow2(k)) <= u64::MAX,\n    ensures\n        (a << k) <= (b << k)\n{\n    mul_le(a as nat, b as nat, pow2(k), pow2(k));\n    lemma_u64_shl_is_mul(a, k as u64);\n    lemma_u64_shl_is_mul(b, k as u64);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/masked_lt",
                                "content": "pub proof fn masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k)\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    shift_is_pow2(k);\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                                ],
                                "code_name": "div_mod_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn masked_lt(v: u64, k: nat)\n    requires\n        0 <= k < 64\n    ensures\n        v & (low_bits_mask(k) as u64) < (1u64 << k)\n{\n    // v & (low_bits_mask(k) as u64) = v % pow2(k)\n    lemma_u64_low_bits_mask_is_mod(v, k);\n    // pow2(k) > 0\n    lemma_pow2_pos(k);\n    // v % pow2(k) < pow2(k)\n    lemma_mod_bound(v as int, pow2(k) as int);\n    // 1 << k = pow2(k)\n    shift_is_pow2(k);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "div_mod_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/low_bits_mask_increases",
                                "content": "pub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b\n    ensures\n        low_bits_mask(a) < low_bits_mask(b)\n    decreases a + b\n{\n    if (a == 0){\n         // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    }\n    else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}",
                                "code_name": "div_mod_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn low_bits_mask_increases(a: nat, b: nat)\n    requires\n        a < b\n    ensures\n        low_bits_mask(a) < low_bits_mask(b)\n    decreases a + b\n{\n    if (a == 0){\n         // lbm(0) = 0\n        lemma_low_bits_mask_values();\n        // lbm(b) = 2 * lbm(b - 1) + 1, in particular, > 0\n        lemma_low_bits_mask_unfold(b);\n    }\n    else {\n        // lbm(b) / 2 = lbm(b - 1)\n        lemma_low_bits_mask_div2(b);\n        // lbm(a) / 2 = lbm(a - 1)\n        lemma_low_bits_mask_div2(a);\n        // lbm(a - 1) < lbm(b - 1)\n        low_bits_mask_increases((a - 1) as nat, (b - 1) as nat);\n    }\n\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/low_bits_masks_fit_u64",
                                "content": "pub proof fn low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64\n    ensures\n        low_bits_mask(k) <= u64::MAX\n{\n    lemma_low_bits_mask_values(); // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64){\n        low_bits_mask_increases(k, 64);\n    }\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mask_lemmas.rs/low_bits_mask_increases"
                                ],
                                "code_name": "div_mod_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn low_bits_masks_fit_u64(k: nat)\n    requires\n        k <= 64\n    ensures\n        low_bits_mask(k) <= u64::MAX\n{\n    lemma_low_bits_mask_values(); // lbm(0) = 0, lbm(64) = 2^64\n    assert(low_bits_mask(64) <= u64::MAX) by (compute);\n    if (k < 64){\n        low_bits_mask_increases(k, 64);\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_div_and_mod",
                                "content": "pub proof fn lemma_div_and_mod(ai:u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64)\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi\n{\n    lemma2_to64();\n    lemma2_to64_rest(); // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        assert(0x8000000000000000 <= u64::MAX) by (compute);\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}",
                                "code_name": "pow2k_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_div_and_mod(ai:u64, bi: u64, v: u64, k: nat)\n    requires\n        k < 64,\n        ai == v >> k,\n        bi == v & (low_bits_mask(k) as u64)\n    ensures\n        ai == v / (pow2(k) as u64),\n        bi == v % (pow2(k) as u64),\n        v == ai * pow2(k) + bi\n{\n    lemma2_to64();\n    lemma2_to64_rest(); // pow2(63) = 0x8000000000000000\n\n    // v >> k = v / pow2(k);\n    lemma_u64_shr_is_div(v, k as u64);\n\n    // v & low_bits_mask(k) = v % pow2(k);\n    lemma_u64_low_bits_mask_is_mod(v, k);\n\n    // 0 < pow2(k) <= u64::MAX\n    lemma_pow2_pos(k);\n    assert(pow2(k) <= u64::MAX) by {\n        assert(0x8000000000000000 <= u64::MAX) by (compute);\n        if (k < 63) {\n            lemma_pow2_strictly_increases(k, 63);\n        }\n    }\n\n    // v = (pow2(k) * (v / pow2(k)) + (v % pow2(k)))\n    lemma_fundamental_div_mod(v as int, pow2(k) as int);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_diff_factor",
                                "content": "pub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
                                "code_name": "pow2k_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_mod_diff_factor(a: int, b: int, m: int)\n    requires\n        m > 0,\n    ensures\n        (b - a * m) % m == b % m\n{\n    // (b - a * m) % m == (b % m - (a * m) % m) % m\n    lemma_sub_mod_noop(b, a * m, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_sum_factor",
                                "content": "pub proof fn lemma_mod_sum_factor(a: int, b: int, m: int)\n    requires\n        m > 0\n    ensures\n        (a * m + b) % m == b % m\n{\n    // (a * m + b) % m == ((a * m) % m + b % m) % m\n    lemma_add_mod_noop(a * m, b, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
                                "code_name": "pow2k_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_mod_sum_factor(a: int, b: int, m: int)\n    requires\n        m > 0\n    ensures\n        (a * m + b) % m == b % m\n{\n    // (a * m + b) % m == ((a * m) % m + b % m) % m\n    lemma_add_mod_noop(a * m, b, m);\n    // (a * m) % m == 0\n    lemma_mod_multiples_basic(a, m);\n    // b % m % m = b % m\n    lemma_mod_twice(b, m);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "pow2k_lemmas.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs/bitwise_or_l_zero_is_id",
                                "content": "pub proof fn bitwise_or_l_zero_is_id(a: u64)\n    ensures\n        0 | a == a\n{\n    assert( 0 | a == a) by (bit_vector);\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn bitwise_or_l_zero_is_id(a: u64)\n    ensures\n        0 | a == a\n{\n    assert( 0 | a == a) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs/bitwise_or_r_zero_is_id",
                                "content": "pub proof fn bitwise_or_r_zero_is_id(a: u64)\n    ensures\n        a | 0 == a\n{\n    assert( a | 0 == a) by (bit_vector);\n}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn bitwise_or_r_zero_is_id(a: u64)\n    ensures\n        a | 0 == a\n{\n    assert( a | 0 == a) by (bit_vector);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/bit_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "mod.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs",
                            "content": "",
                            "code_name": "",
                            "children": [
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/u8_times_pow2_fits_u64",
                                "content": "pub proof fn u8_times_pow2_fits_u64(a: u8, k: nat)\n    requires\n        k <= 56\n    ensures\n        (a as u64) * pow2(k) <= u64::MAX\n{\n    assert((a as u64) * pow2(k) <= (a as u64) * pow2(56)) by {\n        assert(pow2(k) <= pow2(56)) by {\n            if(k < 56) {\n                lemma_pow2_strictly_increases(k, 56);\n            }\n        }\n        mul_le(a as nat, a as nat, pow2(k), pow2(56));\n    }\n\n    pow2_mul_u8(a, 56);\n    assert(pow2(64) - pow2(56) <= u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le",
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/pow2_mul_u8"
                                ],
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn u8_times_pow2_fits_u64(a: u8, k: nat)\n    requires\n        k <= 56\n    ensures\n        (a as u64) * pow2(k) <= u64::MAX\n{\n    assert((a as u64) * pow2(k) <= (a as u64) * pow2(56)) by {\n        assert(pow2(k) <= pow2(56)) by {\n            if(k < 56) {\n                lemma_pow2_strictly_increases(k, 56);\n            }\n        }\n        mul_le(a as nat, a as nat, pow2(k), pow2(56));\n    }\n\n    pow2_mul_u8(a, 56);\n    assert(pow2(64) - pow2(56) <= u64::MAX) by {\n        lemma2_to64_rest();\n    }\n\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/main",
                                "content": "fn main() {}",
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "fn main() {}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow2_square",
                                "content": "pub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1))\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}",
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_pow2_square(v: int, i: nat)\n    ensures\n        pow(v, pow2(i)) * pow(v, pow2(i)) == pow(v, pow2(i + 1))\n{\n    // pow(v, pow2(i)) * pow(v, pow2(i)) = pow(v, pow2(i) + pow2(i));\n    lemma_pow_adds(v as int, pow2(i), pow2(i));\n    // 2 * pow2(i) = pow2(i + 1)\n    lemma_pow2_unfold(i + 1);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/pow2_mul_u8",
                                "content": "pub proof fn pow2_mul_u8(a: u8, k: nat)\n    ensures\n        pow2(k) * a <= pow2(k + 8) - pow2(k)\n{\n    assert(a <= pow2(8) - 1) by {\n        lemma2_to64();\n    }\n\n    mul_le(a as nat, (pow2(8) - 1) as nat, pow2(k), pow2(k));\n    assert((pow2(8) - 1) * pow2(k) == pow2(k + 8) - pow2(k)) by {\n        lemma_mul_is_distributive_sub(pow2(k) as int, pow2(8) as int, 1);\n        lemma_pow2_adds(k, 8);\n    }\n\n}",
                                "dependencies": [
                                  "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le"
                                ],
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn pow2_mul_u8(a: u8, k: nat)\n    ensures\n        pow2(k) * a <= pow2(k + 8) - pow2(k)\n{\n    assert(a <= pow2(8) - 1) by {\n        lemma2_to64();\n    }\n\n    mul_le(a as nat, (pow2(8) - 1) as nat, pow2(k), pow2(k));\n    assert((pow2(8) - 1) * pow2(k) == pow2(k + 8) - pow2(k)) by {\n        lemma_mul_is_distributive_sub(pow2(k) as int, pow2(8) as int, 1);\n        lemma_pow2_adds(k, 8);\n    }\n\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/pow2_le_max64",
                                "content": "pub proof fn pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX\n    {\n        lemma2_to64();\n        lemma2_to64_rest();\n    }",
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn pow2_le_max64(k: nat)\n    requires\n        k < 64,\n    ensures\n        pow2(k) <= u64::MAX\n    {\n        lemma2_to64();\n        lemma2_to64_rest();\n    }",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow_nat_is_nat",
                                "content": "pub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0\n{\n    lemma_pow2_pos(i); // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    }\n    else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}",
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_pow_nat_is_nat(v: nat, i: nat)\n    ensures\n        pow(v as int, pow2(i)) >= 0\n{\n    lemma_pow2_pos(i); // pow2(i) > 0\n    if (v == 0) {\n        lemma0_pow(pow2(i));\n    }\n    else {\n        lemma_pow_positive(v as int, pow2(i));\n    }\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              },
                              {
                                "identifier": "curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_two_factoring",
                                "content": "pub proof fn lemma_two_factoring(a : nat, b: nat, v: u64)\n    ensures\n        pow2(a + b) * v == pow2(a) * (pow2(b) * v)\n{\n    lemma_pow2_adds(a, b);\n    lemma_mul_is_associative(pow2(a) as int, pow2(b) as int, v as int);\n}",
                                "code_name": "field_verus.rs",
                                "children": [],
                                "file_type": "file",
                                "status_id": 3,
                                "snippets": [
                                  {
                                    "sortorder": 0,
                                    "text": "pub proof fn lemma_two_factoring(a : nat, b: nat, v: u64)\n    ensures\n        pow2(a + b) * v == pow2(a) * (pow2(b) * v)\n{\n    lemma_pow2_adds(a, b);\n    lemma_mul_is_associative(pow2(a) as int, pow2(b) as int, v as int);\n}",
                                    "type_id": 2
                                  }
                                ],
                                "specified": true
                              }
                            ],
                            "file_type": "folder",
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_scalar",
                            "content": "spec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "spec fn to_scalar(limbs: &[u64; 5]) -> nat {\n    to_nat(limbs) % group_order()\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat_gen_u64",
                            "content": "pub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn words_to_nat_gen_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u64(words, num_words - 1, bits_per_word)\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_wide_to_nat_rec",
                            "content": "pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\ndecreases 64 - index\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat\ndecreases 64 - index\n{\n    if index >= 64 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_wide_to_nat_rec(bytes, index + 1)\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/nine_limbs_to_nat_aux",
                            "content": "pub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {\n    (limbs[0] as nat) +\n    (limbs[1] as nat) * pow2(52) +\n    (limbs[2] as nat) * pow2(104) +\n    (limbs[3] as nat) * pow2(156) +\n    (limbs[4] as nat) * pow2(208) +\n    (limbs[5] as nat) * pow2(260) +\n    (limbs[6] as nat) * pow2(312) +\n    (limbs[7] as nat) * pow2(364) +\n    (limbs[8] as nat) * pow2(416)\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {\n    (limbs[0] as nat) +\n    (limbs[1] as nat) * pow2(52) +\n    (limbs[2] as nat) * pow2(104) +\n    (limbs[3] as nat) * pow2(156) +\n    (limbs[4] as nat) * pow2(208) +\n    (limbs[5] as nat) * pow2(260) +\n    (limbs[6] as nat) * pow2(312) +\n    (limbs[7] as nat) * pow2(364) +\n    (limbs[8] as nat) * pow2(416)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat_gen_u32",
                            "content": "pub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn words_to_nat_gen_u32(words: &[u32], num_words: int, bits_per_word: int) -> nat\ndecreases num_words\n{\n    if num_words <= 0 {\n        0\n    } else {\n        let word_value = (words[num_words - 1] as nat) * pow2(((num_words - 1) * bits_per_word) as nat);\n        word_value + words_to_nat_gen_u32(words, num_words - 1, bits_per_word)\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/five_limbs_to_nat_aux",
                            "content": "pub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {\n    (limbs[0] as nat) +\n    pow2(52) * (limbs[1] as nat) +\n    pow2(104) * (limbs[2] as nat) +\n    pow2(156) * (limbs[3] as nat) +\n    pow2(208) * (limbs[4] as nat)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                            "content": "pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat",
                            "content": "pub open spec fn words_to_nat(words: &[u64; 4]) -> nat {\n    words_to_nat_gen_u64(words, 4, 64)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat_gen_u64"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn words_to_nat(words: &[u64; 4]) -> nat {\n    words_to_nat_gen_u64(words, 4, 64)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                            "content": "pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat",
                            "content": "pub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_to_nat_rec(bytes, 0)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat_rec"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_to_nat_rec(bytes, 0)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                            "content": "pub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_wide_to_nat",
                            "content": "pub open spec fn bytes_wide_to_nat(bytes: &[u8; 64]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_wide_to_nat_rec(bytes, 0)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_wide_to_nat_rec"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn bytes_wide_to_nat(bytes: &[u8; 64]) -> nat {\n    // Convert bytes to nat in little-endian order using recursive helper\n    bytes_wide_to_nat_rec(bytes, 0)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                            "content": "pub open spec fn to_nat(limbs: &[u64]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn to_nat(limbs: &[u64]) -> nat\n{\n    seq_to_nat(limbs@.map(|i, x| x as nat))\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                            "content": "pub open spec fn seq_u64_to_nat(limbs: Seq<u64>) -> nat\n{\n    seq_to_nat(limbs.map(|i, x| x as nat))\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat"
                            ],
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn seq_u64_to_nat(limbs: Seq<u64>) -> nat\n{\n    seq_to_nat(limbs.map(|i, x| x as nat))\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat_rec",
                            "content": "pub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\ndecreases 32 - index\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_to_nat_rec(bytes, index + 1)\n    }\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat\ndecreases 32 - index\n{\n    if index >= 32 {\n        0\n    } else {\n        (bytes[index] as nat) * pow2((index * 8) as nat) + bytes_to_nat_rec(bytes, index + 1)\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                            "content": "pub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat",
                            "content": "pub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\ndecreases limbs.len()\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}",
                            "code_name": "subtle_assumes.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub open spec fn seq_to_nat(limbs: Seq<nat>) -> nat\ndecreases limbs.len()\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_empty_seq_as_nat",
                            "content": "pub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures seq_u64_to_nat(a.subrange(0, 0)) == 0\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_empty_seq_as_nat(a: Seq<u64>)\n    ensures seq_u64_to_nat(a.subrange(0, 0)) == 0\n{\n    assert(seq_u64_to_nat(a.subrange(0, 0)) == 0);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_square_internal_no_overflow",
                            "content": "pub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_square_internal_no_overflow()\n    ensures\n         (1u128 << 105) + (1u128 << 105) == (1u128 << 106),\n         (1u128 << 105) + (1u128 << 104) < (1u128 << 106),\n         (1u128 << 104) * 2 == (1u128 << 105),\n         (1u128 << 106) + (1u128 << 104) < (1u128 << 107),\n{\n    assert((1u128 << 105) + (1u128 << 105) == (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 105) + (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert((1u128 << 104) * 2 == (1u128 << 105)) by (bit_vector);\n    assert((1u128 << 106) + (1u128 << 104) < (1u128 << 107)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_carry_and_sum_bounds",
                            "content": "pub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_add_carry_and_sum_bounds(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) < 2,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_borrow_and_mask_bounded",
                            "content": "pub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_borrow_and_mask_bounded(borrow: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n    ensures\n        (borrow & mask) < (1u64 << 52),\n{\n    assert((borrow & mask) <= mask) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_bound_scalar",
                            "content": "pub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires limbs_bounded(a)\n    ensures to_nat(&a.limbs) < pow2((52 * (5) as nat))\n{\n    lemma_general_bound(a.limbs@);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_general_bound"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_bound_scalar(a: &Scalar52)\n    requires limbs_bounded(a)\n    ensures to_nat(&a.limbs) < pow2((52 * (5) as nat))\n{\n    lemma_general_bound(a.limbs@);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_correct_after_loops",
                            "content": "pub(crate) proof fn lemma_sub_correct_after_loops(difference: Scalar52, carry: u64, a: &Scalar52, b: &Scalar52, difference_after_loop1: Scalar52, borrow: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n        seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)),\n    ensures\n            to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        assert( seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs)) by {\n            assert( seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n            assert( difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n            assert( seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n            assert( b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n            assert( seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n            assert( a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        }\n        if borrow >> 63 == 0 {\n\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) );\n            assert(              to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                                        to_nat(&difference.limbs) );\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n            lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n            assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int));\n        }\n        if borrow >> 63 == 1 {\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n            );\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int))\n            );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                     - pow2((52 * (5) as nat)) );\n            if carry >> 52 == 0 {\n                // Get a contradiction because the sides in the above equation have different signs\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                    seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) >=0) by {\n                    assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order()) by {\n                        lemma_l_equals_group_order();\n                    };\n                    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n                };\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2((52 * (5) as nat))) by {\n                    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs));\n                    lemma_bound_scalar(&difference);\n                };\n                assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n                assert(false);\n            }\n            assert(carry >> 52 ==1);\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int))  );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                   to_nat(&difference.limbs)  );\n            assert(to_nat(&constants::L.limbs) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(group_order() > 0);\n            calc! {\n                (==)\n                to_nat(&difference.limbs) as int; {\n                }\n                group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                    assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()) by {\n                        assert( seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) == to_nat(&difference_after_loop1.limbs)) by {\n                            assert( seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(&difference_after_loop1.limbs));\n                            assert( difference_after_loop1.limbs@ == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                        }\n                        assert(to_nat(&a.limbs) - to_nat(&b.limbs ) ==\n                        to_nat(&difference_after_loop1.limbs ) - pow2((52 * (5) as nat)) );\n                        lemma_bound_scalar(&difference_after_loop1);\n                    };\n                    lemma_small_mod((group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n                }\n                (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                    lemma_mod_cancel(a, b);\n                }\n                (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n            }\n        }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_bound_scalar",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_l_equals_group_order"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub(crate) proof fn lemma_sub_correct_after_loops(difference: Scalar52, carry: u64, a: &Scalar52, b: &Scalar52, difference_after_loop1: Scalar52, borrow: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        limbs_bounded(&difference),\n        limbs_bounded(&difference_after_loop1),\n        (carry >> 52) < 2,\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n        seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat),\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)),\n    ensures\n            to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        assert( seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs)) by {\n            assert( seq_u64_to_nat(difference.limbs@) == to_nat(&difference.limbs));\n            assert( difference.limbs@ == difference.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n            assert( seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n            assert( b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        }\n        assert( seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n            assert( seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n            assert( a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        }\n        if borrow >> 63 == 0 {\n\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n            assert(              seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                                        seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) );\n            assert(              to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                                        to_nat(&difference.limbs) );\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) >= 0);\n            assert(to_nat(&a.limbs) - to_nat(&b.limbs) < group_order());\n            lemma_small_mod((to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n            assert(to_nat(&difference.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int));\n        }\n        if borrow >> 63 == 1 {\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n            );\n            assert(\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int))\n            );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int )) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                    - seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) - pow2((52 * (5) as nat)) );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2(52 * 5 as nat)\n                     - pow2((52 * (5) as nat)) );\n            if carry >> 52 == 0 {\n                // Get a contradiction because the sides in the above equation have different signs\n                assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                    seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) >=0) by {\n                    assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) >= group_order()) by {\n                        lemma_l_equals_group_order();\n                    };\n                    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs));\n                    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs));\n                };\n                assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) < pow2((52 * (5) as nat))) by {\n                    assert(seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int)) == to_nat(&difference.limbs));\n                    lemma_bound_scalar(&difference);\n                };\n                assert((carry >> 52) * pow2(52 * 5 as nat) == 0);\n                assert(false);\n            }\n            assert(carry >> 52 ==1);\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                   seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int))  );\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) +\n                   to_nat(&a.limbs) - to_nat(&b.limbs) ==\n                   to_nat(&difference.limbs)  );\n            assert(to_nat(&constants::L.limbs) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()) by {\n                lemma_l_equals_group_order();\n            };\n            assert(group_order() > 0);\n            calc! {\n                (==)\n                to_nat(&difference.limbs) as int; {\n                }\n                group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs); {\n                    assert(group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs) < group_order()) by {\n                        assert( seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 5 as int)) == to_nat(&difference_after_loop1.limbs)) by {\n                            assert( seq_u64_to_nat(difference_after_loop1.limbs@) == to_nat(&difference_after_loop1.limbs));\n                            assert( difference_after_loop1.limbs@ == difference_after_loop1.limbs@.subrange(0, 5 as int));\n                        }\n                        assert(to_nat(&a.limbs) - to_nat(&b.limbs ) ==\n                        to_nat(&difference_after_loop1.limbs ) - pow2((52 * (5) as nat)) );\n                        lemma_bound_scalar(&difference_after_loop1);\n                    };\n                    lemma_small_mod((group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) as nat, group_order());\n                }\n                (group_order() as int + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int); {\n                    lemma_mod_cancel(a, b);\n                }\n                (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int);\n            }\n        }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_five_limbs_equals_to_nat",
                            "content": "pub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/five_limbs_to_nat_aux"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_five_limbs_equals_to_nat(limbs: &[u64; 5])\nensures\n    five_limbs_to_nat_aux(*limbs) == to_nat(limbs)\n{\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 6);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            (limbs[4] as nat) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        (limbs[0] as nat) +\n        pow2(52) * (limbs[1] as nat) +\n        pow2(104) * (limbs[2] as nat) +\n        pow2(156) * (limbs[3] as nat) +\n        pow2(208) * (limbs[4] as nat); {\n        }\n        five_limbs_to_nat_aux(*limbs);\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_general_bound",
                            "content": "pub proof fn lemma_general_bound(a: Seq<u64>)\n    requires forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52)\n    ensures seq_u64_to_nat(a) < pow2((52 * a.len() as nat))\n    decreases a.len()\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64(); // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(1, a.len() as int).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int)) * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52)) by {\n            lemma_mul_inequality((pow2(52 * (a.len() - 1) as nat) - 1) as int, pow2(52 * (a.len() - 1) as nat) as int, pow2(52) as int);\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) ==\n               pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) ==\n               pow2(52 * (a.len() - 1) as nat) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_general_bound(a: Seq<u64>)\n    requires forall|i: int| 0 <= i < a.len() ==> a[i] < (1u64 << 52)\n    ensures seq_u64_to_nat(a) < pow2((52 * a.len() as nat))\n    decreases a.len()\n{\n    if a.len() == 0 {\n        assert(seq_u64_to_nat(a) == 0);\n        lemma2_to64(); // Gives us pow2(0) == 1 among other facts\n        assert(pow2(0) == 1);\n    } else {\n        // Inductive case\n        let tail = a.subrange(1, a.len() as int);\n\n        // Apply induction hypothesis on tail\n        assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] < (1u64 << 52)) by {\n            assert(forall|i: int| 0 <= i < tail.len() ==> tail[i] == a[i + 1]);\n        };\n\n        assert(tail.len() == a.len() - 1);\n\n        // Apply induction hypothesis\n        lemma_general_bound(tail);\n        assert(seq_u64_to_nat(tail) < pow2((52 * tail.len() as nat)));\n\n        // Now prove for the full sequence\n        assert(seq_u64_to_nat(a) == seq_to_nat(a.map(|i, x| x as nat)));\n        assert(a.map(|i, x| x as nat).len() == a.len());\n        assert(a.map(|i, x| x as nat)[0] == a[0] as nat);\n        assert(a.map(|i, x| x as nat).subrange(1, a.len() as int) == a.subrange(1, a.len() as int).map(|i, x| x as nat));\n        // Therefore:\n        assert(seq_u64_to_nat(a) == a[0] as nat + seq_u64_to_nat(a.subrange(1, a.len() as int)) * pow2(52));\n\n        assert(a.subrange(1, a.len() as int) == tail);\n\n        // From precondition\n        assert(a[0] < (1u64 << 52));\n        lemma2_to64_rest();\n        assert(0x10000000000000 == 1u64 << 52) by (compute_only);\n        assert(0x10000000000000 == pow2(52));\n        assert((1u64 << 52) == pow2(52));\n\n        // We have seq_u64_to_nat(a) == a[0] + seq_u64_to_nat(tail) * pow2(52)\n        // We know a[0] < pow2(52) and seq_u64_to_nat(tail) < pow2(52 * (a.len() - 1))\n\n\n        assert(a[0] as nat <= pow2(52) - 1);\n        assert(seq_u64_to_nat(tail) <= pow2(52 * (a.len() - 1) as nat) - 1);\n\n        assert(seq_u64_to_nat(a) <= (pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52)) by {\n            lemma_mul_inequality((pow2(52 * (a.len() - 1) as nat) - 1) as int, pow2(52 * (a.len() - 1) as nat) as int, pow2(52) as int);\n        };\n\n        // Expand the right side\n        assert((pow2(52) - 1) + (pow2(52 * (a.len() - 1) as nat) - 1) * pow2(52) ==\n               pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52)) by {\n            broadcast use lemma_mul_is_distributive_sub;\n        };\n\n        assert(pow2(52) - 1 + pow2(52 * (a.len() - 1) as nat) * pow2(52) - pow2(52) ==\n               pow2(52 * (a.len() - 1) as nat) * pow2(52) - 1);\n\n        lemma_pow2_adds(52 * (a.len() - 1) as nat, 52);\n        assert(pow2(52 * (a.len() - 1) as nat) * pow2(52) == pow2(52 * (a.len() - 1) as nat + 52));\n        assert(52 * (a.len() - 1) as nat + 52 == 52 * a.len() as nat);\n\n        assert(seq_u64_to_nat(a) <= pow2(52 * a.len() as nat) - 1);\n        assert(seq_u64_to_nat(a) < pow2(52 * a.len() as nat));\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_carry_bounded_after_mask",
                            "content": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_carry_bounded_after_mask(carry: u64, mask: u64)\n    requires\n        mask == (1u64 << 52) - 1,\n        carry < (1u64 << 53),\n    ensures\n        (carry & mask) < (1u64 << 52),\n        (carry >> 52) <= 1,\n{\n    assert((carry & mask) <= mask) by (bit_vector);\n    assert((1u64 << 53) == 2 * (1u64 << 52)) by (bit_vector);\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    assert(carry >> 52 == carry / (1u64 << 52));\n    lemma_fundamental_div_mod(carry as int, (1u64 << 52) as int);\n    let q = carry / (1u64 << 52);\n    let r = carry % (1u64 << 52);\n    lemma_mul_strict_inequality_converse(q as int, 2int, (1u64 << 52) as int);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_l_equals_group_order",
                            "content": "pub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {lemma2_to64_rest();};\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/five_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_five_limbs_equals_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_pow252",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub(crate) proof fn lemma_l_equals_group_order()\n    ensures\n        to_nat(&constants::L.limbs) == group_order(),\n        seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)) == group_order()\n{\n    // First show that the subrange equals the full array\n    assert(constants::L.limbs@ == constants::L.limbs@.subrange(0, 5 as int));\n    assert(seq_u64_to_nat(constants::L.limbs@) == seq_u64_to_nat(constants::L.limbs@.subrange(0, 5 as int)));\n    assert(to_nat(&constants::L.limbs) == seq_u64_to_nat(constants::L.limbs@));\n\n    assert(pow2(52) == 0x10000000000000) by {lemma2_to64_rest();};\n    lemma_pow2_adds(52, 52);\n    assert(pow2(104) == 0x100000000000000000000000000);\n    lemma_pow2_adds(104, 104);\n    assert(pow2(208) == 0x10000000000000000000000000000000000000000000000000000);\n    lemma_pow252();\n    lemma_five_limbs_equals_to_nat(&constants::L.limbs);\n    assert(five_limbs_to_nat_aux(constants::L.limbs) == group_order()) by (compute);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_square_internal_correct",
                            "content": "pub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/five_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_five_limbs_equals_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_nine_limbs_equals_slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/nine_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_square_internal_correct(a: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        z[0] == (a[0] * a[0]) ,\n        z[1] == (a[0] * a[1])  * 2,\n        z[2] == (a[0] * a[2])  * 2 + (a[1] * a[1]) ,\n        z[3] == (a[0] * a[3])  * 2 + (a[1] * a[2])  * 2,\n        z[4] == (a[0] * a[4])  * 2 + (a[1] * a[3])  * 2 + (a[2] * a[2]) ,\n        z[5] == (a[1] * a[4])  * 2 + (a[2] * a[3])  * 2,\n        z[6] == (a[2] * a[4])  * 2 + (a[3] * a[3]) ,\n        z[7] == (a[3] * a[4])  * 2,\n        z[8] == (a[4] * a[4]) ,\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(a),\n\n{\n        assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*a) == nine_limbs_to_nat_aux(&z)) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n            broadcast use lemma_mul_is_associative;\n\n            lemma_pow2_adds(52, 52);\n            lemma_pow2_adds(52, 104);\n            lemma_pow2_adds(52, 156);\n            lemma_pow2_adds(52, 208);\n            lemma_pow2_adds(104, 104);\n            lemma_pow2_adds(104, 156);\n            lemma_pow2_adds(104, 208);\n            lemma_pow2_adds(156, 156);\n            lemma_pow2_adds(156, 208);\n            lemma_pow2_adds(208, 208);\n        };\n        lemma_nine_limbs_equals_slice128_to_nat(&z);\n        lemma_five_limbs_equals_to_nat(&a);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_mul_internal_correct",
                            "content": "pub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/five_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_five_limbs_equals_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/nine_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_nine_limbs_equals_slice128_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_mul_internal_correct(a: &[u64; 5], b: &[u64; 5], z: &[u128; 9])\n    requires\n        forall|i: int| 0 <= i < 5 ==> a[i] < (1u64 << 52),\n        forall|i: int| 0 <= i < 5 ==> b[i] < (1u64 << 52),\n        z[0] == (a[0] * b[0]),\n        z[1] == (a[0] * b[1]) + (a[1] * b[0]),\n        z[2] == (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]),\n        z[3] == (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]),\n        z[4] == (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]),\n        z[5] == (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]),\n        z[6] == (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]),\n        z[7] == (a[3] * b[4]) + (a[4] * b[3]),\n        z[8] == (a[4] * b[4]),\n    ensures\n        slice128_to_nat(z) == to_nat(a) * to_nat(b),\n{\n    assert(five_limbs_to_nat_aux(*a) * five_limbs_to_nat_aux(*b) == nine_limbs_to_nat_aux(&z)) by {\n        broadcast use group_mul_is_commutative_and_distributive;\n        broadcast use lemma_mul_is_associative;\n\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(52, 104);\n        lemma_pow2_adds(52, 156);\n        lemma_pow2_adds(52, 208);\n        lemma_pow2_adds(104, 104);\n        lemma_pow2_adds(104, 156);\n        lemma_pow2_adds(104, 208);\n        lemma_pow2_adds(156, 156);\n        lemma_pow2_adds(156, 208);\n        lemma_pow2_adds(208, 208);\n    };\n    lemma_nine_limbs_equals_slice128_to_nat(&z);\n    lemma_five_limbs_equals_to_nat(&a);\n    lemma_five_limbs_equals_to_nat(&b);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_nine_limbs_equals_slice128_to_nat",
                            "content": "pub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/nine_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_nine_limbs_equals_slice128_to_nat(limbs: &[u128; 9])\nensures\n    nine_limbs_to_nat_aux(limbs) == slice128_to_nat(limbs)\n{\n\n    let seq = limbs@.map(|i, x| x as nat);\n\n    calc! {\n        (==)\n        slice128_to_nat(limbs); {\n        }\n        seq_to_nat(seq); {\n            reveal_with_fuel(seq_to_nat, 10);\n        }\n        (limbs[0] as nat) +\n        ((limbs[1] as nat) +\n            ((limbs[2] as nat) +\n            ((limbs[3] as nat) +\n            ((limbs[4] as nat) +\n            ((limbs[5] as nat) +\n                ((limbs[6] as nat) +\n                ((limbs[7] as nat) +\n                (limbs[8] as nat) * pow2(52)\n                ) * pow2(52)\n                ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n            ) * pow2(52)\n        ) * pow2(52); {\n        lemma_pow2_adds(52, 52);\n        lemma_pow2_adds(104, 52);\n        lemma_pow2_adds(156, 52);\n        lemma_pow2_adds(208, 52);\n        lemma_pow2_adds(260, 52);\n        lemma_pow2_adds(312, 52);\n        lemma_pow2_adds(364, 52);\n        broadcast use group_mul_is_distributive;\n        broadcast use lemma_mul_is_associative;\n        }\n        nine_limbs_to_nat_aux(limbs);\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_sum_simplify",
                            "content": "pub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) ==\n               seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2((52 * (5) as nat))\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs)\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2((52 * (5) as nat)));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_pow2_260_greater_than_2_group_order"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_add_sum_simplify(a: &Scalar52, b: &Scalar52, sum: &Scalar52, carry: u64)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n        (carry >> 52) < 2,\n        seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) ==\n               seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) as nat * pow2((52 * (5) as nat))\n    ensures\n        to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs)\n{\n    // First establish the relationship between the different representations\n    assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) == to_nat(&a.limbs)) by {\n        assert(a.limbs@ == a.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(a.limbs@) == to_nat(&a.limbs));\n    }\n    assert(seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) == to_nat(&b.limbs)) by {\n        assert(b.limbs@ == b.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(b.limbs@) == to_nat(&b.limbs));\n    }\n    assert(seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) == to_nat(&sum.limbs)) by {\n        assert(sum.limbs@ == sum.limbs@.subrange(0, 5 as int));\n        assert(seq_u64_to_nat(sum.limbs@) == to_nat(&sum.limbs));\n    }\n\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) * pow2((52 * (5) as nat)));\n\n    // From the loop invariant, we have: a + b == sum + (carry >> 52) * 2^260\n    assert(52 * 5 == 260) by (compute);\n    assert(pow2((52 * 5) as nat) == pow2(260));\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) == to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n\n    // Since a < group_order() and b < group_order(), we have a + b < 2 * group_order()\n    // This is just basic arithmetic: if x < A and y < A, then x + y < A + A = 2*A\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < group_order() + group_order());\n    assert(group_order() + group_order() == 2 * group_order());\n    assert(to_nat(&a.limbs) + to_nat(&b.limbs) < 2 * group_order());\n\n    // Therefore: sum + (carry >> 52) * 2^260 < 2 * group_order()\n    assert(to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260) < 2 * group_order());\n\n    // Prove a contradiction if carry is nonzero\n    assert((carry >> 52) as nat * pow2(260) < 2 * group_order());\n    if carry >> 52 == 1 {\n        lemma_pow2_260_greater_than_2_group_order();\n        assert(1 as nat * pow2(260) < 2 * group_order());\n        assert(false);\n    }\n    assert(carry >> 52 == 0);\n\n    // Since carry >> 52 >= 0 and pow2(260) > 0, we have (carry >> 52) * pow2(260) >= 0\n    // Therefore sum < sum + (carry >> 52) * pow2(260) < 2 * group_order()\n    lemma_pow2_pos(260);\n    assert(pow2(260) > 0);\n    assert((carry >> 52) as nat * pow2(260) >= 0);\n    assert(to_nat(&sum.limbs) <= to_nat(&sum.limbs) + (carry >> 52) as nat * pow2(260));\n    assert(to_nat(&sum.limbs) < 2 * group_order());\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_loop_invariant",
                            "content": "pub proof fn lemma_add_loop_invariant(sum: Scalar52, carry: u64, i: usize, a: &Scalar52, b: &Scalar52, old_carry: u64, mask: u64, sum_loop_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) ==\n                    seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2((52 * (i) as nat)),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52)\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(52 * i as nat) +\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, a.limbs[i as int] as int, b.limbs[i as int] as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n        (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, (old_carry >> 52) as int, (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        ((old_carry >> 52) as nat + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        ((carry >> 52) as nat * pow2(52) + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {lemma_pow2_adds(52, 52 * i as nat);};\n            assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, (carry >> 52) as nat * pow2(52) as int, sum.limbs[i as int] as int);\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                    lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        (carry >> 52) as nat * pow2(52 * (i+1) as nat) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2((52 * (i + 1) as nat));\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_add_loop_invariant(sum: Scalar52, carry: u64, i: usize, a: &Scalar52, b: &Scalar52, old_carry: u64, mask: u64, sum_loop_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> sum.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) ==\n                    seq_u64_to_nat(sum_loop_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2((52 * (i) as nat)),\n        sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int),\n        sum.limbs[i as int] == carry & mask,\n        carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52)\n    ensures\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) + seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] as nat * pow2(52 * i as nat) +\n        seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, a.limbs[i as int] as int, b.limbs[i as int] as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n        (a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, (old_carry >> 52) as int, (a.limbs[i as int] as nat + b.limbs[i as int] as nat) as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        ((old_carry >> 52) as nat + a.limbs[i as int] as nat + b.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(carry == a.limbs[i as int] + b.limbs[i as int] + (old_carry >> 52));\n            assert(sum.limbs[i as int] == carry & mask);\n            // Decompose carry using the mask\n            lemma_decompose(carry, mask);\n            assert(carry == (carry >> 52) * pow2(52) + sum.limbs[i as int]);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        ((carry >> 52) as nat * pow2(52) + sum.limbs[i as int] as nat) * pow2(52 * i as nat); {\n            assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {lemma_pow2_adds(52, 52 * i as nat);};\n            assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n            lemma_mul_is_distributive_add_other_way(pow2(52 * i as nat) as int, (carry >> 52) as nat * pow2(52) as int, sum.limbs[i as int] as int);\n            assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                    assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                    lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n            };\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) +\n        (carry >> 52) as nat * pow2(52 * (i+1) as nat) + sum.limbs[i as int] as nat * pow2(52 * i as nat); {\n            lemma_seq_u64_to_nat_subrange_extend(sum.limbs@, i as int);\n        }\n        seq_u64_to_nat(sum.limbs@.subrange(0, i + 1)) + (carry >> 52) as nat * pow2((52 * (i + 1) as nat));\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_decompose",
                            "content": "pub proof fn lemma_decompose(a: u64, mask: u64)\n    requires mask == (1u64 << 52) - 1\n    ensures a == (a >> 52) * pow2(52) + (a & mask)\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest(); // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_decompose(a: u64, mask: u64)\n    requires mask == (1u64 << 52) - 1\n    ensures a == (a >> 52) * pow2(52) + (a & mask)\n{\n    // First, establish that bit shifting is division by pow2(52)\n    broadcast use lemma_u64_shr_is_div;\n    lemma_pow2_pos(52);\n    shift_is_pow2(52);\n    lemma2_to64_rest(); // Establishes pow2(52) == 0x10000000000000\n    assert((1u64 << 52) == 0x10000000000000) by (bit_vector);\n    assert(pow2(52) == 0x10000000000000);\n    assert((1u64 << 52) as nat == pow2(52));\n\n    assert(a >> 52 == a / (1u64 << 52));\n\n    // Apply fundamental division theorem: a = q * d + r\n    lemma_fundamental_div_mod(a as int, pow2(52) as int);\n    let q = a as nat / pow2(52);\n    let r = a as nat % pow2(52);\n    assert(a as nat == q * pow2(52) + r);\n    assert(0 <= r < pow2(52));\n\n    // Now prove that (a & mask) == r\n    // mask is all 1s in the lower 52 bits\n    assert(mask == (1u64 << 52) - 1);\n\n    // Key insight: a & mask gives us the lower 52 bits, which is exactly a % pow2(52)\n    lemma_u64_low_bits_mask_is_mod(a, 52);\n    assert(a & mask == a % (1u64 << 52));\n    assert((a % (1u64 << 52)) as nat == a as nat % pow2(52));\n    assert((a & mask) as nat == r);\n\n    // Now show that a >> 52 == q\n    assert((a >> 52) as nat == a as nat / pow2(52));\n    assert((a >> 52) as nat == q);\n\n    // Combine everything\n    assert(a as nat == (a >> 52) as nat * pow2(52) + (a & mask) as nat);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_scalar_subtract_no_overflow",
                            "content": "pub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_scalar_subtract_no_overflow(carry: u64, difference_limb: u64, addend: u64, i: u32, l_value: &Scalar52)\n    requires\n        i < 5,\n        difference_limb < (1u64 << 52),\n        addend == 0 || addend == l_value.limbs[i as int],\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n    ensures\n        (carry >> 52) + difference_limb + addend < (1u64 << 53),\n{\n    if i == 0 {\n        assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    } else if i == 1 {\n        assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n    } else if i == 2 {\n        assert(0x000000000014def9 < (1u64 << 52)) by (bit_vector);\n    } else if i == 3 {\n    } else {\n        assert(0x0000100000000000 < (1u64 << 52)) by (bit_vector);\n    }\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert(2 * (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/verify_invert_correct",
                            "content": "proof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "proof fn verify_invert_correct(x: Scalar52)\n//     requires to_scalar(&x.limbs) != 0\n//    ensures (to_scalar(&x.limbs) * invert_spec(&x.limbs)) % group_order() == 1\n{\n    assume(false);\n\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_pow252",
                            "content": "pub proof fn lemma_pow252()\n    ensures pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000\n{\n    assert(pow2(63) == 0x8000000000000000) by {lemma2_to64_rest();}\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_pow252()\n    ensures pow2(252) == 0x1000000000000000000000000000000000000000000000000000000000000000\n{\n    assert(pow2(63) == 0x8000000000000000) by {lemma2_to64_rest();}\n    lemma_pow2_adds(63, 63);\n    assert(pow2(126) == 0x40000000000000000000000000000000);\n    lemma_pow2_adds(126, 126);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_from_montgomery_limbs_conversion",
                            "content": "pub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/nine_limbs_to_nat_aux",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_nine_limbs_equals_slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_five_limbs_equals_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_from_montgomery_limbs_conversion(\n    limbs: &[u128; 9],\n    self_limbs: &[u64; 5]\n)\n    requires\n        forall|j: int| #![auto] 0 <= j < 5 ==> limbs[j] == self_limbs[j] as u128,\n        forall|j: int| 5 <= j < 9 ==> limbs[j] == 0,\n    ensures\n        slice128_to_nat(limbs) == to_nat(self_limbs),\n{\n    lemma_nine_limbs_equals_slice128_to_nat(limbs);\n    lemma_five_limbs_equals_to_nat(self_limbs);\n    assert(limbs[0] == self_limbs[0] as u128);\n    assert(nine_limbs_to_nat_aux(limbs) == (self_limbs[0] as nat) +\n           (self_limbs[1] as nat) * pow2(52) +\n           (self_limbs[2] as nat) * pow2(104) +\n           (self_limbs[3] as nat) * pow2(156) +\n           (self_limbs[4] as nat) * pow2(208) +\n           0 * pow2(260) + 0 * pow2(312) + 0 * pow2(364) + 0 * pow2(416));\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_mod_cancel",
                            "content": "pub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) ==\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n    lemma_mod_add_multiples_vanish((to_nat(&a.limbs) - to_nat(&b.limbs)) as int, group_order() as int);\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_mod_cancel(a: &Scalar52, b: &Scalar52)\n    ensures (group_order() + to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int) ==\n            (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int)\n{\n    lemma_mod_add_multiples_vanish((to_nat(&a.limbs) - to_nat(&b.limbs)) as int, group_order() as int);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_seq_u64_to_nat_subrange_extend",
                            "content": "pub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) ==\n        seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)\n    decreases i\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len()>0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(nat_single.subrange(1, 1)) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {lemma2_to64();}\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return;\n    }\n    else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert( seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(1, limbs1.len() as int));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i-1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i-1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) ==\n                    seq_u64_to_nat(tail.subrange(0, i - 1)) + tail[i -1 ] * pow2(52 * (i-1) as nat));\n                assert( tail.subrange(0, i) == seq.subrange(1, i + 1) );\n                assert( tail.subrange(0, i - 1) == seq.subrange(1, i ) );\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) ==\n                    seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat)) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * (i-1) as nat) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n                lemma_pow2_adds(52 * (i-1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert(seq.subrange(1, i ).map(|i, x| x as nat) == limbs2.subrange(1, limbs2.len() as int));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert( seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {\n            }\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n\n        }\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_seq_u64_to_nat_subrange_extend(seq: Seq<u64>, i: int)\n    requires\n        0 <= i < seq.len(),\n    ensures\n        seq_u64_to_nat(seq.subrange(0, i + 1)) ==\n        seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)\n    decreases i\n{\n    if i == 0 {\n        reveal_with_fuel(seq_to_nat, 3);\n        assert(seq.len()>0);\n        assert(seq.subrange(0, 1) == seq![seq[0]]);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, 0 + 1 as int)); {\n                assert(seq.subrange(0, 1) == seq![seq[0]]);\n            }\n            seq_u64_to_nat(seq![seq[0]]); {\n                let single_elem = seq![seq[0]];\n                let nat_single = single_elem.map(|idx, x| x as nat);\n                assert(nat_single == seq![seq[0] as nat]);\n                assert(seq_u64_to_nat(single_elem) == seq_to_nat(nat_single));\n                assert(nat_single.len() == 1);\n                assert(seq_to_nat(nat_single) == nat_single[0] + seq_to_nat(nat_single.subrange(1, 1)) * pow2(52));\n                assert(nat_single.subrange(1, 1).len() == 0);\n                assert(seq_to_nat(nat_single.subrange(1, 1)) == 0);\n                assert(seq_to_nat(nat_single) == nat_single[0]);\n                assert(nat_single[0] == seq[0] as nat);\n            }\n            seq[0] as nat; {\n                assert(pow2(0) == 1) by {lemma2_to64();}\n                assert(52 * 0 == 0);\n                assert(pow2(52 * 0 as nat) == pow2(0));\n                assert((seq[0] * pow2(0)) as nat == (seq[0] * 1) as nat);\n                assert((seq[0] * 1) as nat == seq[0] as nat);\n            }\n            (seq[0] * pow2(52 * 0 as nat)) as nat; {\n                lemma_empty_seq_as_nat(seq);\n            }\n            (seq_u64_to_nat(seq.subrange(0, 0)) + seq[0] * pow2(52 * 0 as nat)) as nat;\n        }\n        return;\n    }\n    else {\n        let limbs1 = seq.subrange(0, i + 1).map(|i, x| x as nat);\n        let limbs2 = seq.subrange(0, i).map(|i, x| x as nat);\n        calc! {\n            (==)\n            seq_u64_to_nat(seq.subrange(0, i + 1)); {\n                assert( seq_to_nat(limbs1) == limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52));\n            }\n            limbs1[0] + seq_to_nat(limbs1.subrange(1, limbs1.len() as int)) * pow2(52); {\n                assert(seq.subrange(1, i + 1).map(|i, x| x as nat) == limbs1.subrange(1, limbs1.len() as int));\n            }\n            limbs1[0] + seq_u64_to_nat(seq.subrange(1, i + 1)) * pow2(52); {\n                let tail = seq.subrange(1, i + 1);\n                assert(i >= 1);\n                assert(0 <= i-1 < tail.len());\n                lemma_seq_u64_to_nat_subrange_extend(tail, i-1);\n                assert(seq_u64_to_nat(tail.subrange(0, i)) ==\n                    seq_u64_to_nat(tail.subrange(0, i - 1)) + tail[i -1 ] * pow2(52 * (i-1) as nat));\n                assert( tail.subrange(0, i) == seq.subrange(1, i + 1) );\n                assert( tail.subrange(0, i - 1) == seq.subrange(1, i ) );\n                assert(seq_u64_to_nat(seq.subrange(1, i + 1)) ==\n                    seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat));\n            }\n            limbs1[0] + ((seq_u64_to_nat(seq.subrange(1, i )) + seq[i] * pow2(52 * (i-1) as nat)) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * (i-1) as nat) * pow2(52)) as nat; {\n                broadcast use lemma_mul_is_associative;\n                lemma_pow2_adds(52 * (i-1) as nat, 52);\n            }\n            (limbs1[0] + seq_u64_to_nat(seq.subrange(1, i )) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert(seq.subrange(1, i ).map(|i, x| x as nat) == limbs2.subrange(1, limbs2.len() as int));\n            }\n            (limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52) + seq[i] * pow2(52 * i as nat)) as nat; {\n                assert( seq_to_nat(limbs2) == limbs2[0] + seq_to_nat(limbs2.subrange(1, limbs2.len() as int)) * pow2(52));\n            }\n            (seq_to_nat(limbs2) + seq[i] * pow2(52 * i as nat)) as nat; {\n            }\n            (seq_u64_to_nat(seq.subrange(0, i)) + seq[i] * pow2(52 * i as nat)) as nat;\n\n        }\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_mul_internal_no_overflow",
                            "content": "pub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_mul_internal_no_overflow()\n    ensures\n        (1u128 << 104) + (1u128 << 104) == (1u128 << 105),\n        3u128 * (1u128 << 104) < (1u128 << 106),\n        4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104),\n        (1u128 << 2) * (1u128 << 104) == (1u128 << 106),\n        8u128 == (1u128 << 3),\n        (1u128 << 3) * (1u128 << 104) == (1u128 << 107),\n{\n    assert((1u128 << 104) + (1u128 << 104) == (1u128 << 105)) by (bit_vector);\n    assert(3u128 * (1u128 << 104) < (1u128 << 106)) by (bit_vector);\n    assert(4u128 * (1u128 << 104) == (1u128 << 2) * (1u128 << 104)) by (bit_vector);\n    assert((1u128 << 2) * (1u128 << 104) == (1u128 << 106)) by (bit_vector);\n    assert(8u128 == (1u128 << 3)) by (bit_vector);\n    assert((1u128 << 3) * (1u128 << 104) == (1u128 << 107)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop2_invariant",
                            "content": "pub(crate) proof fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int| i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int| (0 <= j < 5 && j!=i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >=1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i-1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i+1 >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1 as int)) ==\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1 as int)) + (carry >> 52) * pow2(52 * (i+1) as nat)\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert( carry & mask == carry ) by (bit_vector)\n            requires\n            carry < 1u64 <<52,\n            mask == (1u64 << 52) - 1;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall |j :int| 0<=j<5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1)); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat) +\n            seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int) );\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat +\n            difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int] + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(52 * i as nat); {\n                assert(carry == (carry >> 52) * (1u64<<52) + (carry & mask)) by (bit_vector)\n                    requires mask == (1u64 << 52) - 1;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);};\n                    assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                        lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat);\n        }\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_old_carry"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub(crate) proof fn lemma_sub_loop2_invariant(difference: Scalar52, i: usize, a: &Scalar52, b: &Scalar52, mask: u64, difference_after_loop1: Scalar52, difference_loop2_start: Scalar52, carry: u64, old_carry: u64, addend: u64, borrow: u64)\n    requires\n        0 <= i < 5,\n        mask == (1u64 << 52) - 1,\n        forall|j: int| 0 <= j < 5 ==> difference_loop2_start.limbs[j] < (1u64 << 52),\n        forall|j: int| i <= j < 5 ==> difference_loop2_start.limbs[j] == difference_after_loop1.limbs[j],\n        forall|j: int| (0 <= j < 5 && j!=i) ==> difference_loop2_start.limbs[j] == difference.limbs[j],\n        mask == (1u64 << 52) - 1,\n        i == 0 ==> old_carry == 0,\n        i >= 1 ==> (old_carry >> 52) < 2,\n        (i >=1 && borrow >> 63 == 0) ==> old_carry == difference_loop2_start.limbs[i-1],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference_loop2_start,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) * pow2(52 * i as nat),\n        difference.limbs[i as int] == carry & mask,\n        difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        borrow >> 63 == 0 ==> addend == 0,\n        borrow >> 63 == 1 ==> addend == constants::L.limbs[i as int],\n        carry == (old_carry >> 52) + difference_loop2_start.limbs[i as int] + addend,\n    ensures\n        (i+1 >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i as int],\n        borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n        borrow >> 63 == 1 ==>\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1 as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1 as int)) ==\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1 as int)) + (carry >> 52) * pow2(52 * (i+1) as nat)\n{\n    if borrow >> 63 == 0 {\n        lemma_old_carry(old_carry);\n        assert(addend == 0);\n        assert(carry == difference_loop2_start.limbs[i as int]);\n        assert( carry & mask == carry ) by (bit_vector)\n            requires\n            carry < 1u64 <<52,\n            mask == (1u64 << 52) - 1;\n        assert(difference_after_loop1.limbs[i as int] == difference.limbs[i as int]);\n        assert(forall |j :int| 0<=j<5 ==> difference_after_loop1.limbs[j] == difference.limbs[j]);\n        assert(difference_after_loop1.limbs == difference.limbs);\n    }\n    if borrow >> 63 == 1 {\n        // When underflow, addend = L.limbs[i]\n        assert(addend == constants::L.limbs[i as int]);\n        // carry = (old_carry >> 52) + difference_after_loop1.limbs[i] + L.limbs[i]\n        // difference.limbs[i] = carry & mask\n        calc! {\n            (==)\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i+1)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i+1)); {\n                lemma_seq_u64_to_nat_subrange_extend(difference_after_loop1.limbs@, i as int);\n                lemma_seq_u64_to_nat_subrange_extend(constants::L.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + difference_after_loop1.limbs[i as int] as nat * pow2(52 * i as nat) +\n            seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) + constants::L.limbs[i as int] as nat * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                // Use invariant\n            }\n            seq_u64_to_nat(difference_loop2_start.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int) );\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (old_carry >> 52) as nat * pow2(52 * i as nat) +\n            (difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((old_carry >> 52) as nat +\n            difference_after_loop1.limbs[i as int] as nat + constants::L.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                assert(carry == (old_carry >> 52) + difference_after_loop1.limbs[i as int] + constants::L.limbs[i as int]);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + carry as nat * pow2(52 * i as nat); {\n                assert(carry == (carry >> 52) * (1u64<<52) + (carry & mask)) by (bit_vector)\n                    requires mask == (1u64 << 52) - 1;\n                assert(carry == (carry >> 52) * pow2(52) + difference.limbs[i as int]) by {\n                    lemma2_to64_rest();\n                    assert(0x10000000000000 == 1u64 << 52) by (compute_only);};\n                    assert(difference.limbs[i as int] == carry & mask);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + ((carry >> 52) as nat * pow2(52) + difference.limbs[i as int] as nat) * pow2(52 * i as nat); {\n                broadcast use lemma_mul_is_distributive_add_other_way;\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                assert((carry >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (carry >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                        lemma_mul_is_associative((carry >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                };\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat) + difference.limbs[i as int] as nat * pow2(52 * i as nat); {\n                lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n            }\n            seq_u64_to_nat(difference.limbs@.subrange(0, i+1)) + (carry >> 52) as nat * pow2(52 * (i+1) as nat);\n        }\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop1_invariant",
                            "content": "pub proof fn lemma_sub_loop1_invariant(difference: Scalar52, borrow: u64, i: usize, a: &Scalar52, b: &Scalar52, old_borrow: u64, mask: u64, difference_loop1_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                    seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64)\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) -\n        (seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(52 * i as nat) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n        (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52) + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat) -\n                        0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64<<12) - 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        assert( 0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(52 * (i + 1) as nat) ) by\n                        {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(pow2(52 * (i+1) as nat) as int, (1u64<<12) - 1, (1u64 << 12) as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (-1) * pow2(52 * (i+1) as nat) ; {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n            else {\n\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert (borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n    }\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_sub_loop1_invariant(difference: Scalar52, borrow: u64, i: usize, a: &Scalar52, b: &Scalar52, old_borrow: u64, mask: u64, difference_loop1_start: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        0 <= i < 5,\n        forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n        mask == (1u64 << 52) - 1,\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                    seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)),\n        difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int),\n        difference.limbs[i as int] == borrow & mask,\n        borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64)\n    ensures\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat))\n        == seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1))\n{\n    calc! {\n        (==)\n        seq_u64_to_nat(a.limbs@.subrange(0, i + 1)) - seq_u64_to_nat(b.limbs@.subrange(0, i + 1)); {\n            lemma_seq_u64_to_nat_subrange_extend(a.limbs@, i as int);\n            lemma_seq_u64_to_nat_subrange_extend(b.limbs@, i as int);\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + a.limbs[i as int] * pow2(52 * i as nat) -\n        (seq_u64_to_nat(b.limbs@.subrange(0, i as int)) + b.limbs[i as int] * pow2(52 * i as nat)); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int)) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            // Use loop invariant\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) - (old_borrow >> 63) * pow2(52 * i as nat) +\n        (a.limbs[i as int] - b.limbs[i as int]) * pow2(52 * i as nat); {\n            broadcast use lemma_mul_is_distributive_sub_other_way;\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n        (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n            assert(borrow == a.limbs[i as int].wrapping_sub((b.limbs[i as int] + (old_borrow >> 63)) as u64));\n            assert(difference.limbs[i as int] == borrow & mask);\n            // Expand wrapping sub\n            if a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) < 0 {\n\n                assert(borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52)) by {\n                    assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    assert(b.limbs[i as int] <= (1u64 << 52) - 1);\n                    assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                    assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 <= 1u64 << 52);\n                    assert(borrow >= (a.limbs[i as int] - (1u64 << 52) + 0x1_0000_0000_0000_0000) as u64);\n                };\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64) + 0x1_0000_0000_0000_0000) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int] - 0x1_0000_0000_0000_0000) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        broadcast use lemma_mul_is_distributive_sub_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat) -\n                        0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) - 0x1_0000_0000_0000_0000 * pow2(52 * i as nat); {\n                        assert(borrow >> 52 == (1u64<<12) - 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        assert( 0x1_0000_0000_0000_0000 * pow2(52 * i as nat) == (1u64 << 12) * pow2(52 * (i + 1) as nat) ) by\n                        {\n                            lemma2_to64();\n                            assert(0x1_0000_0000_0000_0000 == pow2(64));\n                            assert(1u64 << 12 == pow2(12)) by (compute);\n                            lemma_pow2_adds(64, 52 * i as nat);\n                            lemma_pow2_adds(12, 52 * (i + 1) as nat);\n                            assert(64 + 52 * i as nat == 12 + 52 * (i + 1) as nat);\n                        }\n                        lemma_mul_is_distributive_sub_other_way(pow2(52 * (i+1) as nat) as int, (1u64<<12) - 1, (1u64 << 12) as int);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) +\n                        (-1) * pow2(52 * (i+1) as nat) ; {\n                        assert(borrow >> 63 == 1) by (bit_vector)\n                                requires borrow >= 0x1_0000_0000_0000_0000 - (1u64<<52);\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n            else {\n\n                calc! {\n                    (==)\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int))  +\n                    (a.limbs[i as int] - b.limbs[i as int] - (old_borrow >> 63)) * pow2(52 * i as nat); {\n                        assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                        assert(b.limbs[i as int] < 1u64 << 52);\n                        assert(old_borrow >> 63 <= 1) by (bit_vector);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (borrow) * pow2(52 * i as nat); {\n                        lemma_decompose(borrow, mask);\n                        assert(borrow == (borrow >> 52) * pow2(52) + difference.limbs[i as int]);\n                    }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        ((borrow >> 52) * pow2(52) + difference.limbs[i as int]) * pow2(52 * i as nat); {\n                        assert(pow2(52) * pow2(52 * i as nat) == pow2(52 + 52 * i as nat)) by {broadcast use lemma_pow2_adds;};\n                        assert(52 + 52 * i as nat == 52 * (i+1) as nat);\n                        broadcast use lemma_mul_is_distributive_add_other_way;\n                        assert((borrow >> 52) as nat * pow2(52) * pow2(52 * i as nat) == (borrow >> 52) as nat * pow2(52 * (i+1) as nat)) by {\n                                assert(pow2(52) * pow2(52 * i as nat) == pow2(52 * (i+1) as nat));\n                                lemma_mul_is_associative((borrow >> 52) as int, pow2(52) as int, pow2(52 * i as nat) as int);\n                        };\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) +\n                        (borrow >> 52) * pow2(52 * (i+1) as nat) + difference.limbs[i as int] * pow2(52 * i as nat); {\n                            lemma_seq_u64_to_nat_subrange_extend(difference.limbs@, i as int);\n                        assert (borrow < 1u64 << 52) by {\n                            assert(borrow == (a.limbs[i as int] - ((b.limbs[i as int] + (old_borrow >> 63)) as u64)) as u64);\n                            assert(a.limbs[i as int] < (1u64 << 52));\n                            assert((b.limbs[i as int] + (old_borrow >> 63)) as u64 >= 0);\n                        }\n                        assert(borrow >> 52 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        assert(borrow >> 63 == 0) by (bit_vector)\n                                requires borrow < 1u64 << 52;\n                        }\n                    seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n                }\n            }\n        }\n        seq_u64_to_nat(difference.limbs@.subrange(0, i + 1)) - (borrow >> 63) * pow2((52 * (i + 1) as nat));\n    }\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_pow2_260_greater_than_2_group_order",
                            "content": "pub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures pow2(260) > 2 * group_order()\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_pow252"
                            ],
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_pow2_260_greater_than_2_group_order()\n    ensures pow2(260) > 2 * group_order()\n{\n    // The group order is approximately 2^252, so 2 * group_order ≈ 2^253\n    // And 2^260 >> 2^253\n    assert(pow2(260) == pow2(252) * pow2(8)) by {\n        lemma_pow2_adds(252, 8);\n    };\n    assert(pow2(8) == 256) by {\n        lemma2_to64();\n    };\n    lemma_pow252();\n    // Now Verus knows what the powers of 2 mean, so it can figure out the rest\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_l_value_properties",
                            "content": "pub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_l_value_properties(l_value: &Scalar52, sum: &Scalar52)\n    requires\n        l_value.limbs[0] == 0x0002631a5cf5d3ed,\n        l_value.limbs[1] == 0x000dea2f79cd6581,\n        l_value.limbs[2] == 0x000000000014def9,\n        l_value.limbs[3] == 0x0000000000000000,\n        l_value.limbs[4] == 0x0000100000000000,\n        forall|j: int| 0 <= j < 5 ==> sum.limbs[j] < (1u64 << 52),\n    ensures\n        forall|j: int| 0 <= j < 5 ==> l_value.limbs[j] < (1u64 << 52),\n{\n    assert(0x0002631a5cf5d3ed < (1u64 << 52)) by (bit_vector);\n    assert(0x000dea2f79cd6581 < (1u64 << 52)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_rr_limbs_bounded",
                            "content": "pub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_rr_limbs_bounded()\n    ensures\n        0x000d63c715bea69fu64 < (1u64 << 52),\n{\n    // Verus can figure that out the other 4 limbs are bounded\n    assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_52_52",
                            "content": "pub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_52_52(x: u64, y: u64)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures (x as u128) * (y as u128) < (1u128 << 104)\n{\n    assert(1u128 << 52 == 1u64 << 52) by (bit_vector);\n    calc! {\n        (<)\n        (x as u128) * (y as u128); (<=) {\n            if x > 0 {\n                lemma_mul_strict_inequality(y as int, (1u128 << 52) as int, x as int);\n                assert( x * y < x * (1u128 << 52)  );\n            } else {\n                assert((0 as u128) * (y as u128) == 0);\n            }\n        }\n        (x as u128) * (1u128 << 52); (<) {\n            lemma_mul_strict_inequality(x as int, (1u128 << 52) as int, (1u128 << 52) as int);\n        }\n        (1u128 << 52) * (1u128 << 52);\n    }\n    assert((1u128 << 52) * (1u128 << 52) == (1u128 << 104)) by (compute);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_old_carry",
                            "content": "pub proof fn lemma_old_carry(old_carry: u64)\n    requires old_carry < 1u64 <<52,\n    ensures old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires old_carry < 1u64 <<52;\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_old_carry(old_carry: u64)\n    requires old_carry < 1u64 <<52,\n    ensures old_carry >> 52 == 0,\n{\n    assert(old_carry >> 52 == 0) by (bit_vector)\n        requires old_carry < 1u64 <<52;\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_loop_bounds",
                            "content": "pub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
                            "code_name": "pow_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn lemma_add_loop_bounds(i: int, carry: u64, a_limb: u64, b_limb: u64)\n    requires\n        0 <= i < 5,\n        a_limb < (1u64 << 52),\n        b_limb < (1u64 << 52),\n        i == 0 ==> carry == 0,\n        i >= 1 ==> (carry >> 52) < 2,\n    ensures\n        (carry >> 52) + a_limb + b_limb < (1u64 << 53),\n{\n    if i == 0 {\n        assert((0u64 >> 52) == 0) by (bit_vector);\n    }\n    assert((1u64 << 52) + (1u64 << 52) == (1u64 << 53)) by (bit_vector);\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/as_montgomery",
                            "content": "    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        assume(to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order());\n        result\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_rr_limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order(),\n    {\n        proof {\n            lemma_rr_limbs_bounded();\n        }\n        let result = Scalar52::montgomery_mul(self, &constants::RR);\n        assume(to_nat(&result.limbs) == (to_nat(&self.limbs) * montgomery_radix()) % group_order());\n        result\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                            "content": "    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n    {\n        proof {lemma_mul_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        proof {lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);}\n\n        z\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/m",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_mul_internal_correct",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_mul_internal_no_overflow"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub (crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&b.limbs),\n    {\n        proof {lemma_mul_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n\n        z[0] = m(a.limbs[0], b.limbs[0]);\n        z[1] = m(a.limbs[0], b.limbs[1]) + m(a.limbs[1], b.limbs[0]);\n        z[2] = m(a.limbs[0], b.limbs[2]) + m(a.limbs[1], b.limbs[1]) + m(a.limbs[2], b.limbs[0]);\n        z[3] = m(a.limbs[0], b.limbs[3]) + m(a.limbs[1], b.limbs[2]) + m(a.limbs[2], b.limbs[1]) + m(a.limbs[3], b.limbs[0]);\n        z[4] = m(a.limbs[0], b.limbs[4]) + m(a.limbs[1], b.limbs[3]) + m(a.limbs[2], b.limbs[2]) + m(a.limbs[3], b.limbs[1]) + m(a.limbs[4], b.limbs[0]);\n        z[5] =                 m(a.limbs[1], b.limbs[4]) + m(a.limbs[2], b.limbs[3]) + m(a.limbs[3], b.limbs[2]) + m(a.limbs[4], b.limbs[1]);\n        z[6] =                                 m(a.limbs[2], b.limbs[4]) + m(a.limbs[3], b.limbs[3]) + m(a.limbs[4], b.limbs[2]);\n        z[7] =                                                 m(a.limbs[3], b.limbs[4]) + m(a.limbs[4], b.limbs[3]);\n        z[8] =                                                                 m(a.limbs[4], b.limbs[4]);\n\n        proof {lemma_mul_internal_correct(&a.limbs, &b.limbs, &z);}\n\n        z\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/mul",
                            "content": "    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let ab = Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&ab, &constants::RR))\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/index_mut",
                            "content": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }",
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn index_mut(&mut self, _index: usize) -> &mut u64 {\n        &mut (self.limbs[_index])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
                            "content": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // Without the following condition, all we can prove is something like:\n        // to_nat(&a.limbs) >= to_nat(&b.limbs) ==> to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n        // to_nat(&a.limbs) < to_nat(&b.limbs) ==> to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs) + pow2(260) + group_order()) % (pow2(260) as int),\n        // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n        limbs_bounded(&s),\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )));\n        assert( (borrow >> 63) == 0 ) by (bit_vector)\n            requires borrow == 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )) - (borrow >> 63) * pow2((52 * (0) as nat)));\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      limbs_bounded(a),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n                      seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int )) - (borrow >> 63) * pow2((52 * (i) as nat))\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            let ghost old_borrow = borrow;\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            let ghost difference_loop1_start = difference;\n            difference.limbs[i] = borrow & mask;\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            assert(\n            seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                        seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)));\n            proof{\n                lemma_sub_loop1_invariant(difference, borrow, i, a, b, old_borrow, mask, difference_loop1_start);\n            }\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n        // conditionally add l if the difference is negative\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        let mut carry: u64 = 0;\n        let ghost difference_after_loop1 = difference;\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) == 0);\n        assert(carry >> 52 == 0) by (bit_vector)\n            requires carry == 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      forall|j: int| i <= j < 5 ==> difference.limbs[j] == difference_after_loop1.limbs[j],\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n                      (i >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i-1],\n                      borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n                      borrow >> 63 == 1 ==>\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2(52 * i as nat)\n\n        {\n            let ghost old_carry = carry;\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            if borrow >> 63 == 0 {\n                assert(addend == 0);\n            }\n            if borrow >> 63 == 1 {\n                assert(addend == constants::L.limbs[i as int]);\n            }\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            let ghost difference_loop2_start = difference;\n            difference.limbs[i] = carry & mask;\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n                lemma_sub_loop2_invariant(difference, i, a, b, mask, difference_after_loop1, difference_loop2_start, carry, old_carry, addend, borrow);\n            }\n        }\n        proof { lemma_sub_correct_after_loops(difference, carry, a, b, difference_after_loop1, borrow);}\n        difference\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_scalar_subtract_no_overflow",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop1_invariant",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_borrow_and_mask_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs/select",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_carry_bounded_after_mask",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_loop2_invariant",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_sub_correct_after_loops"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // Without the following condition, all we can prove is something like:\n        // to_nat(&a.limbs) >= to_nat(&b.limbs) ==> to_nat(&s.limbs) == to_nat(&a.limbs) - to_nat(&b.limbs),\n        // to_nat(&a.limbs) < to_nat(&b.limbs) ==> to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs) + pow2(260) + group_order()) % (pow2(260) as int),\n        // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n        -group_order() <= to_nat(&a.limbs) - to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) - to_nat(&b.limbs)) % (group_order() as int),\n        limbs_bounded(&s),\n    {\n        let mut difference = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector);}\n        let mask = (1u64 << 52) - 1;\n\n        // a - b\n        let mut borrow: u64 = 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )));\n        assert( (borrow >> 63) == 0 ) by (bit_vector)\n            requires borrow == 0;\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 0 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int )) - (borrow >> 63) * pow2((52 * (0) as nat)));\n        for i in 0..5\n            invariant\n                      limbs_bounded(b),\n                      limbs_bounded(a),\n                      forall|j: int| 0 <= j < i ==> difference.limbs[j] < (1u64 << 52),\n                      mask == (1u64 << 52) - 1,\n                      seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                                    seq_u64_to_nat(difference.limbs@.subrange(0, i as int )) - (borrow >> 63) * pow2((52 * (i) as nat))\n        {\n            proof { assert ((borrow >> 63) < 2) by (bit_vector); }\n            let ghost old_borrow = borrow;\n            borrow = a.limbs[i].wrapping_sub(b.limbs[i] + (borrow >> 63));\n            let ghost difference_loop1_start = difference;\n            difference.limbs[i] = borrow & mask;\n            assert(difference_loop1_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n            assert(\n            seq_u64_to_nat(a.limbs@.subrange(0, i as int)) - seq_u64_to_nat(b.limbs@.subrange(0, i as int )) ==\n                        seq_u64_to_nat(difference_loop1_start.limbs@.subrange(0, i as int )) - (old_borrow >> 63) * pow2((52 * (i) as nat)));\n            proof{\n                lemma_sub_loop1_invariant(difference, borrow, i, a, b, old_borrow, mask, difference_loop1_start);\n            }\n            proof { lemma_borrow_and_mask_bounded(borrow, mask); }\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) - seq_u64_to_nat(b.limbs@.subrange(0, 5 as int )) ==\n                seq_u64_to_nat(difference.limbs@.subrange(0, 5 as int )) - (borrow >> 63) * pow2((52 * (5) as nat)) );\n        // conditionally add l if the difference is negative\n        assert(borrow >> 63 == 1 || borrow >> 63 == 0) by (bit_vector);\n        let mut carry: u64 = 0;\n        let ghost difference_after_loop1 = difference;\n        assert(seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(constants::L.limbs@.subrange(0, 0 as int)) == 0);\n        assert(seq_u64_to_nat(difference.limbs@.subrange(0, 0 as int)) == 0);\n        assert(carry >> 52 == 0) by (bit_vector)\n            requires carry == 0;\n        for i in 0..5\n            invariant\n                      forall|j: int| 0 <= j < 5 ==> difference.limbs[j] < (1u64 << 52),  // from first loop\n                      forall|j: int| i <= j < 5 ==> difference.limbs[j] == difference_after_loop1.limbs[j],\n                      mask == (1u64 << 52) - 1,\n                      i == 0 ==> carry == 0,\n                      i >= 1 ==> (carry >> 52) < 2,\n                      (i >=1 && borrow >> 63 == 0) ==> carry == difference.limbs[i-1],\n                      borrow >> 63 == 0 ==> difference_after_loop1 == difference,\n                      borrow >> 63 == 1 ==>\n                          seq_u64_to_nat(difference_after_loop1.limbs@.subrange(0, i as int)) + seq_u64_to_nat(constants::L.limbs@.subrange(0, i as int)) ==\n                          seq_u64_to_nat(difference.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2(52 * i as nat)\n\n        {\n            let ghost old_carry = carry;\n            let underflow = Choice::from((borrow >> 63) as u8);\n            let addend = select(&0, &constants::L.limbs[i], underflow);\n            if borrow >> 63 == 0 {\n                assert(addend == 0);\n            }\n            if borrow >> 63 == 1 {\n                assert(addend == constants::L.limbs[i as int]);\n            }\n            proof {lemma_scalar_subtract_no_overflow(carry, difference.limbs[i as int], addend, i as u32, &constants::L);}\n            carry = (carry >> 52) + difference.limbs[i] + addend;\n            let ghost difference_loop2_start = difference;\n            difference.limbs[i] = carry & mask;\n            proof {\n                lemma_carry_bounded_after_mask(carry, mask);\n                assert(difference_loop2_start.limbs@.subrange(0, i as int) == difference.limbs@.subrange(0, i as int));\n                lemma_sub_loop2_invariant(difference, i, a, b, mask, difference_after_loop1, difference_loop2_start, carry, old_carry, addend, borrow);\n            }\n        }\n        proof { lemma_sub_correct_after_loops(difference, carry, a, b, difference_after_loop1, borrow);}\n        difference\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                            "content": "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/m",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/part1",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/part2",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    ensures\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == slice128_to_nat(limbs) % group_order(),\n        limbs_bounded(&result),\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n\n\n        // note: l[3] is zero, so its multiples can be skipped\n        let l = &constants::L;\n\n        // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n        let (carry, n0) = Self::part1(limbs[0]);\n        let (carry, n1) = Self::part1(carry + limbs[1] + m(n0, l.limbs[1]));\n        let (carry, n2) = Self::part1(carry + limbs[2] + m(n0, l.limbs[2]) + m(n1, l.limbs[1]));\n        let (carry, n3) = Self::part1(carry + limbs[3] + m(n1, l.limbs[2]) + m(n2, l.limbs[1]));\n        let (carry, n4) = Self::part1(carry + limbs[4] + m(n0, l.limbs[4]) + m(n2, l.limbs[2]) + m(n3, l.limbs[1]));\n\n        // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n        let (carry, r0) = Self::part2(carry + limbs[5] + m(n1, l.limbs[4]) + m(n3, l.limbs[2]) + m(n4, l.limbs[1]));\n        let (carry, r1) = Self::part2(carry + limbs[6] + m(n2, l.limbs[4]) + m(n4, l.limbs[2]));\n        let (carry, r2) = Self::part2(carry + limbs[7] + m(n3, l.limbs[4]));\n        let (carry, r3) = Self::part2(carry + limbs[8] + m(n4, l.limbs[4]));\n        let r4 = carry as u64;\n\n        // result may be >= l, so attempt to subtract l\n        Scalar52::sub(&Scalar52 { limbs: [r0, r1, r2, r3, r4] }, l)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/to_bytes",
                            "content": "    pub fn to_bytes(self) -> (s: [u8; 32])\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn to_bytes(self) -> (s: [u8; 32])\n    ensures bytes_to_nat(&s) == to_nat(&self.limbs)\n    {\n        let mut s = [0u8; 32];\n\n        s[ 0] =  (self.limbs[ 0] >>  0)                      as u8;\n        s[ 1] =  (self.limbs[ 0] >>  8)                      as u8;\n        s[ 2] =  (self.limbs[ 0] >> 16)                      as u8;\n        s[ 3] =  (self.limbs[ 0] >> 24)                      as u8;\n        s[ 4] =  (self.limbs[ 0] >> 32)                      as u8;\n        s[ 5] =  (self.limbs[ 0] >> 40)                      as u8;\n        s[ 6] = ((self.limbs[ 0] >> 48) | (self.limbs[ 1] << 4)) as u8;\n        s[ 7] =  (self.limbs[ 1] >>  4)                      as u8;\n        s[ 8] =  (self.limbs[ 1] >> 12)                      as u8;\n        s[ 9] =  (self.limbs[ 1] >> 20)                      as u8;\n        s[10] =  (self.limbs[ 1] >> 28)                      as u8;\n        s[11] =  (self.limbs[ 1] >> 36)                      as u8;\n        s[12] =  (self.limbs[ 1] >> 44)                      as u8;\n        s[13] =  (self.limbs[ 2] >>  0)                      as u8;\n        s[14] =  (self.limbs[ 2] >>  8)                      as u8;\n        s[15] =  (self.limbs[ 2] >> 16)                      as u8;\n        s[16] =  (self.limbs[ 2] >> 24)                      as u8;\n        s[17] =  (self.limbs[ 2] >> 32)                      as u8;\n        s[18] =  (self.limbs[ 2] >> 40)                      as u8;\n        s[19] = ((self.limbs[ 2] >> 48) | (self.limbs[ 3] << 4)) as u8;\n        s[20] =  (self.limbs[ 3] >>  4)                      as u8;\n        s[21] =  (self.limbs[ 3] >> 12)                      as u8;\n        s[22] =  (self.limbs[ 3] >> 20)                      as u8;\n        s[23] =  (self.limbs[ 3] >> 28)                      as u8;\n        s[24] =  (self.limbs[ 3] >> 36)                      as u8;\n        s[25] =  (self.limbs[ 3] >> 44)                      as u8;\n        s[26] =  (self.limbs[ 4] >>  0)                      as u8;\n        s[27] =  (self.limbs[ 4] >>  8)                      as u8;\n        s[28] =  (self.limbs[ 4] >> 16)                      as u8;\n        s[29] =  (self.limbs[ 4] >> 24)                      as u8;\n        s[30] =  (self.limbs[ 4] >> 32)                      as u8;\n        s[31] =  (self.limbs[ 4] >> 40)                      as u8;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/part2",
                            "content": "    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }",
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn part2(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let w = (sum as u64) & ((1u64 << 52) - 1);\n        let carry = sum >> 52;\n        (carry, w)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
                            "content": "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&a.limbs) * to_nat(&b.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(a, b))\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/part1",
                            "content": "    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/m"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn part1(sum: u128) -> (res: (u128, u64))\n    {\n        assume(false); // TODO: Add proper bounds checking and proofs\n        let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n        let carry = (sum + m(p, constants::L.limbs[0])) >> 52;\n        (carry, p)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/from_montgomery",
                            "content": "    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs) % group_order(),\n    {\n        let mut limbs = [0u128; 9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_from_montgomery_limbs_conversion",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == to_nat(&self.limbs) % group_order(),\n    {\n        let mut limbs = [0u128; 9];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..5\n            invariant\n                forall|j: int| #![auto] 0 <= j < i ==> limbs[j] == self.limbs[j] as u128,\n                forall|j: int| #![auto] i <= j < 9 ==> limbs[j] == 0,\n        {\n            limbs[i] = self.limbs[i] as u128;\n        }\n        let result = Scalar52::montgomery_reduce(&limbs);\n        proof {\n            lemma_from_montgomery_limbs_conversion(&limbs, &self.limbs);\n        }\n        result\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/square_internal",
                            "content": "    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_square_internal_correct",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_square_internal_no_overflow",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/slice128_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/m"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub (crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limbs_bounded(a),\n    ensures\n        slice128_to_nat(&z) == to_nat(&a.limbs) * to_nat(&a.limbs),\n    {\n        proof {lemma_square_internal_no_overflow()}\n\n        let mut z = [0u128; 9];\n        z[0] = m(a.limbs[0], a.limbs[0]);\n        z[1] = m(a.limbs[0], a.limbs[1]) * 2;\n        z[2] = m(a.limbs[0], a.limbs[2]) * 2 + m(a.limbs[1], a.limbs[1]);\n        z[3] = m(a.limbs[0], a.limbs[3]) * 2 + m(a.limbs[1], a.limbs[2]) * 2;\n        z[4] = m(a.limbs[0], a.limbs[4]) * 2 + m(a.limbs[1], a.limbs[3]) * 2 + m(a.limbs[2], a.limbs[2]);\n        z[5] =                 m(a.limbs[1], a.limbs[4]) * 2 + m(a.limbs[2], a.limbs[3]) * 2;\n        z[6] =                                 m(a.limbs[2], a.limbs[4]) * 2 + m(a.limbs[3], a.limbs[3]);\n        z[7] =                                                 m(a.limbs[3], a.limbs[4]) * 2;\n        z[8] =                                                                 m(a.limbs[4], a.limbs[4]);\n\n        proof {lemma_square_internal_correct(&a.limbs, &z);}\n\n        z\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/from_bytes_wide",
                            "content": "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_wide_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/add"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n        limbs_bounded(&s),\n        to_nat(&s.limbs) == bytes_wide_to_nat(bytes) % group_order(),\n    {\n        assume(false); // TODO: complete the proof\n        let mut words = [0u64; 8];\n        for i in 0..8 {\n            for j in 0..8 {\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let mut lo = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        let mut hi = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n\n        lo[0] =   words[0]                             & mask;\n        lo[1] = ((words[0] >> 52) | (words[ 1] << 12)) & mask;\n        lo[2] = ((words[1] >> 40) | (words[ 2] << 24)) & mask;\n        lo[3] = ((words[2] >> 28) | (words[ 3] << 36)) & mask;\n        lo[4] = ((words[3] >> 16) | (words[ 4] << 48)) & mask;\n        hi[0] =  (words[4] >>  4)                      & mask;\n        hi[1] = ((words[4] >> 56) | (words[ 5] <<  8)) & mask;\n        hi[2] = ((words[5] >> 44) | (words[ 6] << 20)) & mask;\n        hi[3] = ((words[6] >> 32) | (words[ 7] << 32)) & mask;\n        hi[4] =   words[7] >> 20                             ;\n\n        lo = Scalar52::montgomery_mul(&lo, &constants::R);  // (lo * R) / R = lo\n        hi = Scalar52::montgomery_mul(&hi, &constants::RR); // (hi * R^2) / R = hi * R\n\n        Scalar52::add(&hi, &lo)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/m",
                            "content": "fn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_52_52"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "fn m(x: u64, y: u64) -> (z: u128)\nrequires\n    x < (1u64 << 52),\n    y < (1u64 << 52),\nensures\n    z < (1u128 << 104),\n    z == x * y\n{\n    proof {lemma_52_52(x, y);}\n    (x as u128) * (y as u128)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/square",
                            "content": "    pub fn square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/square_internal",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        to_nat(&result.limbs) == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        assume(false); // TODO: Add proper Montgomery arithmetic proofs\n        let aa = Scalar52::montgomery_reduce(&Scalar52::square_internal(self));\n        Scalar52::montgomery_reduce(&Scalar52::mul_internal(&aa, &constants::RR))\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/from_bytes",
                            "content": "    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/bytes_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/words_to_nat"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures bytes_to_nat(bytes) == to_nat(&s.limbs)\n    {\n        let mut words = [0u64; 4];\n        for i in 0..4\n            invariant 0 <= i <= 4 // proof\n        {\n            for j in 0..8\n                invariant 0 <= j <= 8 && i < 4\n            {\n                proof {\n                    assert(i < 4 && j < 8);\n                    assert((i as u64)*8u64 < 32u64);\n                    let idx = (i as u64) * 8 + (j as u64);\n                    assert(idx < 32);\n                }\n                words[i] |= (bytes[(i * 8) + j] as u64) << (j * 8);\n            }\n        }\n        //TODO: prove that bytes_to_nat(bytes) == words_to_nat(&words)\n        assume(bytes_to_nat(bytes) == words_to_nat(&words));\n        proof {\n            assert(1u64 << 52 > 0) by (bit_vector);\n            assert(1u64 << 48 > 0) by (bit_vector);\n            // TODO: prove property about words array\n        }\n\n        let mask = (1u64 << 52) - 1;\n        let top_mask = (1u64 << 48) - 1;\n        let mut s = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        //test workflow graphs\n        s.limbs[0] =   words[0]                            & mask;\n        s.limbs[1] = ((words[0] >> 52) | (words[1] << 12)) & mask;\n        s.limbs[2] = ((words[1] >> 40) | (words[2] << 24)) & mask;\n        s.limbs[3] = ((words[2] >> 28) | (words[3] << 36)) & mask;\n        s.limbs[4] =  (words[3] >> 16)                     & top_mask;\n\n        assume(false); // TODO: complete the proof\n\n        s\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/index",
                            "content": "    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }",
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn index(&self, _index: usize) -> &u64 {\n        &(self.limbs[_index])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_square",
                            "content": "    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/montgomery_radix",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/square_internal"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limbs_bounded(&result),\n        (to_nat(&result.limbs) * montgomery_radix()) % group_order() == (to_nat(&self.limbs) * to_nat(&self.limbs)) % group_order(),\n    {\n        Scalar52::montgomery_reduce(&Scalar52::square_internal(self))\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/add",
                            "content": "    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector); }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        proof {\n            // Base case: empty subrange has value 0\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(b.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(sum.limbs@.subrange(0, 0 as int)) == 0);\n            assert((carry >> 52) == 0) by (bit_vector) requires carry == 0;\n            lemma2_to64();\n            assert(pow2(0) == 1);\n        }\n        for i in 0..5\n           invariant\n                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                    limbs_bounded(a),\n                    limbs_bounded(b),\n                    mask == (1u64 << 52) - 1,\n                    i == 0 ==> carry == 0,\n                    i >= 1 ==> (carry >> 52) < 2,\n                    seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) ==\n                    seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2((52 * (i) as nat))\n        {\n            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}\n            let ghost old_carry = carry;\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            let ghost sum_loop_start = sum;\n            sum.limbs[i] = carry & mask;\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            proof {\n                lemma_add_loop_invariant(sum, carry, i, a, b, old_carry, mask, sum_loop_start);\n            }\n            proof {lemma_add_carry_and_sum_bounds(carry, mask);}\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) ==\n               seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2((52 * (5) as nat)));\n\n        proof {lemma_add_sum_simplify(a, b, &sum, carry);}\n\n        // subtract l if the sum is >= l\n        proof { lemma_l_value_properties(&constants::L, &sum); }\n        assert(group_order() > to_nat(&sum.limbs) - group_order() >= -group_order());\n        proof{lemma_l_equals_group_order();}\n        proof{lemma_mod_sub_multiples_vanish(to_nat(&sum.limbs) as int, group_order() as int);}\n        Scalar52::sub(&sum, &constants::L)\n\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/limbs_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_loop_bounds",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_loop_invariant",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_carry_and_sum_bounds",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_add_sum_simplify",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_l_equals_group_order",
                              "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_specs.rs/seq_u64_to_nat",
                              "/curve25519-dalek/src/backend/serial/u64/scalar_lemmas.rs/lemma_l_value_properties"
                            ],
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        to_nat(&a.limbs) < group_order(),\n        to_nat(&b.limbs) < group_order(),\n    ensures\n        to_nat(&s.limbs) == (to_nat(&a.limbs) + to_nat(&b.limbs)) % group_order(),\n    {\n        let mut sum = Scalar52 { limbs: [0u64, 0u64, 0u64, 0u64, 0u64] };\n        proof { assert(1u64 << 52 > 0) by (bit_vector); }\n        let mask = (1u64 << 52) - 1;\n\n        // a + b\n        let mut carry: u64 = 0;\n        proof {\n            // Base case: empty subrange has value 0\n            assert(seq_u64_to_nat(a.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(b.limbs@.subrange(0, 0 as int)) == 0);\n            assert(seq_u64_to_nat(sum.limbs@.subrange(0, 0 as int)) == 0);\n            assert((carry >> 52) == 0) by (bit_vector) requires carry == 0;\n            lemma2_to64();\n            assert(pow2(0) == 1);\n        }\n        for i in 0..5\n           invariant\n                    forall|j: int| 0 <= j < i ==> sum.limbs[j] < 1u64 << 52,\n                    limbs_bounded(a),\n                    limbs_bounded(b),\n                    mask == (1u64 << 52) - 1,\n                    i == 0 ==> carry == 0,\n                    i >= 1 ==> (carry >> 52) < 2,\n                    seq_u64_to_nat(a.limbs@.subrange(0, i as int)) + seq_u64_to_nat(b.limbs@.subrange(0, i as int)) ==\n                    seq_u64_to_nat(sum.limbs@.subrange(0, i as int)) + (carry >> 52) * pow2((52 * (i) as nat))\n        {\n            proof {lemma_add_loop_bounds(i as int, carry, a.limbs[i as int], b.limbs[i as int]);}\n            let ghost old_carry = carry;\n            carry = a.limbs[i] + b.limbs[i] + (carry >> 52);\n            let ghost sum_loop_start = sum;\n            sum.limbs[i] = carry & mask;\n            assert(sum_loop_start.limbs@.subrange(0, i as int) == sum.limbs@.subrange(0, i as int));\n            proof {\n                lemma_add_loop_invariant(sum, carry, i, a, b, old_carry, mask, sum_loop_start);\n            }\n            proof {lemma_add_carry_and_sum_bounds(carry, mask);}\n        }\n\n        assert(seq_u64_to_nat(a.limbs@.subrange(0, 5 as int)) + seq_u64_to_nat(b.limbs@.subrange(0, 5 as int)) ==\n               seq_u64_to_nat(sum.limbs@.subrange(0, 5 as int)) + (carry >> 52) * pow2((52 * (5) as nat)));\n\n        proof {lemma_add_sum_simplify(a, b, &sum, carry);}\n\n        // subtract l if the sum is >= l\n        proof { lemma_l_value_properties(&constants::L, &sum); }\n        assert(group_order() > to_nat(&sum.limbs) - group_order() >= -group_order());\n        proof{lemma_l_equals_group_order();}\n        proof{lemma_mod_sub_multiples_vanish(to_nat(&sum.limbs) as int, group_order() as int);}\n        Scalar52::sub(&sum, &constants::L)\n\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/scalar.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }",
                            "code_name": "mask_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar52: {:?}\", self.limbs)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/add_assign",
                            "content": "    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn add_assign(&mut self, _rhs: &'a FieldElement51) {\n        for i in 0..5 {\n            self.0[i] += _rhs.0[i];\n        }\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/neg",
                            "content": "    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/negate"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn neg(self) -> FieldElement51 {\n        let mut output = *self;\n        output.negate();\n        output\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/add",
                            "content": "    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn add(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        let mut output = *self;\n        output += _rhs;\n        output\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                            "content": "    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/reduce"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn to_bytes(self) -> [u8; 32] {\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.0).0;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/from_limbs",
                            "content": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        FieldElement51(limbs)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/square2",
                            "content": "    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            square.0[i] *= 2;\n        }\n\n        square\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/pow2k"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn square2(&self) -> FieldElement51 {\n        let mut square = self.pow2k(1);\n        for i in 0..5 {\n            square.0[i] *= 2;\n        }\n\n        square\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign",
                            "content": "    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice) {\n        self.0[0].conditional_assign(&other.0[0], choice);\n        self.0[1].conditional_assign(&other.0[1], choice);\n        self.0[2].conditional_assign(&other.0[2], choice);\n        self.0[3].conditional_assign(&other.0[3], choice);\n        self.0[4].conditional_assign(&other.0[4], choice);\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/reduce",
                            "content": "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn reduce(mut limbs: [u64; 5]) -> FieldElement51 {\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        FieldElement51(limbs)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/mul",
                            "content": "    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn mul(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        /// Helper function to multiply two 64-bit integers with 128\n        /// bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }\n\n        // Alias self, _rhs for more readable formulas\n        let a: &[u64; 5] = &self.0;\n        let b: &[u64; 5] = &_rhs.0;\n\n        // Precondition: assume input limbs a[i], b[i] are bounded as\n        //\n        // a[i], b[i] < 2^(51 + b)\n        //\n        // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n        // 64-bit precomputations to avoid 128-bit multiplications.\n        //\n        // This fits into a u64 whenever 51 + b + lg(19) < 64.\n        //\n        // Since 51 + b + lg(19) < 51 + 4.25 + b\n        //                       = 55.25 + b,\n        // this fits if b < 8.75.\n        let b1_19 = b[1] * 19;\n        let b2_19 = b[2] * 19;\n        let b3_19 = b[3] * 19;\n        let b4_19 = b[4] * 19;\n\n        // Multiply to get 128-bit coefficients of output\n        let     c0: u128 = m(a[0], b[0]) + m(a[4], b1_19) + m(a[3], b2_19) + m(a[2], b3_19) + m(a[1], b4_19);\n        let mut c1: u128 = m(a[1], b[0]) + m(a[0],  b[1]) + m(a[4], b2_19) + m(a[3], b3_19) + m(a[2], b4_19);\n        let mut c2: u128 = m(a[2], b[0]) + m(a[1],  b[1]) + m(a[0],  b[2]) + m(a[4], b3_19) + m(a[3], b4_19);\n        let mut c3: u128 = m(a[3], b[0]) + m(a[2],  b[1]) + m(a[1],  b[2]) + m(a[0],  b[3]) + m(a[4], b4_19);\n        let mut c4: u128 = m(a[4], b[0]) + m(a[3],  b[1]) + m(a[2],  b[2]) + m(a[1],  b[3]) + m(a[0] , b[4]);\n\n        // How big are the c[i]? We have\n        //\n        //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n        //         < 2^(102 + lg(1 + 4*19) + 2*b)\n        //         < 2^(108.27 + 2*b)\n        //\n        // The carry (c[i] >> 51) fits into a u64 when\n        //    108.27 + 2*b - 51 < 64\n        //    2*b < 6.73\n        //    b < 3.365.\n        //\n        // So we require b < 3 to ensure this fits.\n        debug_assert!(a[0] < (1 << 54)); debug_assert!(b[0] < (1 << 54));\n        debug_assert!(a[1] < (1 << 54)); debug_assert!(b[1] < (1 << 54));\n        debug_assert!(a[2] < (1 << 54)); debug_assert!(b[2] < (1 << 54));\n        debug_assert!(a[3] < (1 << 54)); debug_assert!(b[3] < (1 << 54));\n        debug_assert!(a[4] < (1 << 54)); debug_assert!(b[4] < (1 << 54));\n\n        // Casting to u64 and back tells the compiler that the carry is\n        // bounded by 2^64, so that the addition is a u128 + u64 rather\n        // than u128 + u128.\n\n        const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n        let mut out = [0u64; 5];\n\n        c1 += ((c0 >> 51) as u64) as u128;\n        out[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n        c2 += ((c1 >> 51) as u64) as u128;\n        out[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n        c3 += ((c2 >> 51) as u64) as u128;\n        out[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n        c4 += ((c3 >> 51) as u64) as u128;\n        out[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n        let carry: u64 = (c4 >> 51) as u64;\n        out[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n        // To see that this does not overflow, we need out[0] + carry * 19 < 2^64.\n        //\n        // c4 < a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0 + (carry from c3)\n        //    < 5*(2^(51 + b) * 2^(51 + b)) + (carry from c3)\n        //    < 2^(102 + 2*b + lg(5)) + 2^64.\n        //\n        // When b < 3 we get\n        //\n        // c4 < 2^110.33  so that carry < 2^59.33\n        //\n        // so that\n        //\n        // out[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n        //\n        // and there is no overflow.\n        out[0] += carry * 19;\n\n        // Now out[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n        out[1] += out[0] >> 51;\n        out[0] &= LOW_51_BIT_MASK;\n\n        // Now out[i] < 2^(51 + epsilon) for all i.\n        FieldElement51(out)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/negate",
                            "content": "    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/reduce"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn negate(&mut self) {\n        // See commentary in the Sub impl\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.0[0],\n            36028797018963952u64 - self.0[1],\n            36028797018963952u64 - self.0[2],\n            36028797018963952u64 - self.0[3],\n            36028797018963952u64 - self.0[4],\n        ]);\n        self.0 = neg.0;\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/fmt",
                            "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"FieldElement51({:?})\", &self.0[..])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/m",
                            "content": "        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "        fn m(x: u64, y: u64) -> u128 { (x as u128) * (y as u128) }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/load8_at",
                            "content": "        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                            "content": "    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub const fn from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n        const fn load8_at(input: &[u8], i: usize) -> u64 {\n               (input[i] as u64)\n            | ((input[i + 1] as u64) << 8)\n            | ((input[i + 2] as u64) << 16)\n            | ((input[i + 3] as u64) << 24)\n            | ((input[i + 4] as u64) << 32)\n            | ((input[i + 5] as u64) << 40)\n            | ((input[i + 6] as u64) << 48)\n            | ((input[i + 7] as u64) << 56)\n        }\n\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        FieldElement51(\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/sub",
                            "content": "    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/reduce"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn sub(self, _rhs: &'a FieldElement51) -> FieldElement51 {\n        // To avoid underflow, first add a multiple of p.\n        // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n        //\n        // If we could statically track the bitlengths of the limbs\n        // of every FieldElement51, we could choose a multiple of p\n        // just bigger than _rhs and avoid having to do a reduction.\n        //\n        // Since we don't yet have type-level integers to do this, we\n        // have to add an explicit reduction call here.\n        FieldElement51::reduce([\n            (self.0[0] + 36028797018963664u64) - _rhs.0[0],\n            (self.0[1] + 36028797018963952u64) - _rhs.0[1],\n            (self.0[2] + 36028797018963952u64) - _rhs.0[2],\n            (self.0[3] + 36028797018963952u64) - _rhs.0[3],\n            (self.0[4] + 36028797018963952u64) - _rhs.0[4],\n        ])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/sub_assign",
                            "content": "    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn sub_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) - _rhs;\n        self.0 = result.0;\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/conditional_swap",
                            "content": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_swap(a: &mut FieldElement51, b: &mut FieldElement51, choice: Choice) {\n        u64::conditional_swap(&mut a.0[0], &mut b.0[0], choice);\n        u64::conditional_swap(&mut a.0[1], &mut b.0[1], choice);\n        u64::conditional_swap(&mut a.0[2], &mut b.0[2], choice);\n        u64::conditional_swap(&mut a.0[3], &mut b.0[3], choice);\n        u64::conditional_swap(&mut a.0[4], &mut b.0[4], choice);\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/pow2k",
                            "content": "    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn pow2k(&self, mut k: u32) -> FieldElement51 {\n\n        debug_assert!( k > 0 );\n\n        /// Multiply two 64-bit integers with 128 bits of output.\n        #[inline(always)]\n        fn m(x: u64, y: u64) -> u128 {\n            (x as u128) * (y as u128)\n        }\n\n        let mut a: [u64; 5] = self.0;\n\n        loop {\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            debug_assert!(a[0] < (1 << 54));\n            debug_assert!(a[1] < (1 << 54));\n            debug_assert!(a[2] < (1 << 54));\n            debug_assert!(a[3] < (1 << 54));\n            debug_assert!(a[4] < (1 << 54));\n\n            const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1;\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n\n            k -= 1;\n            if k == 0 {\n                break;\n            }\n        }\n\n        FieldElement51(a)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select",
                            "content": "    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn conditional_select(\n        a: &FieldElement51,\n        b: &FieldElement51,\n        choice: Choice,\n    ) -> FieldElement51 {\n        FieldElement51([\n            u64::conditional_select(&a.0[0], &b.0[0], choice),\n            u64::conditional_select(&a.0[1], &b.0[1], choice),\n            u64::conditional_select(&a.0[2], &b.0[2], choice),\n            u64::conditional_select(&a.0[3], &b.0[3], choice),\n            u64::conditional_select(&a.0[4], &b.0[4], choice),\n        ])\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/mul_assign",
                            "content": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }",
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn mul_assign(&mut self, _rhs: &'a FieldElement51) {\n        let result = (self as &FieldElement51) * _rhs;\n        self.0 = result.0;\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field.rs/square",
                            "content": "    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field.rs/pow2k"
                            ],
                            "code_name": "mod.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn square(&self) -> FieldElement51 {\n        self.pow2k(1)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      },
                      {
                        "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs",
                        "content": "",
                        "code_name": "",
                        "children": [
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/from_bytes",
                            "content": "    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            // last bit is ignored\n            as_nat(r.limbs) == as_nat_32_u8(*bytes) % pow2(255)\n    {\n        proof {\n            l51_bit_mask_lt(); // No over/underflow in the below let-def\n            assume(false);\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat_32_u8",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/load8_at"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub const fn from_bytes(bytes: &[u8; 32]) -> (r: FieldElement51)\n        ensures\n            // last bit is ignored\n            as_nat(r.limbs) == as_nat_32_u8(*bytes) % pow2(255)\n    {\n        proof {\n            l51_bit_mask_lt(); // No over/underflow in the below let-def\n            assume(false);\n        }\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{ limbs:\n        // load bits [  0, 64), no shift\n        [  load8_at(bytes,  0)        & low_51_bit_mask\n        // load bits [ 48,112), shift to [ 51,112)\n        , (load8_at(bytes,  6) >>  3) & low_51_bit_mask\n        // load bits [ 96,160), shift to [102,160)\n        , (load8_at(bytes, 12) >>  6) & low_51_bit_mask\n        // load bits [152,216), shift to [153,216)\n        , (load8_at(bytes, 19) >>  1) & low_51_bit_mask\n        // load bits [192,256), shift to [204,112)\n        , (load8_at(bytes, 24) >> 12) & low_51_bit_mask\n        ]}\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/negate",
                            "content": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            negate_proof(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        self.limbs = neg.limbs;\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/negate_proof",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/negate_lemmas.rs/lemma_neg_no_underflow",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn negate(&mut self)\n        requires\n            forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 51),\n        ensures\n            forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n            // Assume we start with l = (l0, l1, l2, l3, l4).\n            // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n            // ( 36028797018963664u64 - l0,\n            //   36028797018963952u64 - l1,\n            //   36028797018963952u64 - l2,\n            //   36028797018963952u64 - l3,\n            //   36028797018963952u64 - l4 )\n            // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n            // Further, as_nat((c0, c, c, c, c)) = p, so\n            // as_nat(16 * (c0, c, c, c, c) - l) is 16p - as_nat(l)\n            // We know as_nat(reduce(v)) = as_nat(v) - p * (v4 >> 51) for any v.\n            // This gives us the identity\n            // as_nat(negate(l)) = as_nat(reduce(16 * (c0, c, c, c, c) - l))\n            //                   = 16p - as_nat(l) - p * ((16c - l4) >> 51)\n            // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n            as_nat(self.limbs) == 16 * p() - as_nat(old(self).limbs) - p() * ((36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n            (as_nat(self.limbs) + as_nat(old(self).limbs)) % p() == 0\n    {\n        proof {\n            lemma_neg_no_underflow(self.limbs);\n            negate_proof(self.limbs);\n        }\n        // See commentary in the Sub impl: (copied below)\n            // To avoid underflow, first add a multiple of p.\n            // Choose 16*p = p << 4 to be larger than 54-bit _rhs.\n            //\n            // If we could statically track the bitlengths of the limbs\n            // of every FieldElement51, we could choose a multiple of p\n            // just bigger than _rhs and avoid having to do a reduction.\n            //\n            // Since we don't yet have type-level integers to do this, we\n            // have to add an explicit reduction call here.\n        // Note on \"magic numbers\":\n        // 36028797018963664u64 = 2^55 - 304 = 16 * (2^51 - 19)\n        // 36028797018963952u64 = 2^55 - 16 =  16 * (2^51 - 1)\n        let neg = FieldElement51::reduce([\n            36028797018963664u64 - self.limbs[0],\n            36028797018963952u64 - self.limbs[1],\n            36028797018963952u64 - self.limbs[2],\n            36028797018963952u64 - self.limbs[3],\n            36028797018963952u64 - self.limbs[4],\n        ]);\n        self.limbs = neg.limbs;\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/to_bytes",
                            "content": "    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            // canonical encoding, i.e. mod p value\n            as_nat_32_u8(r) == as_nat(self.limbs) % p()\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            assume(false);\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shifted_lt",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_add_then_shift",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat_32_u8",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn to_bytes(self) -> (r: [u8; 32])\n        ensures\n            // canonical encoding, i.e. mod p value\n            as_nat_32_u8(r) == as_nat(self.limbs) % p()\n    {\n        proof {\n            let l = spec_reduce(self.limbs);\n            lemma_reduce(self.limbs);\n\n            let q0 = (l[0] + 19) as u64 >> 51;\n            let q1 = (l[1] + q0) as u64 >> 51;\n            let q2 = (l[2] + q1) as u64 >> 51;\n            let q3 = (l[3] + q2) as u64 >> 51;\n            let q4 = (l[4] + q3) as u64 >> 51;\n\n            assert(19 < (1u64 << 52)) by (bit_vector);\n            lemma_add_then_shift(l[0], 19);\n            lemma_add_then_shift(l[1], q0);\n            lemma_add_then_shift(l[2], q1);\n            lemma_add_then_shift(l[3], q2);\n            lemma_add_then_shift(l[4], q3);\n\n            let l0 = (l[0] + 19 * q4) as u64;\n            let l1 = (l[1] + (l0 >> 51)) as u64;\n            let l2 = (l[2] + (l1 >> 51)) as u64;\n            let l3 = (l[3] + (l2 >> 51)) as u64;\n            let l4 = (l[3] + (l3 >> 51)) as u64;\n\n            assert( 19 * q4 < 1u64 << 7) by {\n                // Explicit values for pow2(k) for k < 64\n                lemma2_to64();\n                shift_is_pow2(5); // now we know 19 < 1u64 << 5 for free\n                shift_is_pow2(2);\n                shift_is_pow2(7);\n                lemma_pow2_adds(5, 2);\n            }\n            assert(((1u64 << 7)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            assert(((1u64 << 13)) + (1u64 << 52) < (1u64 << 53)) by (bit_vector);\n            shifted_lt(l0, 51);\n            shifted_lt(l1, 51);\n            shifted_lt(l2, 51);\n            shifted_lt(l3, 51);\n\n            l51_bit_mask_lt();\n\n            assume(false);\n\n            // TODO\n            // let rr = [\n            //     l0 & LOW_51_BIT_MASK,\n            //     l1 & LOW_51_BIT_MASK,\n            //     l2 & LOW_51_BIT_MASK,\n            //     l3 & LOW_51_BIT_MASK,\n            //     l4 & LOW_51_BIT_MASK\n            // ];\n\n            // let r = [\n            //     rr[0]                           as u8,\n            //     (rr[0] >>  8)                    as u8,\n            //     (rr[0] >> 16)                    as u8,\n            //     (rr[0] >> 24)                    as u8,\n            //     (rr[0] >> 32)                    as u8,\n            //     (rr[0] >> 40)                    as u8,\n            //     ((rr[0] >> 48) | (rr[1] << 3)) as u8,\n            //     (rr[1] >>  5)                    as u8,\n            //     (rr[1] >> 13)                    as u8,\n            //     (rr[1] >> 21)                    as u8,\n            //     (rr[1] >> 29)                    as u8,\n            //     (rr[1] >> 37)                    as u8,\n            //     ((rr[1] >> 45) | (rr[2] << 6)) as u8,\n            //     (rr[2] >>  2)                    as u8,\n            //     (rr[2] >> 10)                    as u8,\n            //     (rr[2] >> 18)                    as u8,\n            //     (rr[2] >> 26)                    as u8,\n            //     (rr[2] >> 34)                    as u8,\n            //     (rr[2] >> 42)                    as u8,\n            //     ((rr[2] >> 50) | (rr[3] << 1)) as u8,\n            //     (rr[3] >>  7)                    as u8,\n            //     (rr[3] >> 15)                    as u8,\n            //     (rr[3] >> 23)                    as u8,\n            //     (rr[3] >> 31)                    as u8,\n            //     (rr[3] >> 39)                    as u8,\n            //     ((rr[3] >> 47) | (rr[4] << 4)) as u8,\n            //     (rr[4] >>  4)                    as u8,\n            //     (rr[4] >> 12)                    as u8,\n            //     (rr[4] >> 20)                    as u8,\n            //     (rr[4] >> 28)                    as u8,\n            //     (rr[4] >> 36)                    as u8,\n            //     (rr[4] >> 44)                    as u8\n            // ];\n\n        }\n        // Let h = limbs[0] + limbs[1]*2^51 + ... + limbs[4]*2^204.\n        //\n        // Write h = pq + r with 0 <= r < p.\n        //\n        // We want to compute r = h mod p.\n        //\n        // If h < 2*p = 2^256 - 38,\n        // then q = 0 or 1,\n        //\n        // with q = 0 when h < p\n        //  and q = 1 when h >= p.\n        //\n        // Notice that h >= p <==> h + 19 >= p + 19 <==> h + 19 >= 2^255.\n        // Therefore q can be computed as the carry bit of h + 19.\n\n        // First, reduce the limbs to ensure h < 2*p.\n        let mut limbs = FieldElement51::reduce(self.limbs).limbs;\n\n        let mut q = (limbs[0] + 19) >> 51;\n        q = (limbs[1] + q) >> 51;\n        q = (limbs[2] + q) >> 51;\n        q = (limbs[3] + q) >> 51;\n        q = (limbs[4] + q) >> 51;\n\n        // Now we can compute r as r = h - pq = r - (2^255-19)q = r + 19q - 2^255q\n\n        limbs[0] += 19 * q;\n\n        // Now carry the result to compute r + 19q ...\n        let low_51_bit_mask = (1u64 << 51) - 1;\n        limbs[1] += limbs[0] >> 51;\n        limbs[0] &= low_51_bit_mask;\n        limbs[2] += limbs[1] >> 51;\n        limbs[1] &= low_51_bit_mask;\n        limbs[3] += limbs[2] >> 51;\n        limbs[2] &= low_51_bit_mask;\n        limbs[4] += limbs[3] >> 51;\n        limbs[3] &= low_51_bit_mask;\n        // ... but instead of carrying (limbs[4] >> 51) = 2^255q\n        // into another limb, discard it, subtracting the value\n        limbs[4] &= low_51_bit_mask;\n\n        // Now arrange the bits of the limbs.\n        let mut s = [0u8;32];\n        s[ 0] =   limbs[0]                           as u8;\n        s[ 1] =  (limbs[0] >>  8)                    as u8;\n        s[ 2] =  (limbs[0] >> 16)                    as u8;\n        s[ 3] =  (limbs[0] >> 24)                    as u8;\n        s[ 4] =  (limbs[0] >> 32)                    as u8;\n        s[ 5] =  (limbs[0] >> 40)                    as u8;\n        s[ 6] = ((limbs[0] >> 48) | (limbs[1] << 3)) as u8;\n        s[ 7] =  (limbs[1] >>  5)                    as u8;\n        s[ 8] =  (limbs[1] >> 13)                    as u8;\n        s[ 9] =  (limbs[1] >> 21)                    as u8;\n        s[10] =  (limbs[1] >> 29)                    as u8;\n        s[11] =  (limbs[1] >> 37)                    as u8;\n        s[12] = ((limbs[1] >> 45) | (limbs[2] << 6)) as u8;\n        s[13] =  (limbs[2] >>  2)                    as u8;\n        s[14] =  (limbs[2] >> 10)                    as u8;\n        s[15] =  (limbs[2] >> 18)                    as u8;\n        s[16] =  (limbs[2] >> 26)                    as u8;\n        s[17] =  (limbs[2] >> 34)                    as u8;\n        s[18] =  (limbs[2] >> 42)                    as u8;\n        s[19] = ((limbs[2] >> 50) | (limbs[3] << 1)) as u8;\n        s[20] =  (limbs[3] >>  7)                    as u8;\n        s[21] =  (limbs[3] >> 15)                    as u8;\n        s[22] =  (limbs[3] >> 23)                    as u8;\n        s[23] =  (limbs[3] >> 31)                    as u8;\n        s[24] =  (limbs[3] >> 39)                    as u8;\n        s[25] = ((limbs[3] >> 47) | (limbs[4] << 4)) as u8;\n        s[26] =  (limbs[4] >>  4)                    as u8;\n        s[27] =  (limbs[4] >> 12)                    as u8;\n        s[28] =  (limbs[4] >> 20)                    as u8;\n        s[29] =  (limbs[4] >> 28)                    as u8;\n        s[30] =  (limbs[4] >> 36)                    as u8;\n        s[31] =  (limbs[4] >> 44)                    as u8;\n\n        // High bit should be zero.\n        // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n        // debug_assert!((s[31] & 0b1000_0000u8) == 0u8);\n\n        s\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": false
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/reduce",
                            "content": "    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p()\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            pow255_gt_19();\n            lemma_mod_multiples_vanish((limbs[4] >> 51) as int, as_nat(spec_reduce(limbs)) as int, p() as int);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/spec_reduce",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/reduce_lemmas.rs/lemma_boundaries",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n        ensures\n            r.limbs == spec_reduce(limbs),\n            forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n            (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n            as_nat(r.limbs) == as_nat(limbs) - p() * (limbs[4] >> 51),\n            as_nat(r.limbs) % p() == as_nat(limbs) % p()\n    {\n        proof {\n            lemma_boundaries(limbs);\n            lemma_reduce(limbs);\n            pow255_gt_19();\n            lemma_mod_multiples_vanish((limbs[4] >> 51) as int, as_nat(spec_reduce(limbs)) as int, p() as int);\n        }\n\n        // Since the input limbs are bounded by 2^64, the biggest\n        // carry-out is bounded by 2^13.\n        //\n        // The biggest carry-in is c4 * 19, resulting in\n        //\n        // 2^51 + 19*2^13 < 2^51.0000000001\n        //\n        // Because we don't need to canonicalize, only to reduce the\n        // limb sizes, it's OK to do a \"weak reduction\", where we\n        // compute the carry-outs in parallel.\n\n        let c0 = limbs[0] >> 51;\n        let c1 = limbs[1] >> 51;\n        let c2 = limbs[2] >> 51;\n        let c3 = limbs[3] >> 51;\n        let c4 = limbs[4] >> 51;\n\n        limbs[0] &= LOW_51_BIT_MASK;\n        limbs[1] &= LOW_51_BIT_MASK;\n        limbs[2] &= LOW_51_BIT_MASK;\n        limbs[3] &= LOW_51_BIT_MASK;\n        limbs[4] &= LOW_51_BIT_MASK;\n\n        limbs[0] += c4 * 19;\n        limbs[1] += c0;\n        limbs[2] += c1;\n        limbs[3] += c2;\n        limbs[4] += c3;\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/from_limbs",
                            "content": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub(crate) const fn from_limbs(limbs: [u64; 5]) -> FieldElement51 {\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs}\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/square",
                            "content": "    pub fn square(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, 2) as nat % p()\n\n    {\n        proof {\n            // pow2(1) == 2\n            lemma2_to64();\n        }\n        self.pow2k(1)\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/pow2k"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn square(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, 2) as nat % p()\n\n    {\n        proof {\n            // pow2(1) == 2\n            lemma2_to64();\n        }\n        self.pow2k(1)\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/main",
                            "content": "fn main()\n{}",
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "fn main()\n{}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/masks_are_equal",
                            "content": "pub proof fn masks_are_equal()\n    ensures\n        LOW_51_BIT_MASK == mask51,\n        LOW_51_BIT_MASK == low_bits_mask(51),\n        LOW_51_BIT_MASK < (1u64 << 51) as nat,\n{\n    l51_bit_mask_lt();\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "pub proof fn masks_are_equal()\n    ensures\n        LOW_51_BIT_MASK == mask51,\n        LOW_51_BIT_MASK == low_bits_mask(51),\n        LOW_51_BIT_MASK < (1u64 << 51) as nat,\n{\n    l51_bit_mask_lt();\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/pow2k",
                            "content": "    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            forall |i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p()\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n\n                // precond for term_product_bounds\n                assert( 19 * bound <= u64::MAX) by {\n                    assert( 19 * (1u64 << 54) <= u64::MAX) by (compute);\n                }\n                // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n                term_product_bounds(a, bound);\n\n                // ci_0 < 77 * (1u128 << 108)\n                c_i_0_bounded(a, bound);\n\n                // precond for c_i_shift_bounded\n                assert(77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n                    assert( 77 * (1u128 << 108)+ u64::MAX <= ((u64::MAX as u128) << 51)) by (compute);\n                }\n                // ci >> 51 <= u64::MAX\n                c_i_shift_bounded(a, bound);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // NOTE: we assert the properties derived from c_i_0_bounded\n                // and c_i_shift_bounded after every variable declaration,\n                // to trigger the solver instantiation\n\n                // ci_0 defs\n\n                let c0_0: u128 = c0_0_val(a); // a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19\n                assert(c0_0 < 77 * bound_sq);\n\n                let c1_0: u128 = c1_0_val(a); // a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19\n                assert(c1_0 < 59 * bound_sq);\n\n                let c2_0: u128 = c2_0_val(a); // a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19\n                assert(c2_0 < 41 * bound_sq);\n\n                let c3_0: u128 =  c3_0_val(a); // a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]\n                assert(c3_0 < 23 * bound_sq);\n\n                let c4_0: u128 =  c4_0_val(a); // a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]\n                assert(c4_0 < 5 * bound_sq);\n\n                // ci defs\n\n                let c1 = c1_val(a); // (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                assert((c1 >> 51) <= (u64::MAX as u128));\n\n                let c2 = c2_val(a); // (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                assert((c2 >> 51) <= (u64::MAX as u128));\n\n                let c3 = c3_val(a); // (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                assert((c3 >> 51) <= (u64::MAX as u128));\n\n                let c4 = c4_val(a); // (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                assert((c4 >> 51) <= (u64::MAX as u128));\n\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert(a0_0 + carry * 19 <= u64::MAX) by {\n                    assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                }\n\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        l51_bit_mask_lt();\n\n                        assert((pow2(51) as u64) == (pow2(51) as u128));\n\n                        assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                            lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n                        }\n\n                        assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n                        }\n\n                        assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n                        }\n\n                        assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n                        }\n\n                        assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n                        }\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        lemma_u128_shr_is_div(c0_0, 51);\n                        lemma_u128_shr_is_div(c1, 51);\n                        lemma_u128_shr_is_div(c2, 51);\n                        lemma_u128_shr_is_div(c3, 51);\n                        lemma_u128_shr_is_div(c4, 51);\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51) * c1_0) by {\n                            lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n                        }\n\n                        assert(pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2( 51) * c1 - pow2(102) * c2 + pow2(102) * c2_0) by {\n                            lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n                        }\n\n                        assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(153) * c3 + pow2(153) * c3_0) by {\n                            lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n                        }\n\n                        assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(204) * c4 + pow2(204) * c4_0) by {\n                            lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n                        }\n\n                        assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255) * carry) by {\n                            lemma_mul_is_distributive_sub(pow2(204) as int, c4 as int, pow2(51) * carry);\n                            lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, carry as int);\n                            lemma_pow2_adds(204, 51);\n                        }\n\n                        // carry on the right, get p\n                        assert(\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 +\n                            19 * carry - pow2(255) * carry\n                            ==\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 -\n                            p() * carry\n                        ) by {\n                            pow255_gt_19();\n                            lemma_mul_is_distributive_sub_other_way(carry as int, pow2(255) as int, 19);\n                        }\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/shift_lemmas.rs/shift_is_pow2",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c0_0_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/div_mod_lemmas.rs/lemma_mod_diff_factor",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/term_product_bounds",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_val",
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow_nat_is_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/masked_lt_51",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_0_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/m",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c4_0_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_0_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_squared",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_div_and_mod_51",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/lemma_reorder_mul",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c1_0_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/l51_bit_mask_lt",
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow2_square",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c_i_shift_bounded",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_mul_sub",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c2_0_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2k_lemmas.rs/c3_val",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_cast_then_mod_51",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/pow2_51_lemmas.rs/lemma_shr_51_le"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n        requires\n            k > 0, // debug_assert!( k > 0 );\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54 // 51 + b for b = 3\n        ensures\n            forall |i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n            as_nat(r.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(k as nat)) as nat % p()\n    {\n        let mut a: [u64; 5] = self.limbs;\n\n        // pre-loop invariant, i = 0\n        proof {\n            assert(as_nat(a) == pow(as_nat(self.limbs) as int, pow2(0))) by {\n                lemma2_to64(); // pow2(0) = 1\n                lemma_pow1(as_nat(self.limbs) as int);\n            }\n        }\n\n        for i in 0..k\n            invariant\n                forall |i: int| 0 <= i < 5 ==> a[i] < 1u64 << 54,\n                as_nat(a) % p() == pow(as_nat(self.limbs) as int, pow2(i as nat)) as nat % p(),\n        {\n            proof {\n                pow255_gt_19(); // p > 0\n                lemma2_to64_rest(); // pow2(51 | 54)\n                shift_is_pow2(54);\n\n                let bound = 1u64 << 54;\n                let bound19 = (19 * bound) as u64;\n                let bound_sq = 1u128 << 108;\n\n                // u64 to u128 conversion forces extra assert\n                assert( (1u64 << 54) * ((19 * (1u64 << 54)) as u64) == 19 * (1u128 << 108)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 54) as u128) == (1u128 << 108)) by (bit_vector);\n\n                // precond for term_product_bounds\n                assert( 19 * bound <= u64::MAX) by {\n                    assert( 19 * (1u64 << 54) <= u64::MAX) by (compute);\n                }\n                // If a[i] < 2^54 then a[i] * a[j] < 2^108 and a[i] * (19 * a[j]) < 19 * 2^108\n                term_product_bounds(a, bound);\n\n                // ci_0 < 77 * (1u128 << 108)\n                c_i_0_bounded(a, bound);\n\n                // precond for c_i_shift_bounded\n                assert(77 * (bound * bound) + u64::MAX <= ((u64::MAX as u128) << 51)) by {\n                    assert( 77 * (1u128 << 108)+ u64::MAX <= ((u64::MAX as u128) << 51)) by (compute);\n                }\n                // ci >> 51 <= u64::MAX\n                c_i_shift_bounded(a, bound);\n\n                // bv arithmetic\n                assert(19 < (1u64 << 5)) by (bit_vector);\n                assert((1u64 << 51) < (1u64 << 52)) by (bit_vector);\n                assert((1u64 << 52) < (1u64 << 54)) by (bit_vector);\n                assert((1u64 << 54) < (1u64 << 59)) by (bit_vector);\n                assert((1u64 << 54) * (1u64 << 5) == (1u64 << 59)) by (bit_vector);\n                assert(((1u64 << 54) as u128) * ((1u64 << 59) as u128) == (1u128 << 113)) by (bit_vector);\n\n                let a3_19 = (19 * a[3]) as u64;\n                let a4_19 = (19 * a[4]) as u64;\n\n                // NOTE: we assert the properties derived from c_i_0_bounded\n                // and c_i_shift_bounded after every variable declaration,\n                // to trigger the solver instantiation\n\n                // ci_0 defs\n\n                let c0_0: u128 = c0_0_val(a); // a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19\n                assert(c0_0 < 77 * bound_sq);\n\n                let c1_0: u128 = c1_0_val(a); // a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19\n                assert(c1_0 < 59 * bound_sq);\n\n                let c2_0: u128 = c2_0_val(a); // a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19\n                assert(c2_0 < 41 * bound_sq);\n\n                let c3_0: u128 =  c3_0_val(a); // a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]\n                assert(c3_0 < 23 * bound_sq);\n\n                let c4_0: u128 =  c4_0_val(a); // a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]\n                assert(c4_0 < 5 * bound_sq);\n\n                // ci defs\n\n                let c1 = c1_val(a); // (c1_0 + ((c0_0 >> 51) as u64) as u128) as u128;\n                assert((c1 >> 51) <= (u64::MAX as u128));\n\n                let c2 = c2_val(a); // (c2_0 + ((c1 >> 51) as u64) as u128) as u128;\n                assert((c2 >> 51) <= (u64::MAX as u128));\n\n                let c3 = c3_val(a); // (c3_0 + ((c2 >> 51) as u64) as u128) as u128;\n                assert((c3 >> 51) <= (u64::MAX as u128));\n\n                let c4 = c4_val(a); // (c4_0 + ((c3 >> 51) as u64) as u128) as u128;\n                assert((c4 >> 51) <= (u64::MAX as u128));\n\n                let a0_0 = (c0_0 as u64) & LOW_51_BIT_MASK;\n                // a0_0 < (1u64 << 51)\n                masked_lt_51(c0_0 as u64);\n\n                let a1_0 = (c1 as u64) & LOW_51_BIT_MASK;\n                // a1_0 < (1u64 << 51)\n                masked_lt_51(c1 as u64);\n\n                let a2 = (c2 as u64) & LOW_51_BIT_MASK;\n                // a2 < (1u64 << 51)\n                masked_lt_51(c2 as u64);\n\n                let a3 = (c3 as u64) & LOW_51_BIT_MASK;\n                // a3 < (1u64 << 51)\n                masked_lt_51(c3 as u64);\n\n                let carry: u64 = (c4 >> 51) as u64;\n                let a4 = (c4 as u64) & LOW_51_BIT_MASK;\n                // a4 < (1u64 << 51)\n                masked_lt_51(c4 as u64);\n\n                assert(c4 <= c4_0 + (u64::MAX as u128));\n                lemma_shr_51_le(c4, (5 * bound_sq + (u64::MAX as u128)) as u128 );\n\n                // From the comments below:\n                // c4 < 2^110.33  so that carry < 2^59.33\n                // and\n                // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n\n                // ceil(2^59.33)\n                let pow2_5933 = 724618875532318195u64;\n\n                assert((5 * (1u128 << 108) + (u64::MAX as u128)) as u128 >> 51 < (pow2_5933 as u128)) by (compute);\n                assert(carry < pow2_5933);\n\n                // a[0] += carry * 19 fits in u64\n                assert(a0_0 + carry * 19 <= u64::MAX) by {\n                    assert((1u64 << 51) + 19 * pow2_5933 <= u64::MAX) by (compute);\n                }\n\n                let a0_1 = (a0_0 + carry * 19) as u64;\n\n                lemma_shr_51_le(a0_1 as u128, u64::MAX as u128);\n                assert( ((u64::MAX as u128) >> 51) < (1u64 << 13) ) by (compute);\n\n                // a1_0 < (1u64 << 51)\n                assert((1u64 << 51) + (1u64 << 13) < (1u64 << 52)) by (compute);\n\n                // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n                assert(a1_0 + (a0_1 >> 51) < (1u64 << 52));\n                let a1_1 = (a1_0 + (a0_1 >> 51)) as u64;\n\n                let a0_2 = a0_1 & LOW_51_BIT_MASK;\n                // a0_2 < (1u64 << 51)\n                masked_lt_51(a0_1 as u64);\n\n                //---- end of no-overflow proof ----\n                // Loop invariant: after i loops we have as_nat(a) % p = as_nat(self.limbs) ^ (2 ^ i) % p\n                let a_hat = [a0_2, a1_1, a2, a3, a4];\n                assert(as_nat(a_hat) % p() == (as_nat(a) * as_nat(a)) % p() ) by {\n                    // it suffices to prove as_nat(a_hat) == (as_nat(a))^2 (mod p)\n                    // let s = pow2(51) for brevity\n\n                    // By definition, as_nat(a_hat) = a0_2 + s * a1_1 + s^2 * a2 + s^3 * a3 + s^4 * a4\n                    // a0_2 + s * a1_1 cancel out terms via the div/mod identity:\n                    assert(as_nat(a_hat) ==\n                        a0_1 +\n                        pow2(51) * a1_0 +\n                        pow2(102) * a2 +\n                        pow2(153) * a3 +\n                        pow2(204) * a4\n                    ) by {\n                        // a0_2 + s * a1_1 =\n                        // a0_1 % s  + s * (a1_0 + s * (a0_1 / s)) =\n                        // s * a1_0 + [s * (a0_1 / s) + a0_1 % s] = (by the div-mod identity)\n                        // s * a1_0 + a0_1\n                        assert(a0_2 + pow2(51) * a1_1 == a0_1 + pow2(51) * a1_0) by {\n                            lemma_div_and_mod_51((a0_1 >> 51), a0_2, a0_1);\n                        }\n                    }\n\n                    // Next, we replace all _ & LOW_BITS_MASK with (mod s)\n                    assert(as_nat(a_hat) ==\n                        ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry +\n                        pow2( 51) * ((c1 as u64) % (pow2(51) as u64)) +\n                        pow2(102) * ((c2 as u64) % (pow2(51) as u64)) +\n                        pow2(153) * ((c3 as u64) % (pow2(51) as u64)) +\n                        pow2(204) * ((c4 as u64) % (pow2(51) as u64))\n                    ) by {\n                        l51_bit_mask_lt();\n\n                        assert((pow2(51) as u64) == (pow2(51) as u128));\n\n                        assert(a0_1 == ((c0_0 as u64) % (pow2(51) as u64)) + 19 * carry) by {\n                            lemma_u64_low_bits_mask_is_mod(c0_0 as u64, 51);\n                        }\n\n                        assert(a1_0 == (c1 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c1 as u64, 51);\n                        }\n\n                        assert(a2 == (c2 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c2 as u64, 51);\n                        }\n\n                        assert(a3 == (c3 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c3 as u64, 51);\n                        }\n\n                        assert(a4 == (c4 as u64) % (pow2(51) as u64)) by {\n                            lemma_u64_low_bits_mask_is_mod(c4 as u64, 51);\n                        }\n                    }\n\n                    // We can see all mod operations in u128\n                    assert(as_nat(a_hat) ==\n                        (c0_0 % (pow2(51) as u128)) + 19 * carry +\n                        pow2( 51) * (c1 % (pow2(51) as u128)) +\n                        pow2(102) * (c2 % (pow2(51) as u128)) +\n                        pow2(153) * (c3 % (pow2(51) as u128)) +\n                        pow2(204) * (c4 % (pow2(51) as u128))\n                    ) by {\n                        // pow2(51) is the same in u64 and 128\n                        lemma_cast_then_mod_51(c0_0);\n                        lemma_cast_then_mod_51(c1);\n                        lemma_cast_then_mod_51(c2);\n                        lemma_cast_then_mod_51(c3);\n                        lemma_cast_then_mod_51(c4);\n                    }\n\n                    // Next, we categorically replace a % s with a - s * ( a / s )\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c0_0 / (pow2(51) as u128))) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c1/ (pow2(51) as u128))) +\n                        pow2(102) * (c2 - pow2(51) * (c2/ (pow2(51) as u128))) +\n                        pow2(153) * (c3 - pow2(51) * (c3/ (pow2(51) as u128))) +\n                        pow2(204) * (c4 - pow2(51) * (c4/ (pow2(51) as u128)))\n                    ) by {\n                        lemma_fundamental_div_mod(c0_0 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c1 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c2 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c3 as int, pow2(51) as int);\n                        lemma_fundamental_div_mod(c4 as int, pow2(51) as int);\n                    }\n\n                    // Then, we know that\n                    // carry = c4/s\n                    // c4 = c4_0 + c3/s <=> c3/s = c4 - c4_0\n                    // c3 = c3_0 + c2/s <=> c2/s = c3 - c3_0\n                    // c2 = c2_0 + c1/s <=> c1/s = c2 - c2_0\n                    // c1 = c1_0 + c0_0/s <=> c0_0/s = c1 - c1_0\n                    assert(as_nat(a_hat) ==\n                        (c0_0 - pow2(51) * (c1 - c1_0)) + 19 * carry +\n                        pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) +\n                        pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) +\n                        pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) +\n                        pow2(204) * (c4 - pow2(51) * carry)\n                    ) by {\n                        lemma_u128_shr_is_div(c0_0, 51);\n                        lemma_u128_shr_is_div(c1, 51);\n                        lemma_u128_shr_is_div(c2, 51);\n                        lemma_u128_shr_is_div(c3, 51);\n                        lemma_u128_shr_is_div(c4, 51);\n                    }\n\n                    // Now we use distributivity and pow exponent sums, which cancels out any ci terms and leaves only ci_0 terms\n                    // Conveniently, we're left with a difference of c * p\n                    assert(as_nat(a_hat) ==\n                        c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0 -\n                        p() * carry\n                    ) by {\n                        assert(c0_0 - pow2(51) * (c1 - c1_0) == c0_0 - pow2(51) * c1 + pow2(51) * c1_0) by {\n                            lemma_mul_is_distributive_sub(pow2(51) as int, c1 as int, c1_0 as int);\n                        }\n\n                        assert(pow2( 51) * (c1 - pow2(51) * (c2 - c2_0)) == pow2( 51) * c1 - pow2(102) * c2 + pow2(102) * c2_0) by {\n                            lemma_mul_sub(c1 as int, c2 as int, c2_0 as int, 51);\n                        }\n\n                        assert(pow2(102) * (c2 - pow2(51) * (c3 - c3_0)) == pow2(102) * c2 - pow2(153) * c3 + pow2(153) * c3_0) by {\n                            lemma_mul_sub(c2 as int, c3 as int, c3_0 as int, 102);\n                        }\n\n                        assert(pow2(153) * (c3 - pow2(51) * (c4 - c4_0)) == pow2(153) * c3 - pow2(204) * c4 + pow2(204) * c4_0) by {\n                            lemma_mul_sub(c3 as int, c4 as int, c4_0 as int, 153);\n                        }\n\n                        assert(pow2(204) * (c4 - pow2(51) * carry) == pow2(204) * c4 - pow2(255) * carry) by {\n                            lemma_mul_is_distributive_sub(pow2(204) as int, c4 as int, pow2(51) * carry);\n                            lemma_mul_is_associative(pow2(204) as int, pow2(51) as int, carry as int);\n                            lemma_pow2_adds(204, 51);\n                        }\n\n                        // carry on the right, get p\n                        assert(\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 +\n                            19 * carry - pow2(255) * carry\n                            ==\n                            c0_0 +\n                            pow2(51) * c1_0 +\n                            pow2(102) * c2_0 +\n                            pow2(153) * c3_0 +\n                            pow2(204) * c4_0 -\n                            p() * carry\n                        ) by {\n                            pow255_gt_19();\n                            lemma_mul_is_distributive_sub_other_way(carry as int, pow2(255) as int, 19);\n                        }\n                    }\n\n                    let c_arr_as_nat = (c0_0 +\n                        pow2(51) * c1_0 +\n                        pow2(102) * c2_0 +\n                        pow2(153) * c3_0 +\n                        pow2(204) * c4_0\n                        );\n\n\n                    assert(as_nat(a_hat) % p() == c_arr_as_nat as nat % p()) by {\n                        lemma_mod_diff_factor(carry as int, c_arr_as_nat as int, p() as int);\n                    }\n\n                    // We use the as_nat_squared lemma to see what (as_nat(a)^2) evaluates to (mod p)\n\n                    // The nat_squared lemma gives us the following:\n                    // as_nat(a) * as_nat(a) ==\n                    // pow2(8 * 51) * (a[4] * a[4]) +\n                    // pow2(7 * 51) * (2 * (a[3] * a[4])) +\n                    // pow2(6 * 51) * (a[3] * a[3] + 2 * (a[2] * a[4])) +\n                    // pow2(5 * 51) * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])) +\n                    // pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    // pow2(3 * 51) * (2 * (a[1] * a[2]) + 2 * (a[0] * a[3])) +\n                    // pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] * a[2])) +\n                    // pow2(1 * 51) * (2 * (a[0] * a[1])) +\n                    //                (a[0] * a[0])\n                    //\n                    // AND\n                    //\n                    // (as_nat(a) * as_nat(a)) % p() ==\n                    // (\n                    //     pow2(4 * 51) * (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])) +\n                    //     pow2(3 * 51) * (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])) +\n                    //     pow2(2 * 51) * (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))) +\n                    //     pow2(1 * 51) * (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))) +\n                    //                    (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))\n                    // ) as nat % p()\n                    as_nat_squared(a);\n\n                    // We're basically done, what remains is to prove that the coefficients next to pow2(i * 51)\n                    // are exactly ci_0s (via distributivity and associativity)\n\n                    // let c0_0: u128 = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                    assert(c0_0 == (a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4])))) by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[0] *  a[0] + 2*( a[1] * a4_19 + a[2] * a3_19);\n                        //     = a[0] *  a[0] + 2*( a[1] * a4_19 ) + 2 * (a[2] * a3_19);\n                        // RHS = a[0] *  a[0] + 19 * (2 * (a[2] * a[3]) + 2 * (a[1] * a[4]))\n                        //     = a[0] *  a[0] + 19 * (2 * (a[2] * a[3])) + 19 * (2 * (a[1] * a[4]))\n\n                        // goals\n                        // 1) 2 * (a[1] * a4_19) = 19 * (2 * (a[1] * a[4]))\n                        // 2) 2 * (a[2] * a3_19) = 19 * (2 * (a[2] * a[3]))\n\n                        assert(2*(a[1] * a4_19) == 19 * (2 * (a[1] * a[4]))) by {\n                            lemma_reorder_mul(a[1] as int, a[4] as int);\n                        }\n\n                        assert(2*(a[2] * a3_19) == 19 * (2 * (a[2] * a[3]))) by {\n                            lemma_reorder_mul(a[2] as int, a[3] as int);\n                        }\n                    }\n\n                    // let c1_0: u128 = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19);\n                    assert(c1_0 == (2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[3] * a3_19 + 2*( a[0] *  a[1] + a[2] * a4_19)\n                        //     = a[3] * a3_19 + 2*( a[0] *  a[1]) + 2 * (a[2] * a4_19)\n                        // RHS = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3] + 2 * (a[2] * a[4]))\n                        //     = 2 * (a[0] *  a[1]) + 19 * (a[3] * a[3]) + 19 * (2 * (a[2] * a[4]))\n\n                        // goals: 1) a[3] * a3_19 = 19 * (a[3] * a[3])\n                        //        2) 2 * (a[2] * a4_19) = 19 * (2 * (a[2] * a[4]))\n\n                        assert(a[3] * a3_19 == 19 * (a[3] * a[3])) by {\n                            lemma_mul_is_associative(a[3] as int, a[3] as int, 19);\n                        }\n\n                        assert(2*(a[2] * a4_19) == 19 * (2 * (a[2] * a[4]))) by {\n                            lemma_reorder_mul(a[2] as int, a[4] as int);\n                        }\n                    }\n\n                    // let c2_0: u128 = a[1] *  a[1] + 2*( a[0] *  a[2] + a[4] * a3_19);\n                    assert(c2_0 == (a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[1] * a[1] + 2 * (a[0] *  a[2] + a[4] * a3_19)\n                        //     = a[1] * a[1] + 2 * (a[0] *  a[2]) +  2 * (a[4] * a3_19)\n                        // RHS = a[1] * a[1] + 2 * (a[0] *  a[2]) + 19 * (2 * (a[3] * a[4]))\n\n                        // goals: 2 * (a[4] * a3_19) = 19 * (2 * (a[3] * a[4]))\n\n                        assert(2 * (a[4] * a3_19) == 19 * (2 * (a[3] * a[4]))) by {\n                            lemma_mul_is_associative(a[4] as int, a[3] as int, 19);\n                        }\n                    }\n\n                    // let c3_0: u128 = a[4] * a4_19 + 2*( a[0] *  a[3] + a[1] *  a[2]);\n                    assert(c3_0 == (2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[4] * a4_19 + 2 * (a[0] *  a[3] + a[1] *  a[2])\n                        //     = a[4] * a4_19 + 2 * (a[0] *  a[3]) + 2 * (a[1] *  a[2])\n                        // RHS = 2 * (a[1] *  a[2]) + 2 * (a[0] *  a[3]) + 19 * (a[4] * a[4])\n\n                        // goals: a[4] * a4_19 = 19 * (a[4] * a[4])\n\n                        assert(a[4] * a4_19 == 19 * (a[4] * a[4])) by {\n                            lemma_mul_is_associative(a[4] as int, a[4] as int, 19);\n                        }\n                    }\n\n                    // let c4_0: u128 = a[2] *  a[2] + 2*( a[0] *  a[4] + a[1] *  a[3]);\n                    assert(c4_0 == (a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])))  by {\n                        // The solver does distributivity on its own.\n\n                        // LHS = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3])\n                        //     = a[2] * a[2] + 2 * (a[0] * a[4]) + 2 * (a[1] * a[3])\n                        // RHS = a[2] * a[2] + 2 * (a[1] * a[3]) + 2 * (a[0] * a[4])\n\n                        // goals: none\n                    }\n                }\n\n                let a_pow_2i_int = pow(as_nat(self.limbs) as int, pow2(i as nat));\n                assert(a_pow_2i_int >= 0) by {\n                    lemma_pow_nat_is_nat(as_nat(self.limbs), i as nat);\n                }\n                let a_pow_2i: nat = a_pow_2i_int as nat;\n\n                assert(as_nat(a_hat) % p() ==\n                    ((as_nat(a) % p()) * (as_nat(a) % p())) % p()\n                ) by {\n                    lemma_mul_mod_noop(as_nat(a) as int, as_nat(a) as int, p() as int);\n                }\n\n                // (a_pow_2i % p)^2 % p = (a_pow_2i^2) % p\n                lemma_mul_mod_noop(a_pow_2i as int, a_pow_2i as int, p() as int);\n\n                // We know, by the loop inv, that\n                // as_nat(a) % p == a_pow_2i % p\n                // and, by the above\n                // as_nat(a_hat) % p  = (as_nat(a) * as_nat(a)) % p = (a_pow_2i ^ 2)) % p\n                // It suffices to prove that\n                // (v^(2^i))^2 = v^(2^(i + 1))\n                lemma_pow2_square(as_nat(self.limbs) as int, i as nat);\n            }\n            // Precondition: assume input limbs a[i] are bounded as\n            //\n            // a[i] < 2^(51 + b)\n            //\n            // where b is a real parameter measuring the \"bit excess\" of the limbs.\n\n            // Precomputation: 64-bit multiply by 19.\n            //\n            // This fits into a u64 whenever 51 + b + lg(19) < 64.\n            //\n            // Since 51 + b + lg(19) < 51 + 4.25 + b\n            //                       = 55.25 + b,\n            // this fits if b < 8.75.\n            let a3_19 = 19 * a[3];\n            let a4_19 = 19 * a[4];\n\n            // Multiply to get 128-bit coefficients of output.\n            //\n            // The 128-bit multiplications by 2 turn into 1 slr + 1 slrd each,\n            // which doesn't seem any better or worse than doing them as precomputations\n            // on the 64-bit inputs.\n            let     c0: u128 = m(a[0],  a[0]) + 2*( m(a[1], a4_19) + m(a[2], a3_19) );\n            let mut c1: u128 = m(a[3], a3_19) + 2*( m(a[0],  a[1]) + m(a[2], a4_19) );\n            let mut c2: u128 = m(a[1],  a[1]) + 2*( m(a[0],  a[2]) + m(a[4], a3_19) );\n            let mut c3: u128 = m(a[4], a4_19) + 2*( m(a[0],  a[3]) + m(a[1],  a[2]) );\n            let mut c4: u128 = m(a[2],  a[2]) + 2*( m(a[0],  a[4]) + m(a[1],  a[3]) );\n\n            // Same bound as in multiply:\n            //    c[i] < 2^(102 + 2*b) * (1+i + (4-i)*19)\n            //         < 2^(102 + lg(1 + 4*19) + 2*b)\n            //         < 2^(108.27 + 2*b)\n            //\n            // The carry (c[i] >> 51) fits into a u64 when\n            //    108.27 + 2*b - 51 < 64\n            //    2*b < 6.73\n            //    b < 3.365.\n            //\n            // So we require b < 3 to ensure this fits.\n            // DISABLED DUE TO NO VERUS SUPPORT FOR PANICS\n            // debug_assert!(a[0] < (1 << 54));\n            // debug_assert!(a[1] < (1 << 54));\n            // debug_assert!(a[2] < (1 << 54));\n            // debug_assert!(a[3] < (1 << 54));\n            // debug_assert!(a[4] < (1 << 54));\n\n            // const LOW_51_BIT_MASK: u64 = (1u64 << 51) - 1; // already defined\n\n            // Casting to u64 and back tells the compiler that the carry is bounded by 2^64, so\n            // that the addition is a u128 + u64 rather than u128 + u128.\n            c1 += ((c0 >> 51) as u64) as u128;\n            a[0] = (c0 as u64) & LOW_51_BIT_MASK;\n\n            c2 += ((c1 >> 51) as u64) as u128;\n            a[1] = (c1 as u64) & LOW_51_BIT_MASK;\n\n            c3 += ((c2 >> 51) as u64) as u128;\n            a[2] = (c2 as u64) & LOW_51_BIT_MASK;\n\n            c4 += ((c3 >> 51) as u64) as u128;\n            a[3] = (c3 as u64) & LOW_51_BIT_MASK;\n\n            let carry: u64 = (c4 >> 51) as u64;\n            a[4] = (c4 as u64) & LOW_51_BIT_MASK;\n\n            // To see that this does not overflow, we need a[0] + carry * 19 < 2^64.\n            //\n            // c4 < a2^2 + 2*a0*a4 + 2*a1*a3 + (carry from c3)\n            //    < 2^(102 + 2*b + lg(5)) + 2^64.\n            //\n            // When b < 3 we get\n            //\n            // c4 < 2^110.33  so that carry < 2^59.33\n            //\n            // so that\n            //\n            // a[0] + carry * 19 < 2^51 + 19 * 2^59.33 < 2^63.58\n            //\n            // and there is no overflow.\n            a[0] += carry * 19;\n\n            // Now a[1] < 2^51 + 2^(64 -51) = 2^51 + 2^13 < 2^(51 + epsilon).\n            a[1] += a[0] >> 51;\n            a[0] &= LOW_51_BIT_MASK;\n\n            // Now all a[i] < 2^(51 + epsilon) and a = self^(2^k).\n        }\n\n        // ADAPTED CODE LINE: limbs is now a named field\n        FieldElement51{limbs: a}\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/square2",
                            "content": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p()\n    {\n        let mut square = self.pow2k(1);\n\n        // invisible to Rust, can be referenced in proofs\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall |i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() ==\n                ((2nat % p()) * (as_nat(square.limbs) % p())) % p()\n                ==\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n            ) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n                ==\n                (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p()\n            ) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall |j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall |j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall |j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/as_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/p",
                              "/curve25519-dalek/src/backend/serial/u64/field_verus.rs/pow2k",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/pow255_gt_19",
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/pow_lemmas.rs/lemma_pow_nat_is_nat",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/as_nat_lemmas.rs/as_nat_k"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "    pub fn square2(&self) -> (r: FieldElement51)\n        requires\n            // The precondition in pow2k loop propagates to here\n            forall |i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54\n        ensures\n            as_nat(r.limbs) % p() == (2 * pow(as_nat(self.limbs) as int, 2)) as nat % p()\n    {\n        let mut square = self.pow2k(1);\n\n        // invisible to Rust, can be referenced in proofs\n        // Since square is mut, we save the initial value\n        let ghost old_limbs = square.limbs;\n\n        proof {\n            // forall |i: int| 0 <= i < 5 ==> 2 * old_limbs[i] <= u64::MAX\n            assert forall |i: int| 0 <= i < 5 implies 2 * square.limbs[i] <= u64::MAX by {\n                // if LHS < RHS, then 2 * LHS < 2 * RHS\n                lemma_mul_left_inequality(2, square.limbs[i] as int, (1u64 << 54) as int);\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n            }\n\n            let ka = [\n                (2 * square.limbs[0]) as u64,\n                (2 * square.limbs[1]) as u64,\n                (2 * square.limbs[2]) as u64,\n                (2 * square.limbs[3]) as u64,\n                (2 * square.limbs[4]) as u64\n            ];\n\n            // as_nat(ka) == 2 * as_nat(square.limbs)\n            // and\n            // as_nat(ka) % p() == (2 * as_nat(square.limbs)) % p()\n            as_nat_k(square.limbs, 2);\n\n            // By pow2k ensures:\n            // as_nat(square.limbs) % p() == pow(as_nat(self.limbs) as int, pow2(1)) as nat % p()\n            // We just need pow2(1) == 2\n            lemma2_to64();\n\n            // p > 0\n            pow255_gt_19();\n\n            assert(as_nat(ka) % p() ==\n                ((2nat % p()) * (as_nat(square.limbs) % p())) % p()\n                ==\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n            ) by {\n                lemma_mul_mod_noop(2, as_nat(square.limbs) as int, p() as int);\n            }\n\n            // as_nat(self.limbs)^2 >= 0\n            assert(pow(as_nat(self.limbs) as int, 2) >= 0) by {\n                lemma_pow_nat_is_nat(as_nat(self.limbs), 1);\n            }\n\n            assert(\n                ((2nat % p()) * (pow(as_nat(self.limbs) as int, 2) as nat % p())) % p()\n                ==\n                (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p()\n            ) by {\n                lemma_mul_mod_noop(2, pow(as_nat(self.limbs) as int, 2) as int, p() as int);\n            }\n\n            assert(as_nat(ka) % p() == (2 * (pow(as_nat(self.limbs) as int, 2))) as nat % p());\n        }\n\n        for i in 0..5\n            invariant\n                forall |j: int| 0 <= j < 5 ==> old_limbs[j] < (1u64 << 54),\n                forall |j: int| 0 <= j < i ==> #[trigger] square.limbs[j] == 2 * old_limbs[j],\n                forall |j: int| i <= j < 5 ==> #[trigger] square.limbs[j] == old_limbs[j],\n        {\n            proof {\n                assert(2 * (1u64 << 54) <= u64::MAX) by (compute);\n                lemma_mul_strict_inequality(square.limbs[i as int] as int, (1u64 << 54) as int, 2);\n            }\n\n            square.limbs[i] *= 2;\n        }\n\n        square\n    }",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/load8_at",
                            "content": "const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i)\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n        (input[i] as u64)\n    | ((input[i + 1] as u64) << 8)\n    | ((input[i + 2] as u64) << 16)\n    | ((input[i + 3] as u64) << 24)\n    | ((input[i + 4] as u64) << 32)\n    | ((input[i + 5] as u64) << 40)\n    | ((input[i + 6] as u64) << 48)\n    | ((input[i + 7] as u64) << 56)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/load8_at_versions_equivalent",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/field_core.rs/load8_at_spec",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/plus_version_is_spec",
                              "/curve25519-dalek/src/backend/serial/u64/field_lemmas/load8_lemmas.rs/rec_version_is_exec"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == load8_at_spec(input, i)\n{\n    proof {\n        rec_version_is_exec(input, i);\n        load8_at_versions_equivalent(input, i, 7);\n        plus_version_is_spec(input, i);\n    }\n        (input[i] as u64)\n    | ((input[i + 1] as u64) << 8)\n    | ((input[i + 2] as u64) << 16)\n    | ((input[i + 3] as u64) << 24)\n    | ((input[i + 4] as u64) << 32)\n    | ((input[i + 5] as u64) << 40)\n    | ((input[i + 6] as u64) << 48)\n    | ((input[i + 7] as u64) << 56)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          },
                          {
                            "identifier": "curve25519-dalek/src/backend/serial/u64/field_verus.rs/m",
                            "content": "fn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX\n\n{\n    proof {\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
                            "dependencies": [
                              "/curve25519-dalek/src/backend/serial/u64/common_verus/mul_lemmas.rs/mul_le"
                            ],
                            "code_name": "pow2_51_lemmas.rs",
                            "children": [],
                            "file_type": "file",
                            "status_id": 3,
                            "snippets": [
                              {
                                "sortorder": 0,
                                "text": "fn m(x: u64, y: u64) -> (r: u128)\n    ensures\n        (r as nat) == (x as nat) * (y as nat),\n        r <= u128::MAX\n\n{\n    proof {\n        mul_le(x as nat, u64::MAX as nat, y as nat, u64::MAX as nat);\n    }\n    (x as u128) * (y as u128)\n}",
                                "type_id": 2
                              }
                            ],
                            "specified": true
                          }
                        ],
                        "file_type": "folder",
                        "specified": false
                      }
                    ],
                    "file_type": "folder",
                    "specified": false
                  }
                ],
                "file_type": "folder",
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/backend/mod.rs",
                "content": "",
                "code_name": "",
                "children": [
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/vartime_double_base_mul",
                    "content": "pub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        // }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs/mul",
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "pub fn vartime_double_base_mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::vartime_double_base::spec_avx2::mul(a, A, b),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::vartime_double_base::spec_avx512ifma_avx512vl::mul(a, A, b)\n        // }\n        BackendKind::Serial => serial::scalar_mul::vartime_double_base::mul(a, A, b),\n    }\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/pippenger_optional_multiscalar_mul",
                    "content": "pub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 =>\n        //     vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 =>\n        //     vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial => {\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n    }\n}",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend",
                      "/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs/optional_multiscalar_mul"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "pub fn pippenger_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 =>\n        //     vector::scalar_mul::pippenger::spec_avx2::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 =>\n        //     vector::scalar_mul::pippenger::spec_avx512ifma_avx512vl::Pippenger::optional_multiscalar_mul::<I, J>(scalars, points),\n        BackendKind::Serial => {\n            serial::scalar_mul::pippenger::Pippenger::optional_multiscalar_mul::<I, J>(\n                scalars, points,\n            )\n        }\n    }\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/variable_base_mul",
                    "content": "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        // }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs/mul",
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "pub fn variable_base_mul(point: &EdwardsPoint, scalar: &Scalar) -> EdwardsPoint {\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => vector::scalar_mul::variable_base::spec_avx2::mul(point, scalar),\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::variable_base::spec_avx512ifma_avx512vl::mul(point, scalar)\n        // }\n        BackendKind::Serial => serial::scalar_mul::variable_base::mul(point, scalar),\n    }\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/straus_optional_multiscalar_mul",
                    "content": "pub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n        //         I,\n        //         J,\n        //     >(scalars, points)\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend",
                      "/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs/optional_multiscalar_mul"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "pub fn straus_optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator<Item = Option<EdwardsPoint>>,\n{\n    use crate::traits::VartimeMultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::optional_multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::optional_multiscalar_mul::<\n        //         I,\n        //         J,\n        //     >(scalars, points)\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::optional_multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/new",
                    "content": "    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // BackendKind::Avx2 =>\n            //     VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // BackendKind::Avx512 =>\n            //     VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial => VartimePrecomputedStraus::Scalar(\n                serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(\n                    static_points,\n                ),\n            ),\n        }\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend",
                      "/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/new"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<EdwardsPoint>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match get_selected_backend() {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // BackendKind::Avx2 =>\n            //     VartimePrecomputedStraus::Avx2(vector::scalar_mul::precomputed_straus::spec_avx2::VartimePrecomputedStraus::new(static_points)),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // BackendKind::Avx512 =>\n            //     VartimePrecomputedStraus::Avx512ifma(vector::scalar_mul::precomputed_straus::spec_avx512ifma_avx512vl::VartimePrecomputedStraus::new(static_points)),\n            BackendKind::Serial => VartimePrecomputedStraus::Scalar(\n                serial::scalar_mul::precomputed_straus::VartimePrecomputedStraus::new(\n                    static_points,\n                ),\n            ),\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/is_empty",
                    "content": "    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/is_empty"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn is_empty(&self) -> bool {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.is_empty(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.is_empty(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.is_empty(),\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/optional_mixed_multiscalar_mul",
                    "content": "    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/optional_mixed_multiscalar_mul"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: core::borrow::Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: core::borrow::Borrow<Scalar>,\n        K: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.optional_mixed_multiscalar_mul(\n            //     static_scalars,\n            //     dynamic_scalars,\n            //     dynamic_points,\n            // ),\n            VartimePrecomputedStraus::Scalar(inner) => inner.optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points,\n            ),\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/get_selected_backend",
                    "content": "fn get_selected_backend() -> BackendKind {\n    // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n\n    BackendKind::Serial\n}",
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "fn get_selected_backend() -> BackendKind {\n    // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n    // {\n    //     cpufeatures::new!(cpuid_avx512, \"avx512ifma\", \"avx512vl\");\n    //     let token_avx512: cpuid_avx512::InitToken = cpuid_avx512::init();\n    //     if token_avx512.get() {\n    //         return BackendKind::Avx512;\n    //     }\n    // }\n\n    // #[cfg(curve25519_dalek_backend = \"simd\")]\n    // {\n    //     cpufeatures::new!(cpuid_avx2, \"avx2\");\n    //     let token_avx2: cpuid_avx2::InitToken = cpuid_avx2::init();\n    //     if token_avx2.get() {\n    //         return BackendKind::Avx2;\n    //     }\n    // }\n\n    BackendKind::Serial\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/len",
                    "content": "    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/serial/scalar_mul/precomputed_straus.rs/len"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "    pub fn len(&self) -> usize {\n        use crate::traits::VartimePrecomputedMultiscalarMul;\n\n        match self {\n            // #[cfg(curve25519_dalek_backend = \"simd\")]\n            // VartimePrecomputedStraus::Avx2(inner) => inner.len(),\n            // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n            // VartimePrecomputedStraus::Avx512ifma(inner) => inner.len(),\n            VartimePrecomputedStraus::Scalar(inner) => inner.len(),\n        }\n    }",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  },
                  {
                    "identifier": "curve25519-dalek/src/backend/mod.rs/straus_multiscalar_mul",
                    "content": "pub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
                    "dependencies": [
                      "/curve25519-dalek/src/backend/mod.rs/get_selected_backend",
                      "/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs/multiscalar_mul"
                    ],
                    "code_name": "CHANGELOG.md",
                    "children": [],
                    "file_type": "file",
                    "status_id": 3,
                    "snippets": [
                      {
                        "sortorder": 0,
                        "text": "pub fn straus_multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\nwhere\n    I: IntoIterator,\n    I::Item: core::borrow::Borrow<Scalar>,\n    J: IntoIterator,\n    J::Item: core::borrow::Borrow<EdwardsPoint>,\n{\n    use crate::traits::MultiscalarMul;\n\n    match get_selected_backend() {\n        // #[cfg(curve25519_dalek_backend = \"simd\")]\n        // BackendKind::Avx2 => {\n        //     vector::scalar_mul::straus::spec_avx2::Straus::multiscalar_mul::<I, J>(scalars, points)\n        // }\n        // #[cfg(all(curve25519_dalek_backend = \"unstable_avx512\", nightly))]\n        // BackendKind::Avx512 => {\n        //     vector::scalar_mul::straus::spec_avx512ifma_avx512vl::Straus::multiscalar_mul::<I, J>(\n        //         scalars, points,\n        //     )\n        // }\n        BackendKind::Serial => {\n            serial::scalar_mul::straus::Straus::multiscalar_mul::<I, J>(scalars, points)\n        }\n    }\n}",
                        "type_id": 2
                      }
                    ],
                    "specified": false
                  }
                ],
                "file_type": "folder",
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/ristretto.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/optional_mixed_multiscalar_mul",
                "content": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/optional_mixed_multiscalar_mul"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(\n                static_scalars,\n                dynamic_scalars,\n                dynamic_points.into_iter().map(|P_opt| P_opt.map(|P| P.0)),\n            )\n            .map(RistrettoPoint)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/vartime_double_scalar_mul_basepoint",
                "content": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/vartime_double_scalar_mul_basepoint"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &RistrettoPoint,\n        b: &Scalar,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::vartime_double_scalar_mul_basepoint(\n            a, &A.0, b,\n        ))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/optional_multiscalar_mul",
                "content": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/optional_multiscalar_mul"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<RistrettoPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<RistrettoPoint>>,\n    {\n        let extended_points = points.into_iter().map(|opt_P| opt_P.map(|P| P.0));\n\n        EdwardsPoint::optional_multiscalar_mul(scalars, extended_points).map(RistrettoPoint)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/basepoint",
                "content": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn basepoint(&self) -> RistrettoPoint {\n        RistrettoPoint(self.0.basepoint())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/new",
                "content": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/new"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(\n            static_points.into_iter().map(|P| P.borrow().0),\n        ))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/eq",
                "content": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/ct_eq"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &RistrettoPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/sub",
                "content": "    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 - other.0)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/sub_assign",
                "content": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) - _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/is_empty",
                "content": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/is_empty"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/try_from_rng",
                "content": "    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/from_uniform_bytes"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn try_from_rng<R: TryCryptoRng + ?Sized>(rng: &mut R) -> Result<Self, R::Error> {\n        let mut uniform_bytes = [0u8; 64];\n        rng.try_fill_bytes(&mut uniform_bytes)?;\n\n        Ok(RistrettoPoint::from_uniform_bytes(&uniform_bytes))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/add",
                "content": "    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add(self, other: &'a RistrettoPoint) -> RistrettoPoint {\n        RistrettoPoint(self.0 + other.0)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/from",
                "content": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/is_negative",
                  "/curve25519-dalek/src/ristretto.rs/efgh",
                  "/curve25519-dalek/src/field.rs/batch_invert",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/create",
                "content": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn create(basepoint: &RistrettoPoint) -> RistrettoBasepointTable {\n        RistrettoBasepointTable(EdwardsBasepointTable::create(&basepoint.0))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedRistretto: {:?}\", self.as_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/multiscalar_mul",
                "content": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/multiscalar_mul"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> RistrettoPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<RistrettoPoint>,\n    {\n        let extended_points = points.into_iter().map(|P| P.borrow().0);\n        RistrettoPoint(EdwardsPoint::multiscalar_mul(scalars, extended_points))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/identity",
                "content": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> CompressedRistretto {\n        CompressedRistretto([0u8; 32])\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/conditional_select",
                "content": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/conditional_select"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn conditional_select(\n        a: &RistrettoPoint,\n        b: &RistrettoPoint,\n        choice: Choice,\n    ) -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::conditional_select(&a.0, &b.0, choice))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/coset4",
                  "/curve25519-dalek/src/ristretto.rs/step_2",
                  "/curve25519-dalek/src/ristretto.rs/step_1"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let coset = self.coset4();\n        write!(\n            f,\n            \"RistrettoPoint: coset \\n{:?}\\n{:?}\\n{:?}\\n{:?}\",\n            coset[0], coset[1], coset[2], coset[3]\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/double_and_compress_batch",
                "content": "    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn double_and_compress_batch<'a, I>(points: I) -> Vec<CompressedRistretto>\n    where\n        I: IntoIterator<Item = &'a RistrettoPoint>,\n    {\n        #[derive(Copy, Clone, Debug)]\n        struct BatchCompressState {\n            e: FieldElement,\n            f: FieldElement,\n            g: FieldElement,\n            h: FieldElement,\n            eg: FieldElement,\n            fh: FieldElement,\n        }\n\n        impl BatchCompressState {\n            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }\n        }\n\n        impl<'a> From<&'a RistrettoPoint> for BatchCompressState {\n            #[rustfmt::skip] // keep alignment of explanatory comments\n            fn from(P: &'a RistrettoPoint) -> BatchCompressState {\n                let XX = P.0.X.square();\n                let YY = P.0.Y.square();\n                let ZZ = P.0.Z.square();\n                let dTT = &P.0.T.square() * &constants::EDWARDS_D;\n\n                let e = &P.0.X * &(&P.0.Y + &P.0.Y); // = 2*X*Y\n                let f = &ZZ + &dTT;                  // = Z^2 + d*T^2\n                let g = &YY + &XX;                   // = Y^2 - a*X^2\n                let h = &ZZ - &dTT;                  // = Z^2 - d*T^2\n\n                let eg = &e * &g;\n                let fh = &f * &h;\n\n                BatchCompressState{ e, f, g, h, eg, fh }\n            }\n        }\n\n        let states: Vec<BatchCompressState> =\n            points.into_iter().map(BatchCompressState::from).collect();\n\n        let mut invs: Vec<FieldElement> = states.iter().map(|state| state.efgh()).collect();\n\n        FieldElement::batch_invert(&mut invs[..]);\n\n        states\n            .iter()\n            .zip(invs.iter())\n            .map(|(state, inv): (&BatchCompressState, &FieldElement)| {\n                let Zinv = &state.eg * inv;\n                let Tinv = &state.fh * inv;\n\n                let mut magic = constants::INVSQRT_A_MINUS_D;\n\n                let negcheck1 = (&state.eg * &Zinv).is_negative();\n\n                let mut e = state.e;\n                let mut g = state.g;\n                let mut h = state.h;\n\n                let minus_e = -&e;\n                let f_times_sqrta = &state.f * &constants::SQRT_M1;\n\n                e.conditional_assign(&state.g, negcheck1);\n                g.conditional_assign(&minus_e, negcheck1);\n                h.conditional_assign(&f_times_sqrta, negcheck1);\n\n                magic.conditional_assign(&constants::SQRT_M1, negcheck1);\n\n                let negcheck2 = (&(&h * &e) * &Zinv).is_negative();\n\n                g.conditional_negate(negcheck2);\n\n                let mut s = &(&h - &g) * &(&magic * &(&g * &Tinv));\n\n                let s_is_negative = s.is_negative();\n                s.conditional_negate(s_is_negative);\n\n                CompressedRistretto(s.to_bytes())\n            })\n            .collect()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/elligator_ristretto_flavor",
                "content": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                  "/curve25519-dalek/src/field.rs/sqrt_ratio_i",
                  "/curve25519-dalek/src/field.rs/is_negative",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> RistrettoPoint {\n        let i = &constants::SQRT_M1;\n        let d = &constants::EDWARDS_D;\n        let one_minus_d_sq = &constants::ONE_MINUS_EDWARDS_D_SQUARED;\n        let d_minus_one_sq = &constants::EDWARDS_D_MINUS_ONE_SQUARED;\n        let mut c = constants::MINUS_ONE;\n\n        let one = FieldElement::ONE;\n\n        let r = i * &r_0.square();\n        let N_s = &(&r + &one) * one_minus_d_sq;\n        let D = &(&c - &(d * &r)) * &(&r + d);\n\n        let (Ns_D_is_sq, mut s) = FieldElement::sqrt_ratio_i(&N_s, &D);\n        let mut s_prime = &s * r_0;\n        let s_prime_is_pos = !s_prime.is_negative();\n        s_prime.conditional_negate(s_prime_is_pos);\n\n        s.conditional_assign(&s_prime, !Ns_D_is_sq);\n        c.conditional_assign(&r, !Ns_D_is_sq);\n\n        let N_t = &(&(&c * &(&r - &one)) * d_minus_one_sq) - &D;\n        let s_sq = s.square();\n\n        use crate::backend::serial::curve_models::CompletedPoint;\n\n        // The conversion from W_i is exactly the conversion from P1xP1.\n        RistrettoPoint(\n            CompletedPoint {\n                X: &(&s + &s) * &D,\n                Z: &N_t * &constants::SQRT_AD_MINUS_ONE,\n                Y: &FieldElement::ONE - &s_sq,\n                T: &FieldElement::ONE + &s_sq,\n            }\n            .as_extended(),\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/default",
                "content": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/identity"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> RistrettoPoint {\n        RistrettoPoint::identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/sum",
                "content": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/identity"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(RistrettoPoint::identity(), |acc, item| acc + item.borrow())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/random",
                "content": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/try_from_rng"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        Self::try_from_rng(rng)\n            .map_err(|_: Infallible| {})\n            .expect(\"[bug] unfallible rng failed\")\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/as_bytes",
                "content": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/from_uniform_bytes",
                "content": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/ristretto.rs/elligator_ristretto_flavor"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_uniform_bytes(bytes: &[u8; 64]) -> RistrettoPoint {\n        // This follows the one-way map construction from the Ristretto RFC:\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4\n        let mut r_1_bytes = [0u8; 32];\n        r_1_bytes.copy_from_slice(&bytes[0..32]);\n        let r_1 = FieldElement::from_bytes(&r_1_bytes);\n        let R_1 = RistrettoPoint::elligator_ristretto_flavor(&r_1);\n\n        let mut r_2_bytes = [0u8; 32];\n        r_2_bytes.copy_from_slice(&bytes[32..64]);\n        let r_2 = FieldElement::from_bytes(&r_2_bytes);\n        let R_2 = RistrettoPoint::elligator_ristretto_flavor(&r_2);\n\n        // Applying Elligator twice and adding the results ensures a\n        // uniform distribution.\n        R_1 + R_2\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/default",
                "content": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/identity"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> CompressedRistretto {\n        CompressedRistretto::identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/try_from",
                "content": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/from_slice"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn try_from(slice: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/as_bytes"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &CompressedRistretto) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/from_slice",
                "content": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedRistretto, TryFromSliceError> {\n        bytes.try_into().map(CompressedRistretto)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/eq",
                "content": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/ct_eq"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/mul_assign",
                "content": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &RistrettoPoint) * scalar;\n        *self = result;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/neg",
                "content": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> RistrettoPoint {\n        -&self\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/mul_base",
                "content": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::RISTRETTO_BASEPOINT_TABLE\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/compress",
                "content": "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign",
                  "/curve25519-dalek/src/field.rs/is_negative",
                  "/curve25519-dalek/src/field.rs/invsqrt",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn compress(&self) -> CompressedRistretto {\n        let mut X = self.0.X;\n        let mut Y = self.0.Y;\n        let Z = &self.0.Z;\n        let T = &self.0.T;\n\n        let u1 = &(Z + &Y) * &(Z - &Y);\n        let u2 = &X * &Y;\n        // Ignore return value since this is always square\n        let (_, invsqrt) = (&u1 * &u2.square()).invsqrt();\n        let i1 = &invsqrt * &u1;\n        let i2 = &invsqrt * &u2;\n        let z_inv = &i1 * &(&i2 * T);\n        let mut den_inv = i2;\n\n        let iX = &X * &constants::SQRT_M1;\n        let iY = &Y * &constants::SQRT_M1;\n        let ristretto_magic = &constants::INVSQRT_A_MINUS_D;\n        let enchanted_denominator = &i1 * ristretto_magic;\n\n        let rotate = (T * &z_inv).is_negative();\n\n        X.conditional_assign(&iY, rotate);\n        Y.conditional_assign(&iX, rotate);\n        den_inv.conditional_assign(&enchanted_denominator, rotate);\n\n        Y.conditional_negate((&X * &z_inv).is_negative());\n\n        let mut s = &den_inv * &(Z - &Y);\n        let s_is_negative = s.is_negative();\n        s.conditional_negate(s_is_negative);\n\n        CompressedRistretto(s.to_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/mul",
                "content": "    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul(self, scalar: &'a Scalar) -> RistrettoPoint {\n        RistrettoPoint(self.0 * scalar)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/decompress",
                "content": "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/ristretto.rs/step_1",
                  "/curve25519-dalek/src/ristretto.rs/step_2"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn decompress(&self) -> Option<RistrettoPoint> {\n        let (s_encoding_is_canonical, s_is_negative, s) = decompress::step_1(self);\n\n        if (!s_encoding_is_canonical | s_is_negative).into() {\n            return None;\n        }\n\n        let (ok, t_is_negative, y_is_zero, res) = decompress::step_2(s);\n\n        if (!ok | t_is_negative | y_is_zero).into() {\n            None\n        } else {\n            Some(res)\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/step_1",
                "content": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/field.rs/is_negative",
                  "/curve25519-dalek/src/ristretto.rs/as_bytes",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(super) fn step_1(repr: &CompressedRistretto) -> (Choice, Choice, FieldElement) {\n        // Step 1. Check s for validity:\n        // 1.a) s must be 32 bytes (we get this from the type system)\n        // 1.b) s < p\n        // 1.c) s is nonnegative\n        //\n        // Our decoding routine ignores the high bit, so the only\n        // possible failure for 1.b) is if someone encodes s in 0..18\n        // as s+p in 2^255-19..2^255-1.  We can check this by\n        // converting back to bytes, and checking that we get the\n        // original input, since our encoding routine is canonical.\n\n        let s = FieldElement::from_bytes(repr.as_bytes());\n        let s_bytes_check = s.to_bytes();\n        let s_encoding_is_canonical = s_bytes_check[..].ct_eq(repr.as_bytes());\n        let s_is_negative = s.is_negative();\n\n        (s_encoding_is_canonical, s_is_negative, s)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/neg",
                "content": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> RistrettoPoint {\n        RistrettoPoint(-&self.0)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/ct_eq"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &RistrettoPoint) -> Choice {\n        let X1Y2 = &self.0.X * &other.0.Y;\n        let Y1X2 = &self.0.Y * &other.0.X;\n        let X1X2 = &self.0.X * &other.0.X;\n        let Y1Y2 = &self.0.Y * &other.0.Y;\n\n        X1Y2.ct_eq(&Y1X2) | X1X2.ct_eq(&Y1Y2)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/identity",
                "content": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/identity"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> RistrettoPoint {\n        RistrettoPoint(EdwardsPoint::identity())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/step_2",
                "content": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/field.rs/is_zero",
                  "/curve25519-dalek/src/field.rs/invsqrt",
                  "/curve25519-dalek/src/field.rs/is_negative"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(super) fn step_2(s: FieldElement) -> (Choice, Choice, Choice, RistrettoPoint) {\n        // Step 2.  Compute (X:Y:Z:T).\n        let one = FieldElement::ONE;\n        let ss = s.square();\n        let u1 = &one - &ss; //  1 + as²\n        let u2 = &one + &ss; //  1 - as²    where a=-1\n        let u2_sqr = u2.square(); // (1 - as²)²\n\n        // v == ad(1+as²)² - (1-as²)²            where d=-121665/121666\n        let v = &(&(-&constants::EDWARDS_D) * &u1.square()) - &u2_sqr;\n\n        let (ok, I) = (&v * &u2_sqr).invsqrt(); // 1/sqrt(v*u_2²)\n\n        let Dx = &I * &u2; // 1/sqrt(v)\n        let Dy = &I * &(&Dx * &v); // 1/u2\n\n        // x == | 2s/sqrt(v) | == + sqrt(4s²/(ad(1+as²)² - (1-as²)²))\n        let mut x = &(&s + &s) * &Dx;\n        let x_neg = x.is_negative();\n        x.conditional_negate(x_neg);\n\n        // y == (1-as²)/(1+as²)\n        let y = &u1 * &Dy;\n\n        // t == ((1+as²) sqrt(4s²/(ad(1+as²)² - (1-as²)²)))/(1-as²)\n        let t = &x * &y;\n\n        (\n            ok,\n            t.is_negative(),\n            y.is_zero(),\n            RistrettoPoint(EdwardsPoint {\n                X: x,\n                Y: y,\n                Z: one,\n                T: t,\n            }),\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/efgh",
                "content": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "            fn efgh(&self) -> FieldElement {\n                &self.eg * &self.fh\n            }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/add_assign",
                "content": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add_assign(&mut self, _rhs: &RistrettoPoint) {\n        *self = (self as &RistrettoPoint) + _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/len",
                "content": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/len"
                ],
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/to_bytes",
                "content": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/ristretto.rs/coset4",
                "content": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
                "code_name": "edwards.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn coset4(&self) -> [EdwardsPoint; 4] {\n        [\n            self.0,\n            self.0 + constants::EIGHT_TORSION[2],\n            self.0 + constants::EIGHT_TORSION[4],\n            self.0 + constants::EIGHT_TORSION[6],\n        ]\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/scalar.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/scalar.rs/bits_le",
                "content": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n        (0..256).map(|i| {\n            // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n            // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n            // little-endian on the bit level\n            ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n        })\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/non_adjacent_form",
                "content": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/read_le_u64_into"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn non_adjacent_form(&self, w: usize) -> [i8; 256] {\n        // required by the NAF definition\n        debug_assert!(w >= 2);\n        // required so that the NAF digits fit in i8\n        debug_assert!(w <= 8);\n\n        let mut naf = [0i8; 256];\n\n        let mut x_u64 = [0u64; 5];\n        read_le_u64_into(&self.bytes, &mut x_u64[0..4]);\n\n        let width = 1 << w;\n        let window_mask = width - 1;\n\n        let mut pos = 0;\n        let mut carry = 0;\n        while pos < 256 {\n            // Construct a buffer of bits of the scalar, starting at bit `pos`\n            let u64_idx = pos / 64;\n            let bit_idx = pos % 64;\n            let bit_buf: u64 = if bit_idx < 64 - w {\n                // This window's bits are contained in a single u64\n                x_u64[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (x_u64[u64_idx] >> bit_idx) | (x_u64[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Add the carry into the current window\n            let window = carry + (bit_buf & window_mask);\n\n            if window & 1 == 0 {\n                // If the window value is even, preserve the carry and continue.\n                // Why is the carry preserved?\n                // If carry == 0 and window & 1 == 0, then the next carry should be 0\n                // If carry == 1 and window & 1 == 0, then bit_buf & 1 == 1 so the next carry should be 1\n                pos += 1;\n                continue;\n            }\n\n            if window < width / 2 {\n                carry = 0;\n                naf[pos] = window as i8;\n            } else {\n                carry = 1;\n                naf[pos] = (window as i8).wrapping_sub(width as i8);\n            }\n\n            pos += w;\n        }\n\n        naf\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/add_assign",
                "content": "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self + _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/product",
                "content": "    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn product<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ONE, |acc, item| acc * item.borrow())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/add",
                "content": "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/add",
                  "/curve25519-dalek/src/scalar.rs/unpack",
                  "/curve25519-dalek/src/scalar.rs/pack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add(self, _rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::add function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::add(&self.unpack(), &_rhs.unpack()).pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &Self) -> Choice {\n        self.bytes.ct_eq(&other.bytes)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/mul",
                "content": "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul",
                  "/curve25519-dalek/src/scalar.rs/unpack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul(self, _rhs: &'a Scalar) -> Scalar {\n        UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/from_bytes_mod_order_wide",
                "content": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_bytes_wide"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> Scalar {\n        UnpackedScalar::from_bytes_wide(input).pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/as_radix_16",
                "content": "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn as_radix_16(&self) -> [i8; 64] {\n        debug_assert!(self[31] <= 127);\n        let mut output = [0i8; 64];\n\n        // Step 1: change radix.\n        // Convert from radix 256 (bytes) to radix 16 (nibbles)\n        #[allow(clippy::identity_op)]\n        #[inline(always)]\n        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }\n        #[inline(always)]\n        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }\n\n        for i in 0..32 {\n            output[2 * i] = bot_half(self[i]) as i8;\n            output[2 * i + 1] = top_half(self[i]) as i8;\n        }\n        // Precondition note: since self[31] <= 127, output[63] <= 7\n\n        // Step 2: recenter coefficients from [0,16) to [-8,8)\n        for i in 0..63 {\n            let carry = (output[i] + 8) >> 4;\n            output[i] -= carry << 4;\n            output[i + 1] += carry;\n        }\n        // Precondition note: output[63] is not recentered.  It\n        // increases by carry <= 1.  Thus output[63] <= 8.\n\n        output\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/sub",
                "content": "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/scalar.rs/unpack",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub(self, rhs: &'a Scalar) -> Scalar {\n        // The UnpackedScalar::sub function produces reduced outputs if the inputs are reduced. By\n        // Scalar invariant #1, this is always the case.\n        UnpackedScalar::sub(&self.unpack(), &rhs.unpack()).pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/eq",
                "content": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/ct_eq"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/invert",
                "content": "    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/unpack",
                  "/curve25519-dalek/src/scalar.rs/invert",
                  "/curve25519-dalek/src/scalar.rs/pack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn invert(&self) -> Scalar {\n        self.unpack().invert().pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/from_canonical_bytes",
                "content": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/is_canonical"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_canonical_bytes(bytes: [u8; 32]) -> CtOption<Scalar> {\n        let high_bit_unset = (bytes[31] >> 7).ct_eq(&0);\n        let candidate = Scalar { bytes };\n        CtOption::new(candidate, high_bit_unset & candidate.is_canonical())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/invert",
                "content": "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_montgomery",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/as_montgomery",
                  "/curve25519-dalek/src/scalar.rs/montgomery_invert"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn invert(&self) -> UnpackedScalar {\n        self.as_montgomery().montgomery_invert().from_montgomery()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/read_le_u64_into",
                "content": "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "fn read_le_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(\n        src.len() == 8 * dst.len(),\n        \"src.len() = {}, dst.len() = {}\",\n        src.len(),\n        dst.len()\n    );\n    for (bytes, val) in src.chunks(8).zip(dst.iter_mut()) {\n        *val = u64::from_le_bytes(\n            bytes\n                .try_into()\n                .expect(\"Incorrect src length, should be 8 * dst.len()\"),\n        );\n    }\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/clamp_integer",
                "content": "pub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "pub const fn clamp_integer(mut bytes: [u8; 32]) -> [u8; 32] {\n    bytes[0] &= 0b1111_1000;\n    bytes[31] &= 0b0111_1111;\n    bytes[31] |= 0b0100_0000;\n    bytes\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/unpack",
                "content": "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_bytes"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn unpack(&self) -> UnpackedScalar {\n        UnpackedScalar::from_bytes(&self.bytes)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/to_bytes",
                "content": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.bytes\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/to_radix_2w_size_hint",
                "content": "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        let digits_count = match w {\n            4..=7 => 256_usize.div_ceil(w),\n            // See comment in to_radix_2w on handling the terminal carry.\n            8 => 256_usize.div_ceil(w) + 1_usize,\n            _ => panic!(\"invalid radix parameter\"),\n        };\n\n        debug_assert!(digits_count <= 64);\n        digits_count\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/default",
                "content": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> Scalar {\n        Scalar::ZERO\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/square_multiply",
                "content": "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_square",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/from_bytes_mod_order",
                "content": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/reduce"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_bytes_mod_order(bytes: [u8; 32]) -> Scalar {\n        // Temporarily allow s_unreduced.bytes > 2^255 ...\n        let s_unreduced = Scalar { bytes };\n\n        // Then reduce mod the group order and return the reduced representative.\n        let s = s_unreduced.reduce();\n        debug_assert_eq!(0u8, s[31] >> 7);\n\n        s\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/as_radix_2w",
                "content": "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/as_radix_16",
                  "/curve25519-dalek/src/scalar.rs/read_le_u64_into"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn as_radix_2w(&self, w: usize) -> [i8; 64] {\n        debug_assert!(w >= 4);\n        debug_assert!(w <= 8);\n\n        if w == 4 {\n            return self.as_radix_16();\n        }\n\n        // Scalar formatted as four `u64`s with carry bit packed into the highest bit.\n        let mut scalar64x4 = [0u64; 4];\n        read_le_u64_into(&self.bytes, &mut scalar64x4[0..4]);\n\n        let radix: u64 = 1 << w;\n        let window_mask: u64 = radix - 1;\n\n        let mut carry = 0u64;\n        let mut digits = [0i8; 64];\n        let digits_count = 256_usize.div_ceil(w);\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..digits_count {\n            // Construct a buffer of bits of the scalar, starting at `bit_offset`.\n            let bit_offset = i * w;\n            let u64_idx = bit_offset / 64;\n            let bit_idx = bit_offset % 64;\n\n            // Read the bits from the scalar\n            let bit_buf: u64 = if bit_idx < 64 - w || u64_idx == 3 {\n                // This window's bits are contained in a single u64,\n                // or it's the last u64 anyway.\n                scalar64x4[u64_idx] >> bit_idx\n            } else {\n                // Combine the current u64's bits with the bits from the next u64\n                (scalar64x4[u64_idx] >> bit_idx) | (scalar64x4[1 + u64_idx] << (64 - bit_idx))\n            };\n\n            // Read the actual coefficient value from the window\n            let coef = carry + (bit_buf & window_mask); // coef = [0, 2^r)\n\n            // Recenter coefficients from [0,2^w) to [-2^w/2, 2^w/2)\n            carry = (coef + (radix / 2)) >> w;\n            digits[i] = ((coef as i64) - (carry << w) as i64) as i8;\n        }\n\n        // When 4 < w < 8, we can fold the final carry onto the last digit d,\n        // because d < 2^w/2 so d + carry*2^w = d + 1*2^w < 2^(w+1) < 2^8.\n        //\n        // When w = 8, we can't fit carry*2^w into an i8.  This should\n        // not happen anyways, because the final carry will be 0 for\n        // reduced scalars, but Scalar invariant #1 allows 255-bit scalars.\n        // To handle this, we expand the size_hint by 1 when w=8,\n        // and accumulate the final carry onto another digit.\n        match w {\n            8 => digits[digits_count] += carry as i8,\n            _ => digits[digits_count - 1] += (carry << w) as i8,\n        }\n\n        digits\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/pack",
                "content": "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/to_bytes"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn pack(&self) -> Scalar {\n        Scalar {\n            bytes: self.to_bytes(),\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/reduce",
                "content": "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                  "/curve25519-dalek/src/scalar.rs/unpack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn reduce(&self) -> Scalar {\n        let x = self.unpack();\n        let xR = UnpackedScalar::mul_internal(&x, &constants::R);\n        let x_mod_l = UnpackedScalar::montgomery_reduce(&xR);\n        x_mod_l.pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/montgomery_invert",
                "content": "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_square"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn montgomery_invert(&self) -> UnpackedScalar {\n        // Uses the addition chain from\n        // https://briansmith.org/ecc-inversion-addition-chains-01#curve25519_scalar_inversion\n        let    _1 = *self;\n        let   _10 = _1.montgomery_square();\n        let  _100 = _10.montgomery_square();\n        let   _11 = UnpackedScalar::montgomery_mul(&_10,     &_1);\n        let  _101 = UnpackedScalar::montgomery_mul(&_10,    &_11);\n        let  _111 = UnpackedScalar::montgomery_mul(&_10,   &_101);\n        let _1001 = UnpackedScalar::montgomery_mul(&_10,   &_111);\n        let _1011 = UnpackedScalar::montgomery_mul(&_10,  &_1001);\n        let _1111 = UnpackedScalar::montgomery_mul(&_100, &_1011);\n\n        // _10000\n        let mut y = UnpackedScalar::montgomery_mul(&_1111, &_1);\n\n        #[inline]\n        fn square_multiply(y: &mut UnpackedScalar, squarings: usize, x: &UnpackedScalar) {\n            for _ in 0..squarings {\n                *y = y.montgomery_square();\n            }\n            *y = UnpackedScalar::montgomery_mul(y, x);\n        }\n\n        square_multiply(&mut y, 123 + 3, &_101);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,       4, &_1001);\n        square_multiply(&mut y,       2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   1 + 3, &_101);\n        square_multiply(&mut y,   3 + 3, &_101);\n        square_multiply(&mut y,       3, &_111);\n        square_multiply(&mut y,   1 + 4, &_1111);\n        square_multiply(&mut y,   2 + 3, &_111);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,   2 + 4, &_1011);\n        square_multiply(&mut y,   6 + 4, &_1001);\n        square_multiply(&mut y,   2 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   3 + 2, &_11);\n        square_multiply(&mut y,   1 + 4, &_1001);\n        square_multiply(&mut y,   1 + 3, &_111);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,   1 + 4, &_1011);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   2 + 4, &_1111);\n        square_multiply(&mut y,       3, &_101);\n        square_multiply(&mut y,   1 + 2, &_11);\n\n        y\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/is_canonical",
                "content": "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/ct_eq",
                  "/curve25519-dalek/src/scalar.rs/reduce"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn is_canonical(&self) -> Choice {\n        self.ct_eq(&self.reduce())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/index",
                "content": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn index(&self, _index: usize) -> &u8 {\n        &(self.bytes[_index])\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/random",
                "content": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/from_bytes_mod_order_wide"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn random<R: CryptoRng + ?Sized>(rng: &mut R) -> Self {\n        let mut scalar_bytes = [0u8; 64];\n        rng.fill_bytes(&mut scalar_bytes);\n        Scalar::from_bytes_mod_order_wide(&scalar_bytes)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/batch_invert",
                "content": "    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // Zeroize::zeroize(&mut scratch);\n\n        ret\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/montgomery_invert",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_mul",
                  "/curve25519-dalek/src/scalar.rs/unpack",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/as_montgomery",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/from_montgomery",
                  "/curve25519-dalek/src/scalar.rs/pack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn batch_invert(inputs: &mut [Scalar]) -> Scalar {\n        // This code is essentially identical to the FieldElement\n        // implementation, and is documented there.  Unfortunately,\n        // it's not easy to write it generically, since here we want\n        // to use `UnpackedScalar`s internally, and `Scalar`s\n        // externally, but there's no corresponding distinction for\n        // field elements.\n\n        let n = inputs.len();\n        let one: UnpackedScalar = Scalar::ONE.unpack().as_montgomery();\n\n        let mut scratch = vec![one; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = Scalar::ONE.unpack().as_montgomery();\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter_mut().zip(scratch.iter_mut()) {\n            *scratch = acc;\n\n            // Avoid unnecessary Montgomery multiplication in second pass by\n            // keeping inputs in Montgomery form\n            let tmp = input.unpack().as_montgomery();\n            *input = tmp.pack();\n            acc = UnpackedScalar::montgomery_mul(&acc, &tmp);\n        }\n\n        // acc is nonzero iff all inputs are nonzero\n        debug_assert!(acc.pack() != Scalar::ZERO);\n\n        // Compute the inverse of all products\n        acc = acc.montgomery_invert().from_montgomery();\n\n        // We need to return the product of all inverses later\n        let ret = acc.pack();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.iter().rev()) {\n            let tmp = UnpackedScalar::montgomery_mul(&acc, &input.unpack());\n            *input = UnpackedScalar::montgomery_mul(&acc, scratch).pack();\n            acc = tmp;\n        }\n\n        // #[cfg(feature = \"zeroize\")]\n        // Zeroize::zeroize(&mut scratch);\n\n        ret\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/sub_assign",
                "content": "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub_assign(&mut self, _rhs: &'a Scalar) {\n        *self = *self - _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Scalar{{\\n\\tbytes: {:?},\\n}}\", &self.bytes)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/conditional_select",
                "content": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        let mut bytes = [0u8; 32];\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..32 {\n            bytes[i] = u8::conditional_select(&a.bytes[i], &b.bytes[i], choice);\n        }\n        Scalar { bytes }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/sum",
                "content": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(Scalar::ZERO, |acc, item| acc + item.borrow())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/neg",
                "content": "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/montgomery_reduce",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/sub",
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul_internal",
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/scalar.rs/unpack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> Scalar {\n        let self_R = UnpackedScalar::mul_internal(&self.unpack(), &constants::R);\n        let self_mod_l = UnpackedScalar::montgomery_reduce(&self_R);\n        UnpackedScalar::sub(&UnpackedScalar::ZERO, &self_mod_l).pack()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/as_bytes",
                "content": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.bytes\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/neg",
                "content": "    fn neg(self) -> Scalar {\n        -&self\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> Scalar {\n        -&self\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/from",
                "content": "    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn from(x: u8) -> Scalar {\n        let mut s_bytes = [0u8; 32];\n        s_bytes[0] = x;\n        Scalar { bytes: s_bytes }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/mul_assign",
                "content": "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/scalar.rs/mul",
                  "/curve25519-dalek/src/scalar.rs/pack",
                  "/curve25519-dalek/src/scalar.rs/unpack"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul_assign(&mut self, _rhs: &'a Scalar) {\n        *self = UnpackedScalar::mul(&self.unpack(), &_rhs.unpack()).pack();\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/top_half",
                "content": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/bot_half"
                ],
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "        fn top_half(x: u8) -> u8 {\n            (x >> 4) & 15\n        }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/scalar.rs/bot_half",
                "content": "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
                "code_name": "mod.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "        fn bot_half(x: u8) -> u8 {\n            (x >> 0) & 15\n        }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/traits.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/traits.rs/optional_multiscalar_mul",
                "content": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/is_identity",
                "content": "    fn is_identity(&self) -> bool;\n}\n\n/// Implement generic identity equality testing for a point representations\n/// which have constant-time equality testing and a defined identity\n/// constructor.\nimpl<T> IsIdentity for T\nwhere\n    T: ConstantTimeEq + Identity,\n{\n    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }\n}",
                "dependencies": [
                  "/curve25519-dalek/src/traits.rs/identity"
                ],
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn is_identity(&self) -> bool;\n}\n\n/// Implement generic identity equality testing for a point representations\n/// which have constant-time equality testing and a defined identity\n/// constructor.\nimpl<T> IsIdentity for T\nwhere\n    T: ConstantTimeEq + Identity,\n{\n    fn is_identity(&self) -> bool {\n        self.ct_eq(&T::identity()).into()\n    }\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/mul_base_clamped",
                "content": "    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/clamp_integer"
                ],
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/vartime_mixed_multiscalar_mul",
                "content": "    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn vartime_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator,\n        K::Item: Borrow<Self::Point>,\n    {\n        Self::optional_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            dynamic_scalars,\n            dynamic_points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/vartime_multiscalar_mul",
                "content": "    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/traits.rs/vartime_mixed_multiscalar_mul"
                ],
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/new",
                "content": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>;\n\n    /// Return the number of static points in the precomputation.\n    fn len(&self) -> usize;\n\n    /// Determine if the precomputation is empty.\n    fn is_empty(&self) -> bool;\n\n    /// Given `static_scalars`, an iterator of public scalars\n    /// \\\\(b_i\\\\), compute\n    /// $$\n    /// Q = b_1 B_1 + \\cdots + b_m B_m,\n    /// $$\n    /// where the \\\\(B_j\\\\) are the points that were supplied to `new`.\n    ///\n    /// It is valid for \\\\(b_i\\\\) to have a shorter length than \\\\(B_j\\\\).\n    /// In this case, any \"unused\" points are ignored in the computation.\n    /// It is an error to call this function if \\\\(b_i\\\\) has a longer\n    /// length than \\\\(B_j\\\\).\n    ///\n    /// The trait bound aims for maximum flexibility: the input must\n    /// be convertible to iterators (`I: IntoIter`), and the\n    /// iterator's items must be `Borrow<Scalar>`, to allow iterators\n    /// returning either `Scalar`s or `&Scalar`s.\n    fn vartime_multiscalar_mul<I>(&self, static_scalars: I) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n    {\n        use core::iter;\n\n        Self::vartime_mixed_multiscalar_mul(\n            self,\n            static_scalars,\n            iter::empty::<Scalar>(),\n            iter::empty::<Self::Point>(),\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/identity",
                "content": "    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> Self;\n}\n\n/// Trait for testing if a curve point is equivalent to the identity point.\npub trait IsIdentity {\n    /// Return true if this element is the identity element of the curve.\n    fn is_identity(&self) -> bool;\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/create",
                "content": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn create(basepoint: &Self::Point) -> Self;\n\n    /// Retrieve the original basepoint from this table.\n    fn basepoint(&self) -> Self::Point;\n\n    /// Multiply a `scalar` by this precomputed basepoint table, in constant time.\n    fn mul_base(&self, scalar: &Scalar) -> Self::Point;\n\n    /// Multiply `clamp_integer(bytes)` by this precomputed basepoint table, in constant time. For\n    /// a description of clamping, see [`clamp_integer`].\n    fn mul_base_clamped(&self, bytes: [u8; 32]) -> Self::Point {\n        // Basepoint multiplication is defined for all values of `bytes` up to and including\n        // 2^255 - 1. The limit comes from the fact that scalar.as_radix_16() doesn't work for\n        // most scalars larger than 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        self.mul_base(&s)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/multiscalar_mul",
                "content": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>;\n}\n\n/// A trait for variable-time multiscalar multiplication without precomputation.\npub trait VartimeMultiscalarMul {\n    /// The type of point being multiplied, e.g., `RistrettoPoint`.\n    type Point;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// `Option`s of points, compute either `Some(Q)`, where\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// if all points were `Some(P_i)`, or else return `None`.\n    ///\n    /// This function is particularly useful when verifying statements\n    /// involving compressed points.  Accepting `Option<Point>` allows\n    /// inlining point decompression into the multiscalar call,\n    /// avoiding the need for temporary buffers.\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    /// let abc = [a,b,c];\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    /// let PQR = [P, Q, R];\n    ///\n    /// let compressed = [P.compress(), Q.compress(), R.compress()];\n    ///\n    /// // Now we can compute A1 = a*P + b*Q + c*R using P, Q, R:\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &PQR);\n    ///\n    /// // Or using the compressed points:\n    /// let A2 = RistrettoPoint::optional_multiscalar_mul(\n    ///     &abc,\n    ///     compressed.iter().map(|pt| pt.decompress()),\n    /// );\n    ///\n    /// assert_eq!(A2, Some(A1));\n    ///\n    /// // It's also possible to mix compressed and uncompressed points:\n    /// let A3 = RistrettoPoint::optional_multiscalar_mul(\n    ///     abc.iter()\n    ///         .chain(abc.iter()),\n    ///     compressed.iter().map(|pt| pt.decompress())\n    ///         .chain(PQR.iter().map(|&pt| Some(pt))),\n    /// );\n    ///\n    /// assert_eq!(A3, Some(A1+A1));\n    /// # }\n    /// ```\n    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<Self::Point>>;\n\n    /// Given an iterator of public scalars and an iterator of\n    /// public points, compute\n    /// $$\n    /// Q = c\\_1 P\\_1 + \\cdots + c\\_n P\\_n,\n    /// $$\n    /// using variable-time operations.\n    ///\n    /// It is an error to call this function with two iterators of different lengths.\n    ///\n    /// # Examples\n    ///\n    /// The trait bound aims for maximum flexibility: the inputs must be\n    /// convertible to iterators (`I: IntoIter`), and the iterator's items\n    /// must be `Borrow<Scalar>` (or `Borrow<Point>`), to allow\n    /// iterators returning either `Scalar`s or `&Scalar`s.\n    ///\n    /// ```\n    /// #[cfg(feature = \"alloc\")]\n    /// # {\n    /// use curve25519_dalek::constants;\n    /// use curve25519_dalek::traits::VartimeMultiscalarMul;\n    /// use curve25519_dalek::ristretto::RistrettoPoint;\n    /// use curve25519_dalek::scalar::Scalar;\n    ///\n    /// // Some scalars\n    /// let a = Scalar::from(87329482u64);\n    /// let b = Scalar::from(37264829u64);\n    /// let c = Scalar::from(98098098u64);\n    ///\n    /// // Some points\n    /// let P = constants::RISTRETTO_BASEPOINT_POINT;\n    /// let Q = P + P;\n    /// let R = P + Q;\n    ///\n    /// // A1 = a*P + b*Q + c*R\n    /// let abc = [a,b,c];\n    /// let A1 = RistrettoPoint::vartime_multiscalar_mul(&abc, &[P,Q,R]);\n    /// // Note: (&abc).into_iter(): Iterator<Item=&Scalar>\n    ///\n    /// // A2 = (-a)*P + (-b)*Q + (-c)*R\n    /// let minus_abc = abc.iter().map(|x| -x);\n    /// let A2 = RistrettoPoint::vartime_multiscalar_mul(minus_abc, &[P,Q,R]);\n    /// // Note: minus_abc.into_iter(): Iterator<Item=Scalar>\n    ///\n    /// assert_eq!(A1.compress(), (-A2).compress());\n    /// # }\n    /// ```\n    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/traits.rs/vartime_multiscalar_mul",
                "content": "    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/traits.rs/optional_multiscalar_mul"
                ],
                "code_name": "ristretto.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn vartime_multiscalar_mul<I, J>(scalars: I, points: J) -> Self::Point\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Self::Point>,\n        Self::Point: Clone,\n    {\n        Self::optional_multiscalar_mul(\n            scalars,\n            points.into_iter().map(|P| Some(P.borrow().clone())),\n        )\n        .expect(\"should return some point\")\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/field.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/field.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &FieldElement) -> Choice {\n        self.to_bytes().ct_eq(&other.to_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/is_negative",
                "content": "    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn is_negative(&self) -> Choice {\n        let bytes = self.to_bytes();\n        (bytes[0] & 1).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/invsqrt",
                "content": "    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/sqrt_ratio_i"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn invsqrt(&self) -> (Choice, FieldElement) {\n        FieldElement::sqrt_ratio_i(&FieldElement::ONE, self)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/batch_invert",
                "content": "    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign",
                  "/curve25519-dalek/src/field.rs/invert",
                  "/curve25519-dalek/src/field.rs/is_zero"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn batch_invert(inputs: &mut [FieldElement]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        let n = inputs.len();\n        let mut scratch = vec![FieldElement::ONE; n];\n\n        // Keep an accumulator of all of the previous products\n        let mut acc = FieldElement::ONE;\n\n        // Pass through the input vector, recording the previous\n        // products in the scratch space\n        for (input, scratch) in inputs.iter().zip(scratch.iter_mut()) {\n            *scratch = acc;\n            // acc <- acc * input, but skipping zeros (constant-time)\n            acc.conditional_assign(&(&acc * input), !input.is_zero());\n        }\n\n        // acc is nonzero because we skipped zeros in inputs\n        assert!(bool::from(!acc.is_zero()));\n\n        // Compute the inverse of all products\n        acc = acc.invert();\n\n        // Pass through the vector backwards to compute the inverses\n        // in place\n        for (input, scratch) in inputs.iter_mut().rev().zip(scratch.into_iter().rev()) {\n            let tmp = &acc * input;\n            // input <- acc * scratch, then acc <- tmp\n            // Again, we skip zeros in a constant-time way\n            let nz = !input.is_zero();\n            input.conditional_assign(&(&acc * &scratch), nz);\n            acc.conditional_assign(&tmp, nz);\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/eq",
                "content": "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/ct_eq"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &FieldElement) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/sqrt_ratio_i",
                "content": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/ct_eq",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_assign",
                  "/curve25519-dalek/src/field.rs/is_negative",
                  "/curve25519-dalek/src/field.rs/pow_p58"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (Choice, FieldElement) {\n        // Using the same trick as in ed25519 decoding, we merge the\n        // inversion, the square root, and the square test as follows.\n        //\n        // To compute sqrt(α), we can compute β = α^((p+3)/8).\n        // Then β^2 = ±α, so multiplying β by sqrt(-1) if necessary\n        // gives sqrt(α).\n        //\n        // To compute 1/sqrt(α), we observe that\n        //    1/β = α^(p-1 - (p+3)/8) = α^((7p-11)/8)\n        //                            = α^3 * (α^7)^((p-5)/8).\n        //\n        // We can therefore compute sqrt(u/v) = sqrt(u)/sqrt(v)\n        // by first computing\n        //    r = u^((p+3)/8) v^(p-1-(p+3)/8)\n        //      = u u^((p-5)/8) v^3 (v^7)^((p-5)/8)\n        //      = (uv^3) (uv^7)^((p-5)/8).\n        //\n        // If v is nonzero and u/v is square, then r^2 = ±u/v,\n        //                                     so vr^2 = ±u.\n        // If vr^2 =  u, then sqrt(u/v) = r.\n        // If vr^2 = -u, then sqrt(u/v) = r*sqrt(-1).\n        //\n        // If v is zero, r is also zero.\n\n        let v3 = &v.square() * v;\n        let v7 = &v3.square() * v;\n        let mut r = &(u * &v3) * &(u * &v7).pow_p58();\n        let check = v * &r.square();\n\n        let i = &constants::SQRT_M1;\n\n        let correct_sign_sqrt = check.ct_eq(u);\n        let flipped_sign_sqrt = check.ct_eq(&(-u));\n        let flipped_sign_sqrt_i = check.ct_eq(&(&(-u) * i));\n\n        let r_prime = &constants::SQRT_M1 * &r;\n        r.conditional_assign(&r_prime, flipped_sign_sqrt | flipped_sign_sqrt_i);\n\n        // Choose the nonnegative square root.\n        let r_is_negative = r.is_negative();\n        r.conditional_negate(r_is_negative);\n\n        let was_nonzero_square = correct_sign_sqrt | flipped_sign_sqrt;\n\n        (was_nonzero_square, r)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/is_zero",
                "content": "    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn is_zero(&self) -> Choice {\n        let zero = [0u8; 32];\n        let bytes = self.to_bytes();\n\n        bytes.ct_eq(&zero)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/invert",
                "content": "    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/pow2k",
                  "/curve25519-dalek/src/field.rs/pow22501"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn invert(&self) -> FieldElement {\n        // The bits of p-2 = 2^255 -19 -2 are 11010111111...11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, t3) = self.pow22501();   // t19: 249..0 ; t3: 3,1,0\n        let t20 = t19.pow2k(5);            // 254..5\n        let t21 = &t20 * &t3;              // 254..5,3,1,0\n\n        t21\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/pow22501",
                "content": "    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/pow2k"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn pow22501(&self) -> (FieldElement, FieldElement) {\n        // Instead of managing which temporary variables are used\n        // for what, we define as many as we need and leave stack\n        // allocation to the compiler\n        //\n        // Each temporary variable t_i is of the form (self)^e_i.\n        // Squaring t_i corresponds to multiplying e_i by 2,\n        // so the pow2k function shifts e_i left by k places.\n        // Multiplying t_i and t_j corresponds to adding e_i + e_j.\n        //\n        // Temporary t_i                      Nonzero bits of e_i\n        //\n        let t0  = self.square();           // 1         e_0 = 2^1\n        let t1  = t0.square().square();    // 3         e_1 = 2^3\n        let t2  = self * &t1;              // 3,0       e_2 = 2^3 + 2^0\n        let t3  = &t0 * &t2;               // 3,1,0\n        let t4  = t3.square();             // 4,2,1\n        let t5  = &t2 * &t4;               // 4,3,2,1,0\n        let t6  = t5.pow2k(5);             // 9,8,7,6,5\n        let t7  = &t6 * &t5;               // 9,8,7,6,5,4,3,2,1,0\n        let t8  = t7.pow2k(10);            // 19..10\n        let t9  = &t8 * &t7;               // 19..0\n        let t10 = t9.pow2k(20);            // 39..20\n        let t11 = &t10 * &t9;              // 39..0\n        let t12 = t11.pow2k(10);           // 49..10\n        let t13 = &t12 * &t7;              // 49..0\n        let t14 = t13.pow2k(50);           // 99..50\n        let t15 = &t14 * &t13;             // 99..0\n        let t16 = t15.pow2k(100);          // 199..100\n        let t17 = &t16 * &t15;             // 199..0\n        let t18 = t17.pow2k(50);           // 249..50\n        let t19 = &t18 * &t13;             // 249..0\n\n        (t19, t3)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/field.rs/pow_p58",
                "content": "    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/pow2k",
                  "/curve25519-dalek/src/field.rs/pow22501"
                ],
                "code_name": "montgomery.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn pow_p58(&self) -> FieldElement {\n        // The bits of (p-5)/8 are 101111.....11.\n        //\n        //                                 nonzero bits of exponent\n        let (t19, _) = self.pow22501();    // 249..0\n        let t20 = t19.pow2k(2);            // 251..2\n        let t21 = self * &t20;             // 251..2,0\n\n        t21\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/montgomery.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul",
                "content": "    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB is 0, so we can skip it.\n        self.mul_bits_be(scalar.bits_le().rev().skip(1))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/bits_le",
                  "/curve25519-dalek/src/montgomery.rs/mul_bits_be"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul(self, scalar: &Scalar) -> MontgomeryPoint {\n        // We multiply by the integer representation of the given Scalar. By scalar invariant #1,\n        // the MSB is 0, so we can skip it.\n        self.mul_bits_be(scalar.bits_le().rev().skip(1))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/differential_add_and_double",
                "content": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n) {\n    let t0 = &P.U + &P.W;\n    let t1 = &P.U - &P.W;\n    let t2 = &Q.U + &Q.W;\n    let t3 = &Q.U - &Q.W;\n\n    let t4 = t0.square();   // (U_P + W_P)^2 = U_P^2 + 2 U_P W_P + W_P^2\n    let t5 = t1.square();   // (U_P - W_P)^2 = U_P^2 - 2 U_P W_P + W_P^2\n\n    let t6 = &t4 - &t5;     // 4 U_P W_P\n\n    let t7 = &t0 * &t3;     // (U_P + W_P) (U_Q - W_Q) = U_P U_Q + W_P U_Q - U_P W_Q - W_P W_Q\n    let t8 = &t1 * &t2;     // (U_P - W_P) (U_Q + W_Q) = U_P U_Q - W_P U_Q + U_P W_Q - W_P W_Q\n\n    let t9  = &t7 + &t8;    // 2 (U_P U_Q - W_P W_Q)\n    let t10 = &t7 - &t8;    // 2 (W_P U_Q - U_P W_Q)\n\n    let t11 =  t9.square(); // 4 (U_P U_Q - W_P W_Q)^2\n    let t12 = t10.square(); // 4 (W_P U_Q - U_P W_Q)^2\n\n    let t13 = &APLUS2_OVER_FOUR * &t6; // (A + 2) U_P U_Q\n\n    let t14 = &t4 * &t5;    // ((U_P + W_P)(U_P - W_P))^2 = (U_P^2 - W_P^2)^2\n    let t15 = &t13 + &t5;   // (U_P - W_P)^2 + (A + 2) U_P W_P\n\n    let t16 = &t6 * &t15;   // 4 (U_P W_P) ((U_P - W_P)^2 + (A + 2) U_P W_P)\n\n    let t17 = affine_PmQ * &t12; // U_D * 4 (W_P U_Q - U_P W_Q)^2\n    let t18 = t11;               // W_D * 4 (U_P U_Q - W_P W_Q)^2\n\n    P.U = t14;  // U_{P'} = (U_P + W_P)^2 (U_P - W_P)^2\n    P.W = t16;  // W_{P'} = (4 U_P W_P) ((U_P - W_P)^2 + ((A + 2)/4) 4 U_P W_P)\n    Q.U = t18;  // U_{Q'} = W_D * 4 (U_P U_Q - W_P W_Q)^2\n    Q.W = t17;  // W_{Q'} = U_D * 4 (W_P U_Q - U_P W_Q)^2\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/as_bytes",
                "content": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul_clamped",
                "content": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/clamp_integer"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul_base",
                "content": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/mul_base",
                  "/curve25519-dalek/src/edwards.rs/to_montgomery"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        EdwardsPoint::mul_base(scalar).to_montgomery()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/to_edwards",
                "content": "    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/edwards.rs/decompress",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                  "/curve25519-dalek/src/field.rs/invert"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn to_edwards(&self, sign: u8) -> Option<EdwardsPoint> {\n        // To decompress the Montgomery u coordinate to an\n        // `EdwardsPoint`, we apply the birational map to obtain the\n        // Edwards y coordinate, then do Edwards decompression.\n        //\n        // The birational map is y = (u-1)/(u+1).\n        //\n        // The exceptional points are the zeros of the denominator,\n        // i.e., u = -1.\n        //\n        // But when u = -1, v^2 = u*(u^2+486662*u+1) = 486660.\n        //\n        // Since this is nonsquare mod p, u = -1 corresponds to a point\n        // on the twist, not the curve, so we can reject it early.\n\n        let u = FieldElement::from_bytes(&self.0);\n\n        if u == FieldElement::MINUS_ONE {\n            return None;\n        }\n\n        let one = FieldElement::ONE;\n\n        let y = &(&u - &one) * &(&u + &one).invert();\n\n        let mut y_bytes = y.to_bytes();\n        y_bytes[31] ^= sign << 7;\n\n        CompressedEdwardsY(y_bytes).decompress()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul_base_clamped",
                "content": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/montgomery.rs/mul_base",
                  "/curve25519-dalek/src/scalar.rs/clamp_integer"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/conditional_select",
                "content": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self(<[u8; 32]>::conditional_select(&a.0, &b.0, choice))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/elligator_encode",
                "content": "pub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square2",
                  "/curve25519-dalek/src/field.rs/sqrt_ratio_i",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select",
                  "/curve25519-dalek/src/field.rs/invert"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "pub(crate) fn elligator_encode(r_0: &FieldElement) -> (MontgomeryPoint, Choice) {\n    let one = FieldElement::ONE;\n    let d_1 = &one + &r_0.square2(); /* 2r^2 */\n\n    let d = &MONTGOMERY_A_NEG * &(d_1.invert()); /* A/(1+2r^2) */\n\n    let d_sq = &d.square();\n    let au = &MONTGOMERY_A * &d;\n\n    let inner = &(d_sq + &au) + &one;\n    let eps = &d * &inner; /* eps = d^3 + Ad^2 + d */\n\n    let (eps_is_sq, _eps) = FieldElement::sqrt_ratio_i(&eps, &one);\n\n    let zero = FieldElement::ZERO;\n    let Atemp = FieldElement::conditional_select(&MONTGOMERY_A, &zero, eps_is_sq); /* 0, or A if nonsquare*/\n    let mut u = &d + &Atemp; /* d, or d+A if nonsquare */\n    u.conditional_negate(!eps_is_sq); /* d, or -d-A if nonsquare */\n\n    (MontgomeryPoint(u.to_bytes()), eps_is_sq)\n}",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/identity",
                "content": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::ONE,\n            W: FieldElement::ZERO,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/default",
                "content": "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/montgomery.rs/identity"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> ProjectivePoint {\n        ProjectivePoint::identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/as_affine",
                "content": "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/invert",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn as_affine(&self) -> MontgomeryPoint {\n        let u = &self.U * &self.W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/identity",
                "content": "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> MontgomeryPoint {\n        MontgomeryPoint([0u8; 32])\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/hash",
                "content": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn hash<H: Hasher>(&self, state: &mut H) {\n        // Do a round trip through a `FieldElement`. `as_bytes` is guaranteed to give a canonical\n        // 32-byte encoding\n        let canonical_bytes = FieldElement::from_bytes(&self.0).to_bytes();\n        canonical_bytes.hash(state);\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul_bits_be",
                "content": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        // #[cfg(feature = \"zeroize\")]\n        // prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/montgomery.rs/differential_add_and_double",
                  "/curve25519-dalek/src/montgomery.rs/as_affine",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/montgomery.rs/identity"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n        // Algorithm 8 of Costello-Smith 2017\n        let affine_u = FieldElement::from_bytes(&self.0);\n        let mut x0 = ProjectivePoint::identity();\n        let mut x1 = ProjectivePoint {\n            U: affine_u,\n            W: FieldElement::ONE,\n        };\n\n        // Go through the bits from most to least significant, using a sliding window of 2\n        let mut prev_bit = false;\n        for cur_bit in bits {\n            let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n            debug_assert!(choice == 0 || choice == 1);\n\n            ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n            differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n            prev_bit = cur_bit;\n        }\n        // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n        // Don't leave the bit in the stack\n        // #[cfg(feature = \"zeroize\")]\n        // prev_bit.zeroize();\n\n        x0.as_affine()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/mul_assign",
                "content": "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul_assign(&mut self, scalar: &Scalar) {\n        *self = (self as &MontgomeryPoint) * scalar;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/field.rs/ct_eq"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &MontgomeryPoint) -> Choice {\n        let self_fe = FieldElement::from_bytes(&self.0);\n        let other_fe = FieldElement::from_bytes(&other.0);\n\n        self_fe.ct_eq(&other_fe)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/eq",
                "content": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/montgomery.rs/ct_eq"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &MontgomeryPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/to_bytes",
                "content": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/montgomery.rs/conditional_select",
                "content": "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select"
                ],
                "code_name": "field.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn conditional_select(\n        a: &ProjectivePoint,\n        b: &ProjectivePoint,\n        choice: Choice,\n    ) -> ProjectivePoint {\n        ProjectivePoint {\n            U: FieldElement::conditional_select(&a.U, &b.U, choice),\n            W: FieldElement::conditional_select(&a.W, &b.W, choice),\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/src/edwards.rs",
            "content": "",
            "code_name": "",
            "children": [
              {
                "identifier": "curve25519-dalek/src/edwards.rs/multiscalar_mul",
                "content": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/straus_multiscalar_mul"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn multiscalar_mul<I, J>(scalars: I, points: J) -> EdwardsPoint\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<EdwardsPoint>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.  When we do\n        // size-dependent algorithm dispatch, use this as the hint.\n        let _size = s_lo;\n\n        crate::backend::straus_multiscalar_mul(scalars, points)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_by_pow_2",
                "content": "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_projective",
                  "/curve25519-dalek/src/edwards.rs/as_projective",
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn mul_by_pow_2(&self, k: u32) -> EdwardsPoint {\n        debug_assert!(k > 0);\n        let mut r: CompletedPoint;\n        let mut s = self.as_projective();\n        for _ in 0..(k - 1) {\n            r = s.double();\n            s = r.as_projective();\n        }\n        // Unroll last iteration so we can go directly as_extended()\n        s.double().as_extended()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/optional_multiscalar_mul",
                "content": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/pippenger_optional_multiscalar_mul",
                  "/curve25519-dalek/src/backend/mod.rs/straus_optional_multiscalar_mul"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn optional_multiscalar_mul<I, J>(scalars: I, points: J) -> Option<EdwardsPoint>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator<Item = Option<EdwardsPoint>>,\n    {\n        // Sanity-check lengths of input iterators\n        let mut scalars = scalars.into_iter();\n        let mut points = points.into_iter();\n\n        // Lower and upper bounds on iterators\n        let (s_lo, s_hi) = scalars.by_ref().size_hint();\n        let (p_lo, p_hi) = points.by_ref().size_hint();\n\n        // They should all be equal\n        assert_eq!(s_lo, p_lo);\n        assert_eq!(s_hi, Some(s_lo));\n        assert_eq!(p_hi, Some(p_lo));\n\n        // Now we know there's a single size.\n        // Use this as the hint to decide which algorithm to use.\n        let size = s_lo;\n\n        if size < 190 {\n            crate::backend::straus_optional_multiscalar_mul(scalars, points)\n        } else {\n            crate::backend::pippenger_optional_multiscalar_mul(scalars, points)\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_assign",
                "content": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul_assign(&mut self, scalar: &'a Scalar) {\n        let result = (self as &EdwardsPoint) * scalar;\n        *self = result;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/as_bytes",
                "content": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn as_bytes(&self) -> &[u8; 32] {\n        &self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/to_bytes",
                "content": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub const fn to_bytes(&self) -> [u8; 32] {\n        self.0\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"CompressedEdwardsY: {:?}\", self.as_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/sum",
                "content": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/identity"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = T>,\n    {\n        iter.fold(EdwardsPoint::identity(), |acc, item| acc + item.borrow())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/sub",
                "content": "    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/as_projective_niels",
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self - &other.as_projective_niels()).as_extended()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/compress_batch",
                "content": "    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/batch_invert",
                  "/curve25519-dalek/src/edwards/affine.rs/compress"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn compress_batch(inputs: &[EdwardsPoint]) -> Vec<CompressedEdwardsY> {\n        let mut zs = inputs.iter().map(|input| input.Z).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut zs);\n\n        inputs\n            .iter()\n            .zip(&zs)\n            .map(|(input, recip)| {\n                let x = &input.X * recip;\n                let y = &input.Y * recip;\n                AffinePoint { x, y }.compress()\n            })\n            .collect()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/as_affine_niels",
                "content": "    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/invert"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn as_affine_niels(&self) -> AffineNielsPoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        let xy2d = &(&x * &y) * &constants::EDWARDS_D2;\n        AffineNielsPoint {\n            y_plus_x: &y + &x,\n            y_minus_x: &y - &x,\n            xy2d,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/neg",
                "content": "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> EdwardsPoint {\n        EdwardsPoint {\n            X: -(&self.X),\n            Y: self.Y,\n            Z: self.Z,\n            T: -(&self.T),\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/is_small_order",
                "content": "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/traits.rs/is_identity",
                  "/curve25519-dalek/src/edwards.rs/mul_by_cofactor"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn is_small_order(&self) -> bool {\n        self.mul_by_cofactor().is_identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/as_bytes"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &CompressedEdwardsY) -> Choice {\n        self.as_bytes().ct_eq(other.as_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/conditional_select",
                "content": "    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/conditional_select"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::conditional_select(&a.X, &b.X, choice),\n            Y: FieldElement::conditional_select(&a.Y, &b.Y, choice),\n            Z: FieldElement::conditional_select(&a.Z, &b.Z, choice),\n            T: FieldElement::conditional_select(&a.T, &b.T, choice),\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/is_valid",
                "content": "    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/is_valid",
                  "/curve25519-dalek/src/edwards.rs/as_projective"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn is_valid(&self) -> bool {\n        let point_on_curve = self.as_projective().is_valid();\n        let on_segre_image = (&self.X * &self.Y) == (&self.Z * &self.T);\n\n        point_on_curve && on_segre_image\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/default",
                "content": "    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/identity"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> CompressedEdwardsY {\n        CompressedEdwardsY::identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/is_empty",
                "content": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/is_empty"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_clamped",
                "content": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/scalar.rs/clamp_integer"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_clamped(self, bytes: [u8; 32]) -> Self {\n        // We have to construct a Scalar that is not reduced mod l, which breaks scalar invariant\n        // #2. But #2 is not necessary for correctness of variable-base multiplication. All that\n        // needs to hold is invariant #1, i.e., the scalar is less than 2^255. This is guaranteed\n        // by clamping.\n        // Further, we don't do any reduction or arithmetic with this clamped value, so there's no\n        // issues arising from the fact that the curve point is not necessarily in the prime-order\n        // subgroup.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        s * self\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/add_assign",
                "content": "    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) + _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/to_montgomery",
                "content": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/invert",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn to_montgomery(&self) -> MontgomeryPoint {\n        // We have u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        //\n        // The denominator is zero only when y=1, the identity point of\n        // the Edwards curve.  Since 0.invert() = 0, in this case we\n        // compute the 2-torsion point (0,0).\n        let U = &self.Z + &self.Y;\n        let W = &self.Z - &self.Y;\n        let u = &U * &W.invert();\n        MontgomeryPoint(u.to_bytes())\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/default",
                "content": "    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/identity"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn default() -> EdwardsPoint {\n        EdwardsPoint::identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/optional_mixed_multiscalar_mul",
                "content": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/optional_mixed_multiscalar_mul"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn optional_mixed_multiscalar_mul<I, J, K>(\n        &self,\n        static_scalars: I,\n        dynamic_scalars: J,\n        dynamic_points: K,\n    ) -> Option<Self::Point>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Scalar>,\n        J: IntoIterator,\n        J::Item: Borrow<Scalar>,\n        K: IntoIterator<Item = Option<Self::Point>>,\n    {\n        self.0\n            .optional_mixed_multiscalar_mul(static_scalars, dynamic_scalars, dynamic_points)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/is_torsion_free",
                "content": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/traits.rs/is_identity"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn is_torsion_free(&self) -> bool {\n        (self * constants::BASEPOINT_ORDER).is_identity()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/try_from",
                "content": "    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/from_slice"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn try_from(slice: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        Self::from_slice(slice)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/eq",
                "content": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/ct_eq"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &EdwardsPoint) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/double",
                "content": "    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended",
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/double",
                  "/curve25519-dalek/src/edwards.rs/as_projective"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn double(&self) -> EdwardsPoint {\n        self.as_projective().double().as_extended()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/step_2",
                "content": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/as_bytes"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(super) fn step_2(\n        repr: &CompressedEdwardsY,\n        mut X: FieldElement,\n        Y: FieldElement,\n        Z: FieldElement,\n    ) -> EdwardsPoint {\n         // FieldElement::sqrt_ratio_i always returns the nonnegative square root,\n         // so we negate according to the supplied sign bit.\n        let compressed_sign_bit = Choice::from(repr.as_bytes()[31] >> 7);\n        X.conditional_negate(compressed_sign_bit);\n\n        EdwardsPoint {\n            X,\n            Y,\n            Z,\n            T: &X * &Y,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/identity",
                "content": "    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> EdwardsPoint {\n        EdwardsPoint {\n            X: FieldElement::ZERO,\n            Y: FieldElement::ONE,\n            Z: FieldElement::ONE,\n            T: FieldElement::ZERO,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/ct_eq",
                "content": "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/ct_eq"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn ct_eq(&self, other: &EdwardsPoint) -> Choice {\n        // We would like to check that the point (X/Z, Y/Z) is equal to\n        // the point (X'/Z', Y'/Z') without converting into affine\n        // coordinates (x, y) and (x', y'), which requires two inversions.\n        // We have that X = xZ and X' = x'Z'. Thus, x = x' is equivalent to\n        // (xZ)Z' = (x'Z')Z, and similarly for the y-coordinate.\n\n        (&self.X * &other.Z).ct_eq(&(&other.X * &self.Z))\n            & (&self.Y * &other.Z).ct_eq(&(&other.Y * &self.Z))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_by_cofactor",
                "content": "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/mul_by_pow_2"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_by_cofactor(&self) -> EdwardsPoint {\n        self.mul_by_pow_2(3)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/vartime_double_scalar_mul_basepoint",
                "content": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/vartime_double_base_mul"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn vartime_double_scalar_mul_basepoint(\n        a: &Scalar,\n        A: &EdwardsPoint,\n        b: &Scalar,\n    ) -> EdwardsPoint {\n        crate::backend::vartime_double_base_mul(a, A, b)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/to_affine",
                "content": "    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/field.rs/invert"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn to_affine(self) -> AffinePoint {\n        let recip = self.Z.invert();\n        let x = &self.X * &recip;\n        let y = &self.Y * &recip;\n        AffinePoint { x, y }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/eq",
                "content": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/ct_eq"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn eq(&self, other: &Self) -> bool {\n        self.ct_eq(other).into()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/to_montgomery_batch",
                "content": "    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/to_bytes",
                  "/curve25519-dalek/src/field.rs/batch_invert"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn to_montgomery_batch(eds: &[Self]) -> Vec<MontgomeryPoint> {\n        // Do the same thing as the above function. u = (1+y)/(1-y) = (Z+Y)/(Z-Y).\n        // We will do this in a batch, ie compute (Z-Y) for all the input\n        // points, then invert them all at once\n\n        // Compute the denominators in a batch\n        let mut denominators = eds.iter().map(|p| &p.Z - &p.Y).collect::<Vec<_>>();\n        FieldElement::batch_invert(&mut denominators);\n\n        // Now compute the Montgomery u coordinate for every point\n        let mut ret = Vec::with_capacity(eds.len());\n        for (ed, d) in eds.iter().zip(denominators.iter()) {\n            let u = &(&ed.Z + &ed.Y) * d;\n            ret.push(MontgomeryPoint(u.to_bytes()));\n        }\n\n        ret\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/len",
                "content": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/len"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn len(&self) -> usize {\n        self.0.len()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/random",
                "content": "    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/decompress",
                  "/curve25519-dalek/src/traits.rs/is_identity"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {\n        let mut repr = CompressedEdwardsY([0u8; 32]);\n        loop {\n            rng.fill_bytes(&mut repr.0);\n            if let Some(p) = repr.decompress() {\n                if !IsIdentity::is_identity(&p) {\n                    break p;\n                }\n            }\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/compress",
                "content": "    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards/affine.rs/compress",
                  "/curve25519-dalek/src/edwards.rs/to_affine"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn compress(&self) -> CompressedEdwardsY {\n        self.to_affine().compress()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/add",
                "content": "    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/as_projective_niels",
                  "/curve25519-dalek/src/backend/serial/curve_models/mod.rs/as_extended"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn add(self, other: &'a EdwardsPoint) -> EdwardsPoint {\n        (self + &other.as_projective_niels()).as_extended()\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_base",
                "content": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_base(scalar: &Scalar) -> Self {\n        #[cfg(not(feature = \"precomputed-tables\"))]\n        {\n            scalar * constants::ED25519_BASEPOINT_POINT\n        }\n\n        #[cfg(feature = \"precomputed-tables\")]\n        {\n            scalar * constants::ED25519_BASEPOINT_TABLE\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/sub_assign",
                "content": "    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn sub_assign(&mut self, _rhs: &'a EdwardsPoint) {\n        *self = (self as &EdwardsPoint) - _rhs;\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/neg",
                "content": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn neg(self) -> EdwardsPoint {\n        -&self\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/from_slice",
                "content": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn from_slice(bytes: &[u8]) -> Result<CompressedEdwardsY, TryFromSliceError> {\n        bytes.try_into().map(CompressedEdwardsY)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/identity",
                "content": "    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn identity() -> CompressedEdwardsY {\n        CompressedEdwardsY([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ])\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/new",
                "content": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/new"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn new<I>(static_points: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Borrow<Self::Point>,\n    {\n        Self(crate::backend::VartimePrecomputedStraus::new(static_points))\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/step_1",
                "content": "    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/square",
                  "/curve25519-dalek/src/backend/serial/u64/field.rs/from_bytes",
                  "/curve25519-dalek/src/edwards.rs/as_bytes",
                  "/curve25519-dalek/src/field.rs/sqrt_ratio_i"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(super) fn step_1(\n        repr: &CompressedEdwardsY,\n    ) -> (Choice, FieldElement, FieldElement, FieldElement) {\n        let Y = FieldElement::from_bytes(repr.as_bytes());\n        let Z = FieldElement::ONE;\n        let YY = Y.square();\n        let u = &YY - &Z;                            // u =  y²-1\n        let v = &(&YY * &constants::EDWARDS_D) + &Z; // v = dy²+1\n        let (is_valid_y_coord, X) = FieldElement::sqrt_ratio_i(&u, &v);\n\n        (is_valid_y_coord, X, Y, Z)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul_base_clamped",
                "content": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/mul_base",
                  "/curve25519-dalek/src/scalar.rs/clamp_integer"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn mul_base_clamped(bytes: [u8; 32]) -> Self {\n        // See reasoning in Self::mul_clamped why it is OK to make an unreduced Scalar here. We\n        // note that fixed-base multiplication is also defined for all values of `bytes` less than\n        // 2^255.\n        let s = Scalar {\n            bytes: clamp_integer(bytes),\n        };\n        Self::mul_base(&s)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/fmt",
                "content": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/step_1",
                  "/curve25519-dalek/src/edwards.rs/step_2"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"EdwardsPoint{{\\n\\tX: {:?},\\n\\tY: {:?},\\n\\tZ: {:?},\\n\\tT: {:?}\\n}}\",\n            &self.X, &self.Y, &self.Z, &self.T\n        )\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/mul",
                "content": "    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/backend/mod.rs/variable_base_mul"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    fn mul(self, scalar: &'a Scalar) -> EdwardsPoint {\n        crate::backend::variable_base_mul(self, scalar)\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/as_projective_niels",
                "content": "    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) fn as_projective_niels(&self) -> ProjectiveNielsPoint {\n        ProjectiveNielsPoint {\n            Y_plus_X: &self.Y + &self.X,\n            Y_minus_X: &self.Y - &self.X,\n            Z: self.Z,\n            T2d: &self.T * &constants::EDWARDS_D2,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/decompress",
                "content": "    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }",
                "dependencies": [
                  "/curve25519-dalek/src/edwards.rs/step_1",
                  "/curve25519-dalek/src/edwards.rs/step_2"
                ],
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub fn decompress(&self) -> Option<EdwardsPoint> {\n        let (is_valid_y_coord, X, Y, Z) = decompress::step_1(self);\n\n        if is_valid_y_coord.into() {\n            Some(decompress::step_2(self, X, Y, Z))\n        } else {\n            None\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              },
              {
                "identifier": "curve25519-dalek/src/edwards.rs/as_projective",
                "content": "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }",
                "code_name": "constants.rs",
                "children": [],
                "file_type": "file",
                "status_id": 3,
                "snippets": [
                  {
                    "sortorder": 0,
                    "text": "    pub(crate) const fn as_projective(&self) -> ProjectivePoint {\n        ProjectivePoint {\n            X: self.X,\n            Y: self.Y,\n            Z: self.Z,\n        }\n    }",
                    "type_id": 2
                  }
                ],
                "specified": false
              }
            ],
            "file_type": "folder",
            "specified": false
          }
        ],
        "file_type": "folder",
        "specified": false
      },
      {
        "identifier": "curve25519-dalek/build.rs",
        "content": "",
        "code_name": "",
        "children": [
          {
            "identifier": "curve25519-dalek/build.rs/fmt",
            "content": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }",
            "code_name": "constants.rs",
            "children": [],
            "file_type": "file",
            "status_id": 3,
            "snippets": [
              {
                "sortorder": 0,
                "text": "    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {\n        let w_bits = match self {\n            DalekBits::Dalek32 => \"32\",\n            DalekBits::Dalek64 => \"64\",\n        };\n        write!(f, \"{}\", w_bits)\n    }",
                "type_id": 2
              }
            ],
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/build.rs/determine_curve25519_dalek_bits_warning",
            "content": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
            "code_name": "constants.rs",
            "children": [],
            "file_type": "file",
            "status_id": 3,
            "snippets": [
              {
                "sortorder": 0,
                "text": "    fn determine_curve25519_dalek_bits_warning(cause: &str) {\n        println!(\"cargo:warning=\\\"Defaulting to curve25519_dalek_bits=32: {cause}\\\"\");\n    }",
                "type_id": 2
              }
            ],
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/build.rs/determine_curve25519_dalek_bits",
            "content": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
            "dependencies": [
              "/curve25519-dalek/build.rs/determine_curve25519_dalek_bits_warning"
            ],
            "code_name": "constants.rs",
            "children": [],
            "file_type": "file",
            "status_id": 3,
            "snippets": [
              {
                "sortorder": 0,
                "text": "    pub(super) fn determine_curve25519_dalek_bits(target_arch: &String) -> DalekBits {\n        let target_pointer_width = match std::env::var(\"CARGO_CFG_TARGET_POINTER_WIDTH\") {\n            Ok(pw) => pw,\n            Err(_) => {\n                determine_curve25519_dalek_bits_warning(ERR_MSG_NO_POINTER_WIDTH);\n                return DalekBits::Dalek32;\n            }\n        };\n\n        #[allow(clippy::match_single_binding)]\n        match &target_arch {\n            //Issues: 449 and 456\n            //TODO: When adding arch defaults use proper types not String match\n            //TODO(Arm): Needs tests + benchmarks to back this up\n            //TODO(Wasm32): Needs tests + benchmarks to back this up\n            _ => match target_pointer_width.as_ref() {\n                \"64\" => DalekBits::Dalek64,\n                \"32\" => DalekBits::Dalek32,\n                // Intended default solely for non-32/64 target pointer widths\n                // Otherwise known target platforms only.\n                _ => {\n                    determine_curve25519_dalek_bits_warning(ERR_MSG_UNKNOWN_POINTER_WIDTH);\n                    DalekBits::Dalek32\n                }\n            },\n        }\n    }",
                "type_id": 2
              }
            ],
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/build.rs/is_capable_simd",
            "content": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
            "code_name": "constants.rs",
            "children": [],
            "file_type": "file",
            "status_id": 3,
            "snippets": [
              {
                "sortorder": 0,
                "text": "fn is_capable_simd(arch: &str, bits: DalekBits) -> bool {\n    arch == \"x86_64\" && bits == DalekBits::Dalek64\n}",
                "type_id": 2
              }
            ],
            "specified": false
          },
          {
            "identifier": "curve25519-dalek/build.rs/main",
            "content": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
            "dependencies": [
              "/curve25519-dalek/build.rs/is_capable_simd",
              "/curve25519-dalek/build.rs/determine_curve25519_dalek_bits"
            ],
            "code_name": "constants.rs",
            "children": [],
            "file_type": "file",
            "status_id": 3,
            "snippets": [
              {
                "sortorder": 0,
                "text": "fn main() {\n    let target_arch = match std::env::var(\"CARGO_CFG_TARGET_ARCH\") {\n        Ok(arch) => arch,\n        _ => \"\".to_string(),\n    };\n\n    let curve25519_dalek_bits = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BITS\").as_deref() {\n        Ok(\"32\") => DalekBits::Dalek32,\n        Ok(\"64\") => DalekBits::Dalek64,\n        _ => deterministic::determine_curve25519_dalek_bits(&target_arch),\n    };\n\n    println!(\"cargo:rustc-cfg=curve25519_dalek_bits=\\\"{curve25519_dalek_bits}\\\"\");\n\n    let nightly = if rustc_version::version_meta()\n        .expect(\"failed to detect rustc version\")\n        .channel\n        == rustc_version::Channel::Nightly\n    {\n        println!(\"cargo:rustc-cfg=nightly\");\n        true\n    } else {\n        false\n    };\n\n    let rustc_version = rustc_version::version().expect(\"failed to detect rustc version\");\n    if rustc_version.major == 1 && rustc_version.minor <= 64 {\n        // Old versions of Rust complain when you have an `unsafe fn` and you use `unsafe {}` inside,\n        // so for those we want to apply the `#[allow(unused_unsafe)]` attribute to get rid of that warning.\n        println!(\"cargo:rustc-cfg=allow_unused_unsafe\");\n    }\n\n    // Backend overrides / defaults\n    let curve25519_dalek_backend = match std::env::var(\"CARGO_CFG_CURVE25519_DALEK_BACKEND\")\n        .as_deref()\n    {\n        Ok(\"fiat\") => \"fiat\",\n        Ok(\"serial\") => \"serial\",\n        Ok(\"simd\") => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => \"simd\",\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to simd\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if nightly => {\n            // simd can only be enabled on x86_64 & 64bit target_pointer_width\n            match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n                true => {\n                    // In addition enable Avx2 fallback through simd stable backend\n                    // NOTE: Compiler permits duplicate / multi value on the same key\n                    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"simd\\\"\");\n\n                    \"unstable_avx512\"\n                }\n                // If override is not possible this must result to compile error\n                // See: issues/532\n                false => panic!(\"Could not override curve25519_dalek_backend to unstable_avx512\"),\n            }\n        }\n        Ok(\"unstable_avx512\") if !nightly => {\n            panic!(\n                \"Could not override curve25519_dalek_backend to unstable_avx512, as this is nightly only\"\n            );\n        }\n        // default between serial / simd (if potentially capable)\n        _ => match is_capable_simd(&target_arch, curve25519_dalek_bits) {\n            true => \"simd\",\n            false => \"serial\",\n        },\n    };\n    println!(\"cargo:rustc-cfg=curve25519_dalek_backend=\\\"{curve25519_dalek_backend}\\\"\");\n}",
                "type_id": 2
              }
            ],
            "specified": false
          }
        ],
        "file_type": "folder",
        "specified": false
      }
    ],
    "file_type": "folder",
    "specified": false
  }
]