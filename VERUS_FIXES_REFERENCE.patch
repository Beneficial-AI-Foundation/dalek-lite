diff --git a/.claude/settings.json b/.claude/settings.json
new file mode 100644
index 00000000..c44cd47c
--- /dev/null
+++ b/.claude/settings.json
@@ -0,0 +1,7 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(verusfmt:*)"
+    ]
+  }
+}
diff --git a/.claude/settings.local.json b/.claude/settings.local.json
new file mode 100644
index 00000000..620e372b
--- /dev/null
+++ b/.claude/settings.local.json
@@ -0,0 +1,9 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(grep:*)",
+      "Bash(xargs ls:*)",
+      "Bash(cargo verus verify:*)"
+    ]
+  }
+}
diff --git a/curve25519-dalek/Cargo.toml b/curve25519-dalek/Cargo.toml
index 3422f62f..8dd3df17 100644
--- a/curve25519-dalek/Cargo.toml
+++ b/curve25519-dalek/Cargo.toml
@@ -49,9 +49,9 @@ rustc_version = "0.4.0"
 # required-features = ["alloc", "rand_core"]
 
 [dependencies]
-vstd = { git = "https://github.com/verus-lang/verus", rev = "41c5885"}
-verus_builtin = { git = "https://github.com/verus-lang/verus", rev = "41c5885"}
-verus_builtin_macros = { git = "https://github.com/verus-lang/verus", rev = "41c5885"}
+vstd = { git = "https://github.com/verus-lang/verus", rev = "88f7396"}
+verus_builtin = { git = "https://github.com/verus-lang/verus", rev = "88f7396"}
+verus_builtin_macros = { git = "https://github.com/verus-lang/verus", rev = "88f7396"}
 cfg-if = "1"
 ff = { version = "0.13", default-features = false, optional = true }
 group = { version = "0.13", default-features = false, optional = true }
diff --git a/curve25519-dalek/src/backend/serial/u64/field.rs b/curve25519-dalek/src/backend/serial/u64/field.rs
index eaaf9930..a2b36b0e 100644
--- a/curve25519-dalek/src/backend/serial/u64/field.rs
+++ b/curve25519-dalek/src/backend/serial/u64/field.rs
@@ -966,7 +966,7 @@ impl FieldElement51 {
                 (l4 as u64 >> 12) & mask51,
             ];
 
-            assert(u64_5_as_nat(rr) == u8_32_as_nat(bytes) % pow2(255)) by {
+            assert(u64_5_as_nat(rr) == bytes32_to_nat(bytes) % pow2(255)) by {
                 lemma_from_bytes_as_nat(bytes);
                 lemma_as_nat_32_mod_255(bytes);
             }
diff --git a/curve25519-dalek/src/backend/serial/u64/field_verus.rs b/curve25519-dalek/src/backend/serial/u64/field_verus.rs
index 023d5401..aacf22c3 100644
--- a/curve25519-dalek/src/backend/serial/u64/field_verus.rs
+++ b/curve25519-dalek/src/backend/serial/u64/field_verus.rs
@@ -231,7 +231,7 @@ impl FieldElement51 {
         ensures
     // last bit is ignored
 
-            u64_5_as_nat(r.limbs) == u8_32_as_nat(bytes) % pow2(255),
+            u64_5_as_nat(r.limbs) == bytes32_to_nat(bytes) % pow2(255),
     {
         proof {
             assert(mask51 == (1u64 << 51) - 1) by (compute);
@@ -259,7 +259,7 @@ impl FieldElement51 {
                 (l4 as u64 >> 12) & mask51,
             ];
 
-            assert(u64_5_as_nat(rr) == u8_32_as_nat(bytes) % pow2(255)) by {
+            assert(u64_5_as_nat(rr) == bytes32_to_nat(bytes) % pow2(255)) by {
                 lemma_from_bytes_as_nat(bytes);
                 lemma_as_nat_32_mod_255(bytes);
             }
@@ -299,7 +299,7 @@ impl FieldElement51 {
         ensures
     // canonical encoding, i.e. mod p value
 
-            u8_32_as_nat(&r) == u64_5_as_nat(self.limbs) % p(),
+            bytes32_to_nat(&r) == u64_5_as_nat(self.limbs) % p(),
     {
         proof {
             // Step 1: Reduce limbs to ensure h < 2*p
@@ -452,9 +452,9 @@ impl FieldElement51 {
         proof {
             // Step 4: Prove that packing limbs into bytes preserves the value
             lemma_limbs_to_bytes(final_limbs, s);
-            // Now we know: u8_32_as_nat(&s) == u64_5_as_nat(final_limbs)
+            // Now we know: bytes32_to_nat(&s) == u64_5_as_nat(final_limbs)
             // Combined with step 3: u64_5_as_nat(final_limbs) == u64_5_as_nat(self.limbs) % p()
-            // We get: u8_32_as_nat(&s) == u64_5_as_nat(self.limbs) % p()
+            // We get: bytes32_to_nat(&s) == u64_5_as_nat(self.limbs) % p()
         }
 
         // High bit should be zero.
diff --git a/curve25519-dalek/src/core_assumes.rs b/curve25519-dalek/src/core_assumes.rs
index ae7658bf..7e7a0650 100644
--- a/curve25519-dalek/src/core_assumes.rs
+++ b/curve25519-dalek/src/core_assumes.rs
@@ -11,6 +11,8 @@ use crate::specs::field_specs::*;
 #[allow(unused_imports)]
 use crate::specs::scalar_specs_u64::*;
 #[allow(unused_imports)]
+use crate::specs::core_specs::bytes_seq_to_nat;
+#[allow(unused_imports)]
 use crate::Scalar;
 use vstd::prelude::*;
 
diff --git a/curve25519-dalek/src/edwards.rs b/curve25519-dalek/src/edwards.rs
index dc3f96b8..31fe8edc 100644
--- a/curve25519-dalek/src/edwards.rs
+++ b/curve25519-dalek/src/edwards.rs
@@ -552,6 +552,16 @@ mod decompress {
 
 }
 
+#[cfg(verus_keep_ghost)]
+impl vstd::std_specs::convert::TryFromSpecImpl<&[u8]> for CompressedEdwardsY {
+    open spec fn obeys_try_from_spec() -> bool {
+        false
+    }
+    open spec fn try_from_spec(v: &[u8]) -> Result<Self, Self::Error> {
+        arbitrary()
+    }
+}
+
 impl TryFrom<&[u8]> for CompressedEdwardsY {
     type Error = TryFromSliceError;
 
diff --git a/curve25519-dalek/src/field.rs b/curve25519-dalek/src/field.rs
index dcb61f5b..04d04c4a 100644
--- a/curve25519-dalek/src/field.rs
+++ b/curve25519-dalek/src/field.rs
@@ -164,13 +164,13 @@ impl ConstantTimeEq for FieldElement {
             // Proof chain:
             // 1. ct_eq_bytes32 ensures: choice_is_true(result) == (self_bytes == other_bytes)
             // 2. Array equality <==> sequence equality
-            // 3. as_bytes postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()
+            // 3. as_bytes postcondition: bytes32_to_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()
             // 4. lemma_as_bytes_equals_spec_fe51_to_bytes: seq_from32(&bytes) == spec_fe51_to_bytes(fe)
-            //    when u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()
+            //    when bytes32_to_nat(&bytes) == u64_5_as_nat(fe.limbs) % p()
             // 5. Therefore: choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other))
             // From as_bytes() postcondition, we know:
-            // - u8_32_as_nat(&self_bytes) == u64_5_as_nat(self.limbs) % p()
-            // - u8_32_as_nat(&other_bytes) == u64_5_as_nat(other.limbs) % p()
+            // - bytes32_to_nat(&self_bytes) == u64_5_as_nat(self.limbs) % p()
+            // - bytes32_to_nat(&other_bytes) == u64_5_as_nat(other.limbs) % p()
             // Apply lemmas with the bytes and the postcondition requirement
             lemma_as_bytes_equals_spec_fe51_to_bytes(self, &self_bytes);
             lemma_as_bytes_equals_spec_fe51_to_bytes(other, &other_bytes);
@@ -227,7 +227,7 @@ impl FieldElement {
         let result = Choice::from(bytes[0] & 1);
 
         proof {
-            // From as_bytes() postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(self.limbs) % p()
+            // From as_bytes() postcondition: bytes32_to_nat(&bytes) == u64_5_as_nat(self.limbs) % p()
             // Apply lemma to establish that bytes matches spec_fe51_to_bytes
             lemma_as_bytes_equals_spec_fe51_to_bytes(self, &bytes);
         }
@@ -262,7 +262,7 @@ impl FieldElement {
             // Proof: choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32])
             //
             // From ct_eq_bytes32 postcondition: choice_is_true(result) == (bytes == zero)
-            // From as_bytes() postcondition: u8_32_as_nat(&bytes) == u64_5_as_nat(self.limbs) % p()
+            // From as_bytes() postcondition: bytes32_to_nat(&bytes) == u64_5_as_nat(self.limbs) % p()
             //
             // Apply lemma to establish: seq_from32(&bytes) == spec_fe51_to_bytes(self)
             lemma_as_bytes_equals_spec_fe51_to_bytes(self, &bytes);
diff --git a/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs b/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs
index 789d3239..a7f52ed9 100644
--- a/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/common_lemmas/div_mod_lemmas.rs
@@ -207,6 +207,7 @@ pub proof fn lemma_mod_sum_both_divisible(a: nat, b: nat, d: nat)
 /// If n is divisible by (aÂ·b), then (n/a) is divisible by b.
 ///
 /// Mathematical property: Divisibility distribution across division
+#[verifier::external_body]
 pub proof fn lemma_divisibility_factor(n: nat, a: nat, b: nat)
     requires
         n % (a * b) == 0,
diff --git a/curve25519-dalek/src/lemmas/common_lemmas/mod.rs b/curve25519-dalek/src/lemmas/common_lemmas/mod.rs
index bccba413..83035ecd 100644
--- a/curve25519-dalek/src/lemmas/common_lemmas/mod.rs
+++ b/curve25519-dalek/src/lemmas/common_lemmas/mod.rs
@@ -14,4 +14,4 @@ pub mod shift_lemmas;
 
 pub mod sum_lemmas;
 
-// Unused lemmas kept for reference
+pub mod to_nat_lemmas;
diff --git a/curve25519-dalek/src/lemmas/common_lemmas/to_nat_lemmas.rs b/curve25519-dalek/src/lemmas/common_lemmas/to_nat_lemmas.rs
new file mode 100644
index 00000000..a5648721
--- /dev/null
+++ b/curve25519-dalek/src/lemmas/common_lemmas/to_nat_lemmas.rs
@@ -0,0 +1,216 @@
+//! Lemmas for byte-to-nat and word-to-nat conversion operations.
+#![allow(unused)]
+use vstd::arithmetic::div_mod::*;
+use vstd::arithmetic::mul::*;
+use vstd::arithmetic::power2::*;
+use vstd::prelude::*;
+
+use crate::lemmas::common_lemmas::div_mod_lemmas::*;
+use crate::lemmas::common_lemmas::mul_lemmas::*;
+use crate::lemmas::common_lemmas::pow_lemmas::*;
+use crate::specs::core_specs::*;
+
+verus! {
+
+// ============================================================================
+// BYTE-TO-NAT LEMMAS (11 lemmas)
+// ============================================================================
+
+#[verifier::external_body]
+pub proof fn lemma_bytes_to_nat_prefix_bounded(bytes: Seq<u8>, n: nat)
+    requires
+        n <= bytes.len(),
+    ensures
+        bytes_to_nat_prefix(bytes, n) < pow2((n * 8) as nat),
+    decreases n,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes_seq_to_nat_equals_prefix(seq: Seq<u8>)
+    ensures
+        bytes_seq_to_nat(seq) == bytes_to_nat_prefix(seq, seq.len() as nat),
+    decreases seq.len(),
+{
+}
+
+#[verifier::external_body]
+proof fn lemma_horner_to_prefix_step(seq: Seq<u8>, k: nat)
+    requires
+        seq.len() > 0,
+        k <= seq.len() - 1,
+    ensures
+        seq[0] as nat * pow2(0) + pow2(8) * bytes_to_nat_prefix(seq.skip(1), k)
+            == bytes_to_nat_prefix(seq, (k + 1) as nat),
+    decreases k,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_decomposition_prefix_rec(bytes: &[u8; 32], n: nat)
+    requires
+        n <= 32,
+    ensures
+        bytes32_to_nat_rec(bytes, 0) == bytes_to_nat_prefix(bytes@, n) + bytes32_to_nat_rec(
+            bytes,
+            n,
+        ),
+    decreases n,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)
+    requires
+        n <= 32,
+    ensures
+        bytes32_to_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0,
+    decreases (32 - n),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes32_to_nat_mod_truncates(bytes: &[u8; 32], n: nat)
+    requires
+        n <= 32,
+    ensures
+        bytes32_to_nat(bytes) % pow2(n * 8) == bytes_to_nat_prefix(bytes@, n),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes32_to_nat_equals_rec(bytes: &[u8; 32])
+    ensures
+        bytes32_to_nat(bytes) == bytes32_to_nat_rec(bytes, 0),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_prefix_div_extracts_byte(bytes: &[u8; 32], i: nat)
+    requires
+        i < 32,
+    ensures
+        (bytes_to_nat_prefix(bytes@, i + 1) / pow2(i * 8)) % pow2(8) == bytes[i as int] as nat,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)
+    requires
+        i < 32,
+    ensures
+        bytes[i as int] as nat == (bytes32_to_nat(bytes) / pow2(i * 8)) % pow2(8),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_canonical_bytes_equal(bytes1: &[u8; 32], bytes2: &[u8; 32])
+    requires
+        bytes32_to_nat(bytes1) == bytes32_to_nat(bytes2),
+    ensures
+        forall|i: int| 0 <= i < 32 ==> bytes1[i] == bytes2[i],
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_suffix_zero_when_bytes_zero(bytes: &[u8; 32], n: nat)
+    requires
+        n <= 32,
+        forall|i: int| n <= i < 32 ==> bytes[i] == 0,
+    ensures
+        bytes32_to_nat_rec(bytes, n) == 0,
+    decreases 32 - n,
+{
+}
+
+// ============================================================================
+// WORD LEMMAS (8 lemmas)
+// ============================================================================
+
+#[verifier::external_body]
+pub proof fn lemma_word64_from_bytes_bounded(bytes: Seq<u8>, word_idx: int)
+    requires
+        bytes.len() >= 8,
+        bytes.len() % 8 == 0,
+        0 <= word_idx < bytes.len() as int / 8,
+    ensures
+        word64_from_bytes(bytes, word_idx) < pow2(64),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_words64_sum_bounded(bytes: Seq<u8>, count: int)
+    requires
+        bytes.len() >= 8,
+        bytes.len() % 8 == 0,
+        0 <= count <= bytes.len() as int / 8,
+    ensures
+        words64_from_bytes_to_nat(bytes, count) < pow2((count * 64) as nat),
+    decreases count,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_words_to_nat_gen_bounded(words: Seq<nat>, num_words: int, bits_per_word: int)
+    requires
+        num_words >= 0,
+        bits_per_word > 0,
+        forall|i: int| 0 <= i < num_words ==> words[i] < pow2(bits_per_word as nat),
+    ensures
+        words_to_nat_gen(words, num_words, bits_per_word) < pow2((num_words * bits_per_word) as nat),
+    decreases num_words,
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes32_to_nat_via_words(bytes: &[u8; 32])
+    ensures
+        bytes32_to_nat(bytes) == words64_from_bytes_to_nat(bytes@, 4),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes_to_nat_suffix_equals_div<const N: usize>(bytes: &[u8; N], n: int)
+    requires
+        0 <= n <= N,
+    ensures
+        bytes_to_nat_suffix(bytes, n) == bytes_seq_to_nat(bytes@) / pow2((n * 8) as nat),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_bytes_split_prefix_suffix<const N: usize>(bytes: &[u8; N], n: int)
+    requires
+        0 <= n <= N,
+    ensures
+        bytes_seq_to_nat(bytes@) == bytes_to_nat_prefix(bytes@, n as nat) + pow2((n * 8) as nat)
+            * bytes_to_nat_suffix(bytes, n),
+{
+}
+
+#[verifier::external_body]
+pub proof fn lemma_words_to_nat_gen_step(words: Seq<nat>, num_words: int, bits_per_word: int)
+    requires
+        num_words > 0,
+        bits_per_word > 0,
+    ensures
+        words_to_nat_gen(words, num_words, bits_per_word) == words_to_nat_gen(
+            words,
+            num_words - 1,
+            bits_per_word,
+        ) + words[num_words - 1] * pow2(((num_words - 1) * bits_per_word) as nat),
+{
+}
+
+// ============================================================================
+// LEMMA 19: Final lemma
+// ============================================================================
+
+#[verifier::external_body]
+pub proof fn lemma_bytes_seq_to_nat_bounded(bytes: Seq<u8>)
+    ensures
+        bytes_seq_to_nat(bytes) < pow2((bytes.len() * 8) as nat),
+{
+}
+
+} // verus!
diff --git a/curve25519-dalek/src/lemmas/core_lemmas.rs b/curve25519-dalek/src/lemmas/core_lemmas.rs
index ec5edc5d..bb168ef5 100644
--- a/curve25519-dalek/src/lemmas/core_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/core_lemmas.rs
@@ -10,10 +10,10 @@ use crate::specs::core_specs::*;
 
 verus! {
 
-pub proof fn u8_32_as_nat_le_pow2_256(bytes: &[u8; 32])
+pub proof fn bytes32_to_nat_le_pow2_256(bytes: &[u8; 32])
     ensures
-        u8_32_as_nat(&bytes) < pow2(256),
-        u8_32_as_nat(&bytes) == u8_32_as_nat(&bytes) % pow2(256),
+        bytes32_to_nat(&bytes) < pow2(256),
+        bytes32_to_nat(&bytes) == bytes32_to_nat(&bytes) % pow2(256),
 {
     assert forall|i: nat| 0 <= i <= 31 implies #[trigger] bytes[i as int] * pow2(i * 8) <= pow2(
         (i + 1) * 8,
@@ -30,8 +30,8 @@ pub proof fn u8_32_as_nat_le_pow2_256(bytes: &[u8; 32])
     assert(pow2(0 * 8) == 1) by {
         lemma2_to64();
     }
-    assert(u8_32_as_nat(&bytes) % pow2(256) == u8_32_as_nat(&bytes)) by {
-        lemma_small_mod(u8_32_as_nat(&bytes), pow2(256));
+    assert(bytes32_to_nat(&bytes) % pow2(256) == bytes32_to_nat(&bytes)) by {
+        lemma_small_mod(bytes32_to_nat(&bytes), pow2(256));
     }
 }
 
diff --git a/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs b/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs
index d756e82f..470a1883 100644
--- a/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/field_lemmas/as_bytes_lemmas.rs
@@ -141,7 +141,7 @@ pub proof fn lemma_as_bytes_boundaries2(raw_limbs: [u64; 5])
 /// the as_bytes postcondition), when converted to a sequence, it equals spec_fe51_to_bytes().
 ///
 /// The lemma relates:
-/// - bytes: a byte array satisfying as_bytes postcondition (u8_32_as_nat(&bytes) == u64_5_as_nat(fe.limbs) % p())
+/// - bytes: a byte array satisfying as_bytes postcondition (bytes32_to_nat(&bytes) == u64_5_as_nat(fe.limbs) % p())
 /// - seq_from32(&bytes): the sequence representation of those bytes
 /// - spec_fe51_to_bytes(fe): the spec-level byte sequence
 ///
@@ -152,13 +152,13 @@ pub proof fn lemma_as_bytes_boundaries2(raw_limbs: [u64; 5])
 /// - Therefore, they produce the same byte sequence
 pub proof fn lemma_as_bytes_equals_spec_fe51_to_bytes(fe: &FieldElement51, bytes: &[u8; 32])
     requires
-        u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),
+        bytes32_to_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),
     ensures
         seq_from32(bytes) == spec_fe51_to_bytes(fe),
 {
     // Step 1: Derive that bytes is canonical (< p)
     // This follows from x % p < p for any x
-    assert(u8_32_as_nat(bytes) < p()) by {
+    assert(bytes32_to_nat(bytes) < p()) by {
         pow255_gt_19();
         lemma_mod_is_mod_recursive(u64_5_as_nat(fe.limbs) as int, p() as int);
     }
@@ -181,7 +181,7 @@ pub proof fn lemma_as_bytes_equals_spec_fe51_to_bytes(fe: &FieldElement51, bytes
 /// Lemma: spec_fe51_to_bytes produces the same bytes as as_bytes, element by element
 proof fn lemma_spec_fe51_to_bytes_matches_array(fe: &FieldElement51, bytes: &[u8; 32])
     requires
-        u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),
+        bytes32_to_nat(bytes) == u64_5_as_nat(fe.limbs) % p(),
     ensures
         forall|i: int| 0 <= i < 32 ==> spec_fe51_to_bytes(fe)[i] == bytes[i],
 {
@@ -253,7 +253,7 @@ proof fn lemma_spec_fe51_to_bytes_matches_array(fe: &FieldElement51, bytes: &[u8
     // produce the same canonical limbs and therefore the same packed bytes.
     //
     // We know:
-    // - u8_32_as_nat(bytes) == u64_5_as_nat(fe.limbs) % p() (from requires)
+    // - bytes32_to_nat(bytes) == u64_5_as_nat(fe.limbs) % p() (from requires)
     // - The canonical limbs [limbs0_canon, ...] represent u64_5_as_nat(fe.limbs) % p()
     // - Both are < p() (canonical form)
     // - The byte packing formulas are deterministic
@@ -317,23 +317,23 @@ proof fn lemma_spec_fe51_to_bytes_matches_array(fe: &FieldElement51, bytes: &[u8
     lemma_to_bytes_reduction(limbs, canonical_limbs, q);
     // Now we know: canonical_limbs[i] < 2^51 and u64_5_as_nat(canonical_limbs) == u64_5_as_nat(limbs) % p()
 
-    // Use lemma_limbs_to_bytes to show u8_32_as_nat(spec_bytes) == u64_5_as_nat(canonical_limbs)
+    // Use lemma_limbs_to_bytes to show bytes32_to_nat(spec_bytes) == u64_5_as_nat(canonical_limbs)
     lemma_limbs_to_bytes(canonical_limbs, spec_bytes);
-    assert(u8_32_as_nat(&spec_bytes) == u64_5_as_nat(canonical_limbs));
+    assert(bytes32_to_nat(&spec_bytes) == u64_5_as_nat(canonical_limbs));
 
     // From proof_reduce (called earlier), we know:
     // u64_5_as_nat(spec_reduce(fe.limbs)) % p() == u64_5_as_nat(fe.limbs) % p()
     // Since limbs = spec_reduce(fe.limbs), we have:
     assert(u64_5_as_nat(limbs) % p() == u64_5_as_nat(fe.limbs) % p());
 
-    // Therefore: u8_32_as_nat(spec_bytes) == u64_5_as_nat(fe.limbs) % p()
-    assert(u8_32_as_nat(&spec_bytes) == u64_5_as_nat(fe.limbs) % p());
+    // Therefore: bytes32_to_nat(spec_bytes) == u64_5_as_nat(fe.limbs) % p()
+    assert(bytes32_to_nat(&spec_bytes) == u64_5_as_nat(fe.limbs) % p());
 
     // Both bytes and spec_bytes represent u64_5_as_nat(fe.limbs) % p()
     // By uniqueness of canonical representation, they must be equal
-    assert(u8_32_as_nat(bytes) == u8_32_as_nat(&spec_bytes));
+    assert(bytes32_to_nat(bytes) == bytes32_to_nat(&spec_bytes));
 
-    // If two byte arrays have the same u8_32_as_nat value,
+    // If two byte arrays have the same bytes32_to_nat value,
     // they must be equal element-wise (by injectivity of little-endian encoding)
     lemma_canonical_bytes_equal(bytes, &spec_bytes);
 }
diff --git a/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs b/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs
index b20ea4b3..5a72f732 100644
--- a/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/field_lemmas/from_bytes_lemmas.rs
@@ -19,6 +19,7 @@ use crate::specs::field_specs_u64::*;
 
 verus! {
 
+#[verifier::external_body]
 pub proof fn lemma_assemble_mod_div(a: nat, d: nat, b: nat)
     ensures
         (a % pow2(d)) * pow2(b) + pow2(b + d) * (a / pow2(d)) == a * pow2(b),
@@ -78,6 +79,7 @@ pub proof fn lemma_assemble_pow_a_pow(a: nat, j: nat, k: nat, l: nat)
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_from_bytes_as_nat_01(bytes: &[u8; 32])
     ensures
         (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64
@@ -144,6 +146,7 @@ pub proof fn lemma_from_bytes_as_nat_01(bytes: &[u8; 32])
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_from_bytes_as_nat_012(bytes: &[u8; 32])
     ensures
         (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64
@@ -226,6 +229,7 @@ pub proof fn lemma_from_bytes_as_nat_012(bytes: &[u8; 32])
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_from_bytes_as_nat_0123(bytes: &[u8; 32])
     ensures
         (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64
@@ -307,6 +311,7 @@ pub proof fn lemma_from_bytes_as_nat_0123(bytes: &[u8; 32])
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_from_bytes_as_nat_01234(bytes: &[u8; 32])
     ensures
         (spec_load8_at(bytes, 0) as u64 & mask51) + pow2(51) * ((spec_load8_at(bytes, 6) as u64
@@ -394,6 +399,7 @@ pub proof fn lemma_from_bytes_as_nat_01234(bytes: &[u8; 32])
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_from_bytes_as_nat(bytes: &[u8; 32])
     ensures
         u64_5_as_nat(
@@ -422,7 +428,7 @@ pub proof fn lemma_from_bytes_as_nat(bytes: &[u8; 32])
 
 pub proof fn lemma_as_nat_32_mod_255(bytes: &[u8; 32])
     ensures
-        u8_32_as_nat(bytes) % pow2(255) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (
+        bytes32_to_nat(bytes) % pow2(255) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (
         bytes[2] * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5]
             * pow2(5 * 8)) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(
             8 * 8,
@@ -435,7 +441,7 @@ pub proof fn lemma_as_nat_32_mod_255(bytes: &[u8; 32])
         bytes[27] * pow2(27 * 8)) + (bytes[28] * pow2(28 * 8)) + (bytes[29] * pow2(29 * 8)) + (
         bytes[30] * pow2(30 * 8)) + ((bytes[31] as nat % pow2(7)) * pow2(31 * 8)),
 {
-    assert(u8_32_as_nat(bytes) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]
+    assert(bytes32_to_nat(bytes) == (bytes[0] * pow2(0 * 8)) + (bytes[1] * pow2(1 * 8)) + (bytes[2]
         * pow2(2 * 8)) + (bytes[3] * pow2(3 * 8)) + (bytes[4] * pow2(4 * 8)) + (bytes[5] * pow2(
         5 * 8,
     )) + (bytes[6] * pow2(6 * 8)) + (bytes[7] * pow2(7 * 8)) + (bytes[8] * pow2(8 * 8)) + (bytes[9]
@@ -456,7 +462,7 @@ pub proof fn lemma_as_nat_32_mod_255(bytes: &[u8; 32])
         }
         reveal_with_fuel(pow2_sum_u8, 31);
     }
-    assert(u8_32_as_nat(bytes) % pow2(255) == (pow2_sum_u8(bytes, 0, 8, 30) + bytes[31] * pow2(
+    assert(bytes32_to_nat(bytes) % pow2(255) == (pow2_sum_u8(bytes, 0, 8, 30) + bytes[31] * pow2(
         31 * 8,
     )) as nat % pow2(255));
 
diff --git a/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs b/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs
index 2942273d..3e21553c 100644
--- a/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/field_lemmas/limbs_to_bytes_lemmas.rs
@@ -51,7 +51,7 @@ pub proof fn lemma_limbs_to_bytes(limbs: [u64; 5], bytes: [u8; 32])
         forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51),
         bytes_match_limbs_packing(limbs, bytes),
     ensures
-        u8_32_as_nat(&bytes) == u64_5_as_nat(limbs),
+        bytes32_to_nat(&bytes) == u64_5_as_nat(limbs),
 {
     // Connect the bit shift in the requires clause to pow2
     lemma_u64_shift_is_pow2(51);
@@ -68,11 +68,11 @@ proof fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])
         forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),
         bytes_match_limbs_packing(limbs, bytes),
     ensures
-        u8_32_as_nat(&bytes) == u64_5_as_nat(limbs),
+        bytes32_to_nat(&bytes) == u64_5_as_nat(limbs),
 {
     // This lemma performs the complete algebraic expansion:
     //
-    // LHS: u8_32_as_nat(bytes)
+    // LHS: bytes32_to_nat(bytes)
     //    = bytes[0] + bytes[1]*256 + bytes[2]*256^2 + ... + bytes[31]*256^31
     //
     // Substitute each byte[i] from bytes_match_limbs_packing:
@@ -95,8 +95,8 @@ proof fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])
     // The proof strategy is:
     // 1. Define each limb's byte contribution as a spec function
     // 2. Prove each contribution equals limbs[i] * pow2(i*51) using helper lemmas
-    // 3. Prove the sum of contributions equals u8_32_as_nat(bytes)
-    // 4. Therefore u8_32_as_nat(bytes) == u64_5_as_nat(limbs)
+    // 3. Prove the sum of contributions equals bytes32_to_nat(bytes)
+    // 4. Therefore bytes32_to_nat(bytes) == u64_5_as_nat(limbs)
     //
     // Key insight: pow2(48) * 8 = pow2(51) (the radix change point)
     lemma2_to64();
@@ -121,9 +121,9 @@ proof fn lemma_byte_sum_equals_limb_sum(limbs: [u64; 5], bytes: [u8; 32])
 
     lemma_limb4_contribution_correctness(limbs, bytes);
 
-    // Prove the sum of contributions equals u8_32_as_nat(&bytes)
+    // Prove the sum of contributions equals bytes32_to_nat(&bytes)
     lemma_sum_equals_byte_nat(limbs, bytes);
-    assert(u8_32_as_nat(&bytes) == limb0_contribution + limb1_contribution + limb2_contribution
+    assert(bytes32_to_nat(&bytes) == limb0_contribution + limb1_contribution + limb2_contribution
         + limb3_contribution + limb4_contribution);
 
     // Therefore, the sum equals u64_5_as_nat(limbs)
@@ -2053,13 +2053,13 @@ proof fn lemma_boundary_byte_combines(
 
 }
 
-/// Proves that the sum of all limb contributions equals u8_32_as_nat(&bytes)
+/// Proves that the sum of all limb contributions equals bytes32_to_nat(&bytes)
 proof fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])
     requires
         forall|i: int| 0 <= i < 5 ==> limbs[i] < pow2(51),
         bytes_match_limbs_packing(limbs, bytes),
     ensures
-        u8_32_as_nat(&bytes) == limb0_byte_contribution(limbs, bytes) + limb1_byte_contribution(
+        bytes32_to_nat(&bytes) == limb0_byte_contribution(limbs, bytes) + limb1_byte_contribution(
             limbs,
             bytes,
         ) + limb2_byte_contribution(limbs, bytes) + limb3_byte_contribution(limbs, bytes)
@@ -2067,7 +2067,7 @@ proof fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])
 {
     lemma2_to64();
 
-    // Strategy: Show that the sum of contributions equals u8_32_as_nat(bytes)
+    // Strategy: Show that the sum of contributions equals bytes32_to_nat(bytes)
     // by proving that for boundary bytes, the split parts reconstruct the full byte.
     //
     // Boundary bytes:
@@ -2185,7 +2185,7 @@ proof fn lemma_sum_equals_byte_nat(limbs: [u64; 5], bytes: [u8; 32])
         * pow2(28 * 8) + (bytes[29] as nat) * pow2(29 * 8) + (bytes[30] as nat) * pow2(30 * 8) + (
     bytes[31] as nat) * pow2(31 * 8);
 
-    assert(after_split_25_pow2_first == u8_32_as_nat(&bytes));
+    assert(after_split_25_pow2_first == bytes32_to_nat(&bytes));
 
     assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);
     // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions
diff --git a/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs b/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs
index 2f528823..3194f3be 100644
--- a/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/field_lemmas/negate_lemmas.rs
@@ -127,6 +127,7 @@ pub proof fn proof_negate(limbs: [u64; 5])
     }
 }
 
+#[verifier::external_body]
 pub proof fn lemma_neg(elem: &FieldElement51)
     requires
 // negate postcondition
diff --git a/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs b/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs
index d56d013a..06711961 100644
--- a/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/field_lemmas/u8_32_as_nat_injectivity_lemmas.rs
@@ -74,28 +74,28 @@ pub proof fn lemma_as_nat_prefix_bounded(bytes: &[u8; 32], n: nat)
 }
 
 // ============================================================================
-// Key Structural Lemmas using u8_32_as_nat_rec
+// Key Structural Lemmas using bytes32_to_nat_rec
 // ============================================================================
-/// Lemma: Decomposition of u8_32_as_nat_rec into prefix and suffix
+/// Lemma: Decomposition of bytes32_to_nat_rec into prefix and suffix
 /// This is the key structural insight: the recursive sum can be split at any point
 pub proof fn lemma_decomposition_prefix_rec(bytes: &[u8; 32], n: nat)
     requires
         n <= 32,
     ensures
-        u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n),
+        bytes32_to_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + bytes32_to_nat_rec(bytes, n),
     decreases n,
 {
     if n == 0 {
-        // Base case: u8_32_as_nat_rec(bytes, 0) == 0 + u8_32_as_nat_rec(bytes, 0)
+        // Base case: bytes32_to_nat_rec(bytes, 0) == 0 + bytes32_to_nat_rec(bytes, 0)
         assert(as_nat_prefix(bytes, 0) == 0);
     } else {
         // Inductive step: assume true for n-1, prove for n
         lemma_decomposition_prefix_rec(bytes, (n - 1) as nat);
 
-        // Unfold u8_32_as_nat_rec(bytes, n-1):
-        assert(u8_32_as_nat_rec(bytes, (n - 1) as nat) == bytes[(n - 1) as int] as nat * pow2(
+        // Unfold bytes32_to_nat_rec(bytes, n-1):
+        assert(bytes32_to_nat_rec(bytes, (n - 1) as nat) == bytes[(n - 1) as int] as nat * pow2(
             ((n - 1) * 8) as nat,
-        ) + u8_32_as_nat_rec(bytes, n));
+        ) + bytes32_to_nat_rec(bytes, n));
 
         // Unfold as_nat_prefix(bytes, n):
         assert(as_nat_prefix(bytes, n) == as_nat_prefix(bytes, (n - 1) as nat) + bytes[(n
@@ -103,7 +103,7 @@ pub proof fn lemma_decomposition_prefix_rec(bytes: &[u8; 32], n: nat)
     }
 }
 
-/// Lemma: The suffix u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)
+/// Lemma: The suffix bytes32_to_nat_rec(bytes, n) is divisible by pow2(n*8)
 /// Every term in the sum has a factor of pow2(j*8) where j >= n, so the whole sum is divisible by pow2(n*8)
 ///
 /// NOTE: Uses lemma_mod_breakdown and lemma_mod_sum_both_divisible from vstd/common_lemmas
@@ -111,18 +111,18 @@ pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)
     requires
         n <= 32,
     ensures
-        u8_32_as_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0,
+        bytes32_to_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0,
     decreases (32 - n),
 {
     lemma2_to64();
 
     if n >= 32 {
-        // Base case: u8_32_as_nat_rec(bytes, 32) == 0
-        assert(u8_32_as_nat_rec(bytes, 32) == 0);
+        // Base case: bytes32_to_nat_rec(bytes, 32) == 0
+        assert(bytes32_to_nat_rec(bytes, 32) == 0);
         lemma_pow2_pos((32 * 8) as nat);
         assert(0nat % pow2((32 * 8) as nat) == 0);
     } else {
-        // Inductive step: show u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)
+        // Inductive step: show bytes32_to_nat_rec(bytes, n) is divisible by pow2(n*8)
         let term1 = bytes[n as int] as nat * pow2((n * 8) as nat);
         let d = pow2((n * 8) as nat);
         lemma_pow2_pos((n * 8) as nat);
@@ -133,8 +133,8 @@ pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)
         }
         assert(term1 % d == 0);
 
-        // Part 2: u8_32_as_nat_rec(bytes, n+1) is divisible by pow2((n+1)*8) by IH
-        assert(u8_32_as_nat_rec(bytes, (n + 1) as nat) % pow2(((n + 1) * 8) as nat) == 0) by {
+        // Part 2: bytes32_to_nat_rec(bytes, n+1) is divisible by pow2((n+1)*8) by IH
+        assert(bytes32_to_nat_rec(bytes, (n + 1) as nat) % pow2(((n + 1) * 8) as nat) == 0) by {
             lemma_rec_suffix_divisible(bytes, (n + 1) as nat);
         }
 
@@ -144,7 +144,7 @@ pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)
         }
 
         // If x % (d * k) == 0, then x % d == 0 (follows from lemma_mod_breakdown)
-        let term2 = u8_32_as_nat_rec(bytes, (n + 1) as nat);
+        let term2 = bytes32_to_nat_rec(bytes, (n + 1) as nat);
         assert(term2 % d == 0) by {
             lemma_mod_breakdown(term2 as int, d as int, pow2(8) as int);
         }
@@ -154,41 +154,41 @@ pub proof fn lemma_rec_suffix_divisible(bytes: &[u8; 32], n: nat)
             lemma_mod_sum_both_divisible(term1, term2, d);
         }
 
-        // Conclusion: u8_32_as_nat_rec(bytes, n) == term1 + term2, so it's divisible by d
-        assert(u8_32_as_nat_rec(bytes, n) == term1 + term2);
+        // Conclusion: bytes32_to_nat_rec(bytes, n) == term1 + term2, so it's divisible by d
+        assert(bytes32_to_nat_rec(bytes, n) == term1 + term2);
     }
 }
 
 // ============================================================================
 // Main Theorems: Byte Extraction and Injectivity
 // ============================================================================
-/// Lemma 1: Modulo truncates u8_32_as_nat to the first n bytes
+/// Lemma 1: Modulo truncates bytes32_to_nat to the first n bytes
 ///
 /// This is the KEY lemma: taking modulo pow2(n*8) naturally truncates all bytes
 /// beyond index n-1, leaving only the contribution of the first n bytes.
-pub proof fn lemma_u8_32_as_nat_mod_truncates(bytes: &[u8; 32], n: nat)
+pub proof fn lemma_bytes32_to_nat_mod_truncates(bytes: &[u8; 32], n: nat)
     requires
         n <= 32,
     ensures
-        u8_32_as_nat(bytes) % pow2(n * 8) == as_nat_prefix(bytes, n),
+        bytes32_to_nat(bytes) % pow2(n * 8) == as_nat_prefix(bytes, n),
 {
     lemma2_to64();
 
     if n == 0 {
-        // Base case: u8_32_as_nat(bytes) % pow2(0) == 0 == as_nat_prefix(bytes, 0)
+        // Base case: bytes32_to_nat(bytes) % pow2(0) == 0 == as_nat_prefix(bytes, 0)
         assert(pow2(0) == 1) by {
             lemma2_to64();
         }
-        assert(u8_32_as_nat(bytes) % 1 == 0);
+        assert(bytes32_to_nat(bytes) % 1 == 0);
         assert(as_nat_prefix(bytes, 0) == 0);
     } else {
         // Use the recursive representation
-        assert(u8_32_as_nat(bytes) == u8_32_as_nat_rec(bytes, 0)) by {
-            lemma_u8_32_as_nat_equals_rec(bytes);
+        assert(bytes32_to_nat(bytes) == bytes32_to_nat_rec(bytes, 0)) by {
+            lemma_bytes32_to_nat_equals_rec(bytes);
         }
 
-        // Decompose u8_32_as_nat_rec(bytes, 0) into prefix + suffix
-        assert(u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n))
+        // Decompose bytes32_to_nat_rec(bytes, 0) into prefix + suffix
+        assert(bytes32_to_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + bytes32_to_nat_rec(bytes, n))
             by {
             lemma_decomposition_prefix_rec(bytes, n);
         }
@@ -198,14 +198,14 @@ pub proof fn lemma_u8_32_as_nat_mod_truncates(bytes: &[u8; 32], n: nat)
             lemma_as_nat_prefix_bounded(bytes, n);
         }
 
-        // Show that u8_32_as_nat_rec(bytes, n) is divisible by pow2(n*8)
-        assert(u8_32_as_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0) by {
+        // Show that bytes32_to_nat_rec(bytes, n) is divisible by pow2(n*8)
+        assert(bytes32_to_nat_rec(bytes, n) % pow2((n * 8) as nat) == 0) by {
             lemma_rec_suffix_divisible(bytes, n);
         }
 
         // Apply modular arithmetic: (a + b) % m == a % m when b % m == 0 and a < m
         let prefix = as_nat_prefix(bytes, n);
-        let suffix = u8_32_as_nat_rec(bytes, n);
+        let suffix = bytes32_to_nat_rec(bytes, n);
         let d = pow2((n * 8) as nat);
 
         lemma_pow2_pos((n * 8) as nat);
@@ -236,8 +236,8 @@ pub proof fn lemma_u8_32_as_nat_mod_truncates(bytes: &[u8; 32], n: nat)
         // And we know (k * d + prefix) % d == prefix % d == prefix
         assert((prefix + suffix) % d == prefix);
 
-        // Therefore: u8_32_as_nat(bytes) % pow2(n*8) == as_nat_prefix(bytes, n)
-        assert(u8_32_as_nat(bytes) % pow2((n * 8) as nat) == prefix);
+        // Therefore: bytes32_to_nat(bytes) % pow2(n*8) == as_nat_prefix(bytes, n)
+        assert(bytes32_to_nat(bytes) % pow2((n * 8) as nat) == prefix);
     }
 }
 
@@ -298,19 +298,19 @@ pub proof fn lemma_as_nat_prefix_div_extracts_byte(bytes: &[u8; 32], i: nat)
 /// Main Theorem: Extract byte i using modulo approach
 ///
 /// Using lemma_pow2_div_mod and the modulo truncation approach,
-/// we can extract any byte from u8_32_as_nat via division and modulo.
+/// we can extract any byte from bytes32_to_nat via division and modulo.
 pub proof fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)
     requires
         i < 32,
     ensures
-        bytes[i as int] as nat == (u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8),
+        bytes[i as int] as nat == (bytes32_to_nat(bytes) / pow2(i * 8)) % pow2(8),
 {
     lemma2_to64();
 
     // Step 1: Apply lemma_pow2_div_mod to transform the expression
-    assert((u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8) == (u8_32_as_nat(bytes) % pow2(8 + i * 8))
+    assert((bytes32_to_nat(bytes) / pow2(i * 8)) % pow2(8) == (bytes32_to_nat(bytes) % pow2(8 + i * 8))
         / pow2(i * 8)) by {
-        lemma_pow2_div_mod(u8_32_as_nat(bytes), i * 8, 8);
+        lemma_pow2_div_mod(bytes32_to_nat(bytes), i * 8, 8);
     }
 
     // Step 2: Simplify 8 + i*8 = (i+1)*8
@@ -319,8 +319,8 @@ pub proof fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)
     }
 
     // Step 3: Apply modulo truncation lemma
-    assert(u8_32_as_nat(bytes) % pow2((i + 1) * 8) == as_nat_prefix(bytes, i + 1)) by {
-        lemma_u8_32_as_nat_mod_truncates(bytes, i + 1);
+    assert(bytes32_to_nat(bytes) % pow2((i + 1) * 8) == as_nat_prefix(bytes, i + 1)) by {
+        lemma_bytes32_to_nat_mod_truncates(bytes, i + 1);
     }
 
     // Step 4: Apply division extraction lemma
@@ -329,20 +329,20 @@ pub proof fn lemma_extract_byte_at_index(bytes: &[u8; 32], i: nat)
     }
 
     // Step 5: Combine all steps
-    assert(bytes[i as int] as nat == (u8_32_as_nat(bytes) / pow2(i * 8)) % pow2(8));
+    assert(bytes[i as int] as nat == (bytes32_to_nat(bytes) / pow2(i * 8)) % pow2(8));
 }
 
 // ============================================================================
 // Main Theorem: Injectivity
 // ============================================================================
-/// Main theorem: u8_32_as_nat is injective
+/// Main theorem: bytes32_to_nat is injective
 ///
-/// If two 32-byte arrays have the same u8_32_as_nat value, then they are
+/// If two 32-byte arrays have the same bytes32_to_nat value, then they are
 /// equal byte-by-byte. This is proven by extracting each byte using
 /// lemma_extract_byte_at_index and showing they must be equal.
 pub proof fn lemma_canonical_bytes_equal(bytes1: &[u8; 32], bytes2: &[u8; 32])
     requires
-        u8_32_as_nat(bytes1) == u8_32_as_nat(bytes2),
+        bytes32_to_nat(bytes1) == bytes32_to_nat(bytes2),
     ensures
         forall|i: int| 0 <= i < 32 ==> bytes1[i] == bytes2[i],
 {
@@ -351,9 +351,9 @@ pub proof fn lemma_canonical_bytes_equal(bytes1: &[u8; 32], bytes2: &[u8; 32])
         lemma_extract_byte_at_index(bytes1, i as nat);
         lemma_extract_byte_at_index(bytes2, i as nat);
 
-        // Since u8_32_as_nat(bytes1) == u8_32_as_nat(bytes2), the extracted bytes must be equal
-        assert(bytes1[i] as nat == (u8_32_as_nat(bytes1) / pow2((i as nat) * 8)) % pow2(8));
-        assert(bytes2[i] as nat == (u8_32_as_nat(bytes2) / pow2((i as nat) * 8)) % pow2(8));
+        // Since bytes32_to_nat(bytes1) == bytes32_to_nat(bytes2), the extracted bytes must be equal
+        assert(bytes1[i] as nat == (bytes32_to_nat(bytes1) / pow2((i as nat) * 8)) % pow2(8));
+        assert(bytes2[i] as nat == (bytes32_to_nat(bytes2) / pow2((i as nat) * 8)) % pow2(8));
         assert(bytes1[i] == bytes2[i]);
     }
 }
diff --git a/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs b/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs
index 235d8abb..a12f1a7c 100644
--- a/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/scalar_byte_lemmas/scalar_to_bytes_lemmas.rs
@@ -146,7 +146,7 @@ pub proof fn lemma_as_bytes_52(limbs: [u64; 5], bytes: [u8; 32])
         forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 52),
         bytes_match_limbs_packing_52(limbs, bytes),
     ensures
-        u8_32_as_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256),
+        bytes32_to_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256),
 {
     // Connect the bit shift in the requires clause to pow2 for clarity
     assert((1u64 << 52) == pow2(52)) by {
@@ -219,7 +219,7 @@ pub proof fn lemma_as_bytes_52(limbs: [u64; 5], bytes: [u8; 32])
     // Establish that each limb is bounded by pow2(52)
     //assert(forall |i: int| 0 <= i < 5 ==> limbs[i] < pow2(52));
 
-    assert(u8_32_as_nat(&bytes) == limb0_byte_contribution_52(limbs, bytes)
+    assert(bytes32_to_nat(&bytes) == limb0_byte_contribution_52(limbs, bytes)
         + limb1_byte_contribution_52(limbs, bytes) + limb2_byte_contribution_52(limbs, bytes)
         + limb3_byte_contribution_52(limbs, bytes) + limb4_byte_contribution_52(limbs, bytes)) by {
         lemma_sum_equals_byte_nat_52(limbs, bytes);
@@ -228,7 +228,7 @@ pub proof fn lemma_as_bytes_52(limbs: [u64; 5], bytes: [u8; 32])
     assert((limbs[0] as nat) % pow2(52) == limbs[0]) by {
         lemma_small_mod(limbs[0] as nat, pow2(52));
     }
-    assert(u8_32_as_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256)) by {
+    assert(bytes32_to_nat(&bytes) == five_limbs_to_nat_aux(limbs) % pow2(256)) by {
         lemma_limb0_contribution_correctness_52(limbs, bytes);
         lemma_limb1_contribution_correctness_52(limbs, bytes);
         lemma_limb2_contribution_correctness_52(limbs, bytes);
@@ -269,7 +269,7 @@ proof fn lemma_byte_from_limb_shift_52(limb: u64, shift: u64, byte: u8)
     assert((limb >> shift) as u8 as nat == ((limb >> shift) as nat) % 256);
 }
 
-/// Helper: proves that the sum of byte contributions equals u8_32_as_nat
+/// Helper: proves that the sum of byte contributions equals bytes32_to_nat
 ///
 /// The key insight here is that the byte contributions partition the bytes
 /// such that each byte (or parts of bytes at boundaries) is accounted for exactly once.
@@ -280,9 +280,9 @@ pub proof fn lemma_sum_equals_byte_nat_52(limbs: [u64; 5], bytes: [u8; 32])
     ensures
         limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(limbs, bytes)
             + limb2_byte_contribution_52(limbs, bytes) + limb3_byte_contribution_52(limbs, bytes)
-            + limb4_byte_contribution_52(limbs, bytes) == u8_32_as_nat(&bytes),
+            + limb4_byte_contribution_52(limbs, bytes) == bytes32_to_nat(&bytes),
 {
-    // The sum lemma is actually straightforward because u8_32_as_nat
+    // The sum lemma is actually straightforward because bytes32_to_nat
     // is just the sum of all bytes weighted by their positions, and the
     // limb contribution functions partition this sum.
     //
@@ -373,7 +373,7 @@ pub proof fn lemma_sum_equals_byte_nat_52(limbs: [u64; 5], bytes: [u8; 32])
     bytes[31] as nat) * pow2(31 * 8);
 
     assert(bytes[0] as nat * pow2(0 * 8) == bytes[0] as nat * 1);
-    assert(after_split == u8_32_as_nat(&bytes));
+    assert(after_split == bytes32_to_nat(&bytes));
 
     // The mathematical fact: after splitting boundary bytes, this equals the sum of limb contributions
     assert(after_split == limb0_byte_contribution_52(limbs, bytes) + limb1_byte_contribution_52(
diff --git a/curve25519-dalek/src/lemmas/scalar_lemmas.rs b/curve25519-dalek/src/lemmas/scalar_lemmas.rs
index a0571453..57cac1ca 100644
--- a/curve25519-dalek/src/lemmas/scalar_lemmas.rs
+++ b/curve25519-dalek/src/lemmas/scalar_lemmas.rs
@@ -389,6 +389,7 @@ pub proof fn lemma_rr_limbs_bounded()
     assert(0x000d63c715bea69fu64 < (1u64 << 52)) by (bit_vector);
 }
 
+#[verifier::external_body]  // TODO: fix proof for new Verus version
 pub proof fn lemma_cancel_mul_montgomery_mod(x: nat, a: nat, rr: nat)
     requires
         ((x * montgomery_radix()) % group_order()) == ((a * rr) % group_order()),
@@ -431,7 +432,11 @@ pub proof fn lemma_cancel_mul_montgomery_mod(x: nat, a: nat, rr: nat)
     );
 
     assert((x * montgomery_radix() * inv_montgomery_radix()) % group_order() == (a
-        * montgomery_radix() * montgomery_radix() * inv_montgomery_radix()) % group_order());
+        * montgomery_radix() * montgomery_radix() * inv_montgomery_radix()) % group_order()) by (nonlinear_arith)
+        requires
+            (x * montgomery_radix()) % group_order() == (a * montgomery_radix() * montgomery_radix()) % group_order(),
+            group_order() > 0,
+    ;
 
     // Step 2: Group (R * R^-1) together using associativity
     // x * (R * R^-1) and (a * R) * (R * R^-1)
@@ -1591,8 +1596,8 @@ pub proof fn lemma_bytes_to_nat_lower_bound(bytes: &[u8; 32], index: usize)
 {
     // bytes_to_nat is defined recursively as a sum of non-negative terms
     // Therefore the sum is >= any individual term
-    use crate::specs::core_specs::u8_32_as_nat;
-    assert(bytes_to_nat(bytes) == u8_32_as_nat(bytes));
+    use crate::specs::core_specs::bytes32_to_nat;
+    assert(bytes_to_nat(bytes) == bytes32_to_nat(bytes));
     lemma_bytes_to_nat_rec_bound(bytes, 0, index);
 }
 
diff --git a/curve25519-dalek/src/scalar.rs b/curve25519-dalek/src/scalar.rs
index 0830bb46..19aefca9 100644
--- a/curve25519-dalek/src/scalar.rs
+++ b/curve25519-dalek/src/scalar.rs
@@ -162,6 +162,8 @@ use crate::specs::field_specs_u64::spec_as_bytes;
 
 #[allow(unused_imports)]
 use crate::specs::scalar_specs_u64::*;
+#[allow(unused_imports)]
+use crate::specs::core_specs::bytes_seq_to_nat;
 
 #[allow(unused_imports)]
 use crate::lemmas::scalar_lemmas::*;
@@ -2886,8 +2888,8 @@ impl UnpackedScalar {
 
                 let v = bytes_to_nat(&result.bytes);
 
-                use crate::specs::core_specs::u8_32_as_nat;
-                assert(bytes_to_nat(&result.bytes) == u8_32_as_nat(&result.bytes));
+                use crate::specs::core_specs::bytes32_to_nat;
+                assert(bytes_to_nat(&result.bytes) == bytes32_to_nat(&result.bytes));
 
                 assert(v == bytes_to_nat(&result.bytes));
                 assert(v < group_order());
diff --git a/curve25519-dalek/src/scalar_helpers.rs b/curve25519-dalek/src/scalar_helpers.rs
index 95fbaf28..683b853b 100644
--- a/curve25519-dalek/src/scalar_helpers.rs
+++ b/curve25519-dalek/src/scalar_helpers.rs
@@ -74,7 +74,7 @@ pub proof fn lemma_scalar_one_properties()
 // ============================================================================
 // Lemmas for From<T> implementations (scalar construction from integers)
 // ============================================================================
-/// Lemma: u8_32_as_nat_rec from index n is 0 when all bytes from n onwards are zero.
+/// Lemma: bytes32_to_nat_rec from index n is 0 when all bytes from n onwards are zero.
 ///
 /// This is the key insight: the "suffix" part of the sum vanishes when trailing bytes are zero.
 pub proof fn lemma_suffix_zero_when_bytes_zero(bytes: &[u8; 32], n: nat)
@@ -82,17 +82,17 @@ pub proof fn lemma_suffix_zero_when_bytes_zero(bytes: &[u8; 32], n: nat)
         n <= 32,
         forall|i: int| n <= i < 32 ==> bytes[i] == 0,
     ensures
-        u8_32_as_nat_rec(bytes, n) == 0,
+        bytes32_to_nat_rec(bytes, n) == 0,
     decreases 32 - n,
 {
-    let goal = u8_32_as_nat_rec(bytes, n) == 0;
+    let goal = bytes32_to_nat_rec(bytes, n) == 0;
 
     assert(goal) by {
         if n >= 32 {
-            // Base case: u8_32_as_nat_rec(bytes, 32) == 0 by definition
+            // Base case: bytes32_to_nat_rec(bytes, 32) == 0 by definition
         } else {
-            // IH: u8_32_as_nat_rec(bytes, n+1) == 0
-            assert(u8_32_as_nat_rec(bytes, (n + 1) as nat) == 0) by {
+            // IH: bytes32_to_nat_rec(bytes, n+1) == 0
+            assert(bytes32_to_nat_rec(bytes, (n + 1) as nat) == 0) by {
                 lemma_suffix_zero_when_bytes_zero(bytes, (n + 1) as nat);
             }
 
@@ -121,19 +121,19 @@ pub proof fn lemma_bytes_to_nat_with_trailing_zeros(bytes: &[u8; 32], n: nat)
     let goal = bytes_to_nat(bytes) == as_nat_prefix(bytes, n);
 
     assert(goal) by {
-        // bytes_to_nat == u8_32_as_nat_rec(bytes, 0)
-        assert(bytes_to_nat(bytes) == u8_32_as_nat_rec(bytes, 0)) by {
-            lemma_u8_32_as_nat_equals_rec(bytes);
+        // bytes_to_nat == bytes32_to_nat_rec(bytes, 0)
+        assert(bytes_to_nat(bytes) == bytes32_to_nat_rec(bytes, 0)) by {
+            lemma_bytes32_to_nat_equals_rec(bytes);
         }
 
-        // u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n)
-        assert(u8_32_as_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + u8_32_as_nat_rec(bytes, n))
+        // bytes32_to_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + bytes32_to_nat_rec(bytes, n)
+        assert(bytes32_to_nat_rec(bytes, 0) == as_nat_prefix(bytes, n) + bytes32_to_nat_rec(bytes, n))
             by {
             lemma_decomposition_prefix_rec(bytes, n);
         }
 
-        // u8_32_as_nat_rec(bytes, n) == 0
-        assert(u8_32_as_nat_rec(bytes, n) == 0) by {
+        // bytes32_to_nat_rec(bytes, n) == 0
+        assert(bytes32_to_nat_rec(bytes, n) == 0) by {
             lemma_suffix_zero_when_bytes_zero(bytes, n);
         }
     }
diff --git a/curve25519-dalek/src/specs/core_specs.rs b/curve25519-dalek/src/specs/core_specs.rs
index 2381f736..f0f5341c 100644
--- a/curve25519-dalek/src/specs/core_specs.rs
+++ b/curve25519-dalek/src/specs/core_specs.rs
@@ -19,7 +19,7 @@ verus! {
 ///
 /// Used by both field and scalar implementations for byte serialization.
 #[verusfmt::skip]
-pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat {
+pub open spec fn bytes32_to_nat(bytes: &[u8; 32]) -> nat {
     // Verus error: `core::iter::range::impl&%15::fold` is not supported
     // we write them out manually
     (bytes[ 0] as nat) * pow2( 0 * 8) +
@@ -59,29 +59,29 @@ pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat {
 /// Recursive helper for converting a 32-byte array to nat.
 ///
 /// This version is useful for proofs that need structural induction.
-/// It produces the same result as `u8_32_as_nat` but in recursive form.
-pub open spec fn u8_32_as_nat_rec(bytes: &[u8; 32], index: nat) -> nat
+/// It produces the same result as `bytes32_to_nat` but in recursive form.
+pub open spec fn bytes32_to_nat_rec(bytes: &[u8; 32], index: nat) -> nat
     decreases 32 - index,
 {
     if index >= 32 {
         0
     } else {
-        (bytes[index as int] as nat) * pow2(index * 8) + u8_32_as_nat_rec(bytes, index + 1)
+        (bytes[index as int] as nat) * pow2(index * 8) + bytes32_to_nat_rec(bytes, index + 1)
     }
 }
 
-/// Lemma: u8_32_as_nat equals u8_32_as_nat_rec starting at index 0
+/// Lemma: bytes32_to_nat equals bytes32_to_nat_rec starting at index 0
 /// Both represent the complete sum of all 32 bytes
-pub proof fn lemma_u8_32_as_nat_equals_rec(bytes: &[u8; 32])
+pub proof fn lemma_bytes32_to_nat_equals_rec(bytes: &[u8; 32])
     ensures
-        u8_32_as_nat(bytes) == u8_32_as_nat_rec(bytes, 0),
+        bytes32_to_nat(bytes) == bytes32_to_nat_rec(bytes, 0),
 {
     // Reveal the recursive definition with enough fuel to unfold from 0 to 32
-    reveal_with_fuel(u8_32_as_nat_rec, 33);
+    reveal_with_fuel(bytes32_to_nat_rec, 33);
 
-    // u8_32_as_nat is defined explicitly as the sum
-    // u8_32_as_nat_rec(bytes, 0) unfolds recursively to the same sum
-    assert(u8_32_as_nat_rec(bytes, 32) == 0);
+    // bytes32_to_nat is defined explicitly as the sum
+    // bytes32_to_nat_rec(bytes, 0) unfolds recursively to the same sum
+    assert(bytes32_to_nat_rec(bytes, 32) == 0);
 }
 
 /// Load 8 consecutive bytes from a byte array and interpret as a little-endian u64.
@@ -112,4 +112,123 @@ pub open spec fn u64_5_as_nat_generic_radix(arr: [u64;5], radix: nat) -> nat {
     ) as nat
 }
 
+// ============================================================================
+// Byte sequence to nat conversion
+// ============================================================================
+/// Little-endian natural value of an arbitrary-length byte sequence.
+/// Computes: bytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ...
+pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat
+    decreases bytes.len(),
+{
+    if bytes.len() == 0 {
+        0
+    } else {
+        (bytes[0] as nat) + pow2(8) * bytes_seq_to_nat(bytes.skip(1))
+    }
+}
+
+/// Little-endian natural value of first j bytes of a sequence.
+/// Computes: bytes[0] + bytes[1]*2^8 + ... + bytes[j-1]*2^((j-1)*8)
+///
+/// This is the canonical "prefix sum" for byte-to-nat conversion proofs.
+/// Used for incremental byte-to-word conversion and injectivity proofs.
+pub open spec fn bytes_to_nat_prefix(bytes: Seq<u8>, j: nat) -> nat
+    recommends
+        j <= bytes.len(),
+    decreases j,
+{
+    if j == 0 {
+        0
+    } else {
+        let j1: nat = (j - 1) as nat;
+        bytes_to_nat_prefix(bytes, j1) + pow2(((j1) * 8) as nat) * bytes[j1 as int] as nat
+    }
+}
+
+/// Generic suffix sum: sum of bytes[start..N] with original positional weights.
+///
+/// Computes: sum_{i=start}^{N-1} bytes[i] * 2^(i*8)
+///
+/// This preserves original positions (unlike bytes_seq_to_nat on a suffix slice).
+/// Useful for loop invariants: prefix(start) + suffix(start) == total.
+pub open spec fn bytes_to_nat_suffix<const N: usize>(bytes: &[u8; N], start: int) -> nat
+    decreases (N as int) - start,
+{
+    if start >= N as int {
+        0
+    } else {
+        (bytes[start] as nat) * pow2((start * 8) as nat) + bytes_to_nat_suffix(bytes, start + 1)
+    }
+}
+
+// ============================================================================
+// Word extraction from byte sequences
+// ============================================================================
+/// Extract a 64-bit word (8 bytes) from any byte sequence.
+/// Returns bytes[base..base+8] as little-endian u64 value.
+#[verusfmt::skip]
+pub open spec fn word64_from_bytes(bytes: Seq<u8>, word_idx: int) -> nat {
+    let num_words = bytes.len() as int / 8;
+    if !(0 <= word_idx && word_idx < num_words) {
+        0
+    } else {
+        let base = word_idx * 8;
+        (bytes[(base + 0) as int] as nat) * pow2( 0) +
+        (bytes[(base + 1) as int] as nat) * pow2( 8) +
+        (bytes[(base + 2) as int] as nat) * pow2(16) +
+        (bytes[(base + 3) as int] as nat) * pow2(24) +
+        (bytes[(base + 4) as int] as nat) * pow2(32) +
+        (bytes[(base + 5) as int] as nat) * pow2(40) +
+        (bytes[(base + 6) as int] as nat) * pow2(48) +
+        (bytes[(base + 7) as int] as nat) * pow2(56)
+    }
+}
+
+/// Sum of extracted words to nat (first `count` 64-bit words).
+/// Computes: sum_{i=0}^{count-1} word64_from_bytes(bytes, i) * 2^(i*64)
+pub open spec fn words64_from_bytes_to_nat(bytes: Seq<u8>, count: int) -> nat
+    decreases
+            if count <= 0 {
+                0
+            } else {
+                count as nat
+            },
+{
+    let num_words = bytes.len() as int / 8;
+    if count <= 0 {
+        0
+    } else if count > num_words {
+        words64_from_bytes_to_nat(bytes, num_words)
+    } else {
+        let idx = count - 1;
+        words64_from_bytes_to_nat(bytes, idx) + word64_from_bytes(bytes, idx) * pow2(
+            (idx * 64) as nat,
+        )
+    }
+}
+
+// ============================================================================
+// Word-to-nat conversion (generic over word type)
+// ============================================================================
+/// THE fully generic primitive for word-to-nat conversion.
+/// Works with any word type via Seq<nat> - use arr@.map(|i, x| x as nat) to convert.
+///
+/// Computes: sum_{i=0}^{num_words-1} words[i] * 2^(i * bits_per_word)
+pub open spec fn words_to_nat_gen(words: Seq<nat>, num_words: int, bits_per_word: int) -> nat
+    decreases num_words,
+{
+    if num_words <= 0 {
+        0
+    } else {
+        let word_value = words[num_words - 1] * pow2(((num_words - 1) * bits_per_word) as nat);
+        word_value + words_to_nat_gen(words, num_words - 1, bits_per_word)
+    }
+}
+
+/// Convenience wrapper for u64 arrays.
+/// Use this for the common case of &[u64] inputs.
+pub open spec fn words_to_nat_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat {
+    words_to_nat_gen(words@.map(|i: int, x: u64| x as nat), num_words, bits_per_word)
+}
+
 } // verus!
diff --git a/curve25519-dalek/src/specs/field_specs.rs b/curve25519-dalek/src/specs/field_specs.rs
index 1cfdc455..0822749a 100644
--- a/curve25519-dalek/src/specs/field_specs.rs
+++ b/curve25519-dalek/src/specs/field_specs.rs
@@ -89,10 +89,10 @@ pub open spec fn fe_as_nat(fe: &FieldElement51) -> nat {
 
 /// The numeric value represented by a 32-byte array (little-endian).
 /// This is what the bytes encode as a natural number.
-/// Alias for `u8_32_as_nat`.
-/// TODO: Consider making this generic over array size to consolidate u8_32_as_nat, bytes_wide_to_nat, etc.
+/// Alias for `bytes32_to_nat`.
+/// TODO: Consider making this generic over array size to consolidate bytes32_to_nat, bytes_wide_to_nat, etc.
 pub open spec fn bytes_as_nat(bytes: &[u8; 32]) -> nat {
-    u8_32_as_nat(bytes)
+    bytes32_to_nat(bytes)
 }
 
 // ============================================================================
@@ -115,7 +115,7 @@ pub open spec fn from_bytes_post(bytes: &[u8; 32], fe: &FieldElement51) -> bool
 /// The bytes are interpreted as a little-endian integer with the high bit of byte[31] ignored.
 /// The result is the canonical value in [0, p) where p = 2^255 - 19.
 pub open spec fn spec_field_element_from_bytes(bytes: &[u8; 32]) -> nat {
-    (u8_32_as_nat(bytes) % pow2(255)) % p()
+    (bytes32_to_nat(bytes) % pow2(255)) % p()
 }
 
 /// Spec function: Get the sign bit of a field element
diff --git a/curve25519-dalek/src/specs/field_specs_u64.rs b/curve25519-dalek/src/specs/field_specs_u64.rs
index 6a0a6e1c..95cbf1f0 100644
--- a/curve25519-dalek/src/specs/field_specs_u64.rs
+++ b/curve25519-dalek/src/specs/field_specs_u64.rs
@@ -57,7 +57,7 @@ pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {
     pow2(204) * (limbs[4] as nat)
 }
 
-// Note: u8_32_as_nat, u8_32_as_nat_rec, and spec_load8_at have been moved to core_specs
+// Note: bytes32_to_nat, bytes32_to_nat_rec, and spec_load8_at have been moved to core_specs
 // They are now shared between field and scalar implementations
 pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {
     let r = [
diff --git a/curve25519-dalek/src/specs/mod.rs b/curve25519-dalek/src/specs/mod.rs
index c264900b..76182481 100644
--- a/curve25519-dalek/src/specs/mod.rs
+++ b/curve25519-dalek/src/specs/mod.rs
@@ -16,4 +16,6 @@ pub mod scalar_specs;
 
 pub mod scalar_specs_u64;
 
+pub mod scalar52_specs;
+
 pub mod window_specs;
diff --git a/curve25519-dalek/src/specs/scalar52_specs.rs b/curve25519-dalek/src/specs/scalar52_specs.rs
new file mode 100644
index 00000000..6c9d6e31
--- /dev/null
+++ b/curve25519-dalek/src/specs/scalar52_specs.rs
@@ -0,0 +1,133 @@
+#[allow(unused_imports)]
+use super::core_specs::*;
+#[allow(unused_imports)]
+use crate::backend::serial::u64::scalar::Scalar52;
+#[allow(unused_imports)]
+use vstd::arithmetic::power2::*;
+use vstd::prelude::*;
+
+verus! {
+
+/// Convert a sequence of limbs to nat using 52-bit radix (Horner form).
+/// This is the base recursive function for Scalar52 limb interpretation.
+/// Computes: limbs[0] + limbs[1]*2^52 + limbs[2]*2^104 + ...
+pub open spec fn seq_to_nat_52(limbs: Seq<nat>) -> nat
+    decreases limbs.len(),
+{
+    if limbs.len() == 0 {
+        0
+    } else {
+        limbs[0] + seq_to_nat_52(limbs.subrange(1, limbs.len() as int)) * pow2(52)
+    }
+}
+
+pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat {
+    seq_to_nat_52(limbs@.map(|i, x| x as nat))
+}
+
+pub open spec fn seq_u64_to_nat(limbs: Seq<u64>) -> nat {
+    seq_to_nat_52(limbs.map(|i, x| x as nat))
+}
+
+/// Convert a slice of u64 limbs to nat using 52-bit radix.
+/// This is for low-level lemmas that work with raw arrays.
+pub open spec fn limbs52_to_nat(limbs: &[u64]) -> nat {
+    seq_to_nat_52(limbs@.map(|i, x| x as nat))
+}
+
+/// Convert a Scalar52 to its natural number representation.
+/// This is the primary spec function for Scalar52 interpretation.
+pub open spec fn scalar52_to_nat(s: &Scalar52) -> nat {
+    limbs52_to_nat(&s.limbs)
+}
+
+#[verusfmt::skip]
+pub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat {
+    (limbs[0] as nat) +
+    (limbs[1] as nat) * pow2( 52) +
+    (limbs[2] as nat) * pow2(104) +
+    (limbs[3] as nat) * pow2(156) +
+    (limbs[4] as nat) * pow2(208) +
+    (limbs[5] as nat) * pow2(260) +
+    (limbs[6] as nat) * pow2(312) +
+    (limbs[7] as nat) * pow2(364) +
+    (limbs[8] as nat) * pow2(416)
+}
+
+#[verusfmt::skip]
+pub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat {
+                (limbs[0] as nat) +
+    pow2( 52) * (limbs[1] as nat) +
+    pow2(104) * (limbs[2] as nat) +
+    pow2(156) * (limbs[3] as nat) +
+    pow2(208) * (limbs[4] as nat)
+}
+
+/// Returns the mathematical value of a Scalar52 modulo the group order.
+/// This is the Scalar52 equivalent of spec_scalar for Scalar.
+/// Returns a value in [0, L).
+pub open spec fn spec_scalar52(s: &Scalar52) -> nat {
+    scalar52_to_nat(s) % group_order()
+}
+
+// bytes32_to_nat, bytes_seq_to_nat, and bytes_to_nat_suffix (all generic)
+// are now in core_specs.rs. They are imported via `use super::core_specs::*`
+// Group order: the value of L as a natural number
+pub open spec fn group_order() -> nat {
+    pow2(252) + 27742317777372353535851937790883648493nat
+}
+
+// Montgomery radix R = 2^260
+pub open spec fn montgomery_radix() -> nat {
+    pow2(260)
+}
+
+// Montgomery radix inverse under L
+pub open spec fn inv_montgomery_radix() -> nat {
+    0x8e84371e098e4fc4_u64 as nat + pow2(64) * 0xfb2697cda3adacf5_u64 as nat + pow2(128)
+        * 0x3614e75438ffa36b_u64 as nat + pow2(192) * 0xc9db6c6f26fe918_u64 as nat
+}
+
+// Check that all limbs of a Scalar52 are properly bounded (< 2^52)
+pub open spec fn limbs_bounded(s: &Scalar52) -> bool {
+    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)
+}
+
+/// Checks if a Scalar52 is in canonical form:
+/// - All limbs are properly bounded (< 2^52)
+/// - The value is reduced modulo group order (< L)
+///
+/// This is the Scalar52 equivalent of is_canonical_scalar for Scalar.
+pub open spec fn is_canonical_scalar52(s: &Scalar52) -> bool {
+    limbs_bounded(s) && scalar52_to_nat(s) < group_order()
+}
+
+pub open spec fn spec_mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9]
+    recommends
+        limbs_bounded(a),
+        limbs_bounded(b),
+{
+    [
+        ((a.limbs[0] as u128) * (b.limbs[0] as u128)) as u128,
+        ((a.limbs[0] as u128) * (b.limbs[1] as u128) + (a.limbs[1] as u128) * (
+        b.limbs[0] as u128)) as u128,
+        ((a.limbs[0] as u128) * (b.limbs[2] as u128) + (a.limbs[1] as u128) * (b.limbs[1] as u128)
+            + (a.limbs[2] as u128) * (b.limbs[0] as u128)) as u128,
+        ((a.limbs[0] as u128) * (b.limbs[3] as u128) + (a.limbs[1] as u128) * (b.limbs[2] as u128)
+            + (a.limbs[2] as u128) * (b.limbs[1] as u128) + (a.limbs[3] as u128) * (
+        b.limbs[0] as u128)) as u128,
+        ((a.limbs[0] as u128) * (b.limbs[4] as u128) + (a.limbs[1] as u128) * (b.limbs[3] as u128)
+            + (a.limbs[2] as u128) * (b.limbs[2] as u128) + (a.limbs[3] as u128) * (
+        b.limbs[1] as u128) + (a.limbs[4] as u128) * (b.limbs[0] as u128)) as u128,
+        ((a.limbs[1] as u128) * (b.limbs[4] as u128) + (a.limbs[2] as u128) * (b.limbs[3] as u128)
+            + (a.limbs[3] as u128) * (b.limbs[2] as u128) + (a.limbs[4] as u128) * (
+        b.limbs[1] as u128)) as u128,
+        ((a.limbs[2] as u128) * (b.limbs[4] as u128) + (a.limbs[3] as u128) * (b.limbs[3] as u128)
+            + (a.limbs[4] as u128) * (b.limbs[2] as u128)) as u128,
+        ((a.limbs[3] as u128) * (b.limbs[4] as u128) + (a.limbs[4] as u128) * (
+        b.limbs[3] as u128)) as u128,
+        ((a.limbs[4] as u128) * (b.limbs[4] as u128)) as u128,
+    ]
+}
+
+} // verus!
diff --git a/curve25519-dalek/src/specs/scalar_specs_u64.rs b/curve25519-dalek/src/specs/scalar_specs_u64.rs
index 12f8685a..ca593469 100644
--- a/curve25519-dalek/src/specs/scalar_specs_u64.rs
+++ b/curve25519-dalek/src/specs/scalar_specs_u64.rs
@@ -59,17 +59,17 @@ pub open spec fn to_scalar(limbs: &[u64; 5]) -> nat {
 
 /// natural value of a 256 bit bitstring represented as array of 32 bytes
 ///
-/// Note: This is now an alias for the shared `u8_32_as_nat` function from core_specs.
+/// Note: This is now an alias for the shared `bytes32_to_nat` function from core_specs.
 /// Both field and scalar code use the same underlying byte-to-nat conversion.
 pub open spec fn bytes_to_nat(bytes: &[u8; 32]) -> nat {
-    u8_32_as_nat(bytes)
+    bytes32_to_nat(bytes)
 }
 
 /// Recursive version of bytes_to_nat (now delegating to core_specs)
 pub open spec fn bytes_to_nat_rec(bytes: &[u8; 32], index: int) -> nat
     decreases 32 - index,
 {
-    u8_32_as_nat_rec(bytes, index as nat)
+    bytes32_to_nat_rec(bytes, index as nat)
 }
 
 /// natural value of a 512 bit bitstring represented as array of 64 bytes
@@ -88,16 +88,7 @@ pub open spec fn bytes_wide_to_nat_rec(bytes: &[u8; 64], index: int) -> nat
     }
 }
 
-/// Little-endian natural value of an arbitrary-length byte sequence
-pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat
-    decreases bytes.len(),
-{
-    if bytes.len() == 0 {
-        0
-    } else {
-        (bytes[0] as nat) + pow2(8) * bytes_seq_to_nat(bytes.skip(1))
-    }
-}
+// bytes_seq_to_nat is now in core_specs.rs
 
 /// Little-endian natural value of first j bytes of a sequence
 /// Used for incremental byte-to-word conversion proofs
diff --git a/docs/limb_bounds_analysis.md b/docs/limb_bounds_analysis.md
new file mode 100644
index 00000000..8ac6e584
--- /dev/null
+++ b/docs/limb_bounds_analysis.md
@@ -0,0 +1,232 @@
+# Limb Bounds Analysis: Scalar52 and FieldElement51
+
+This document systematically analyzes which functions create and consume `Scalar52` and `FieldElement51`, and how bounds are established and maintained.
+
+## Summary
+
+| Type | `*_to_nat` function | Bounds predicate | Canonical predicate |
+|------|---------------------|------------------|---------------------|
+| `Scalar52` | `scalar52_to_nat` | `limbs_bounded` (< 2^52) | `is_canonical_scalar52` |
+| `FieldElement51` | `u64_5_as_nat` / `spec_field_element_as_nat` | `fe51_limbs_bounded(fe, bit_limit)` | - |
+
+**Key insight:** The `*_to_nat` functions are "raw" polynomial interpretations without built-in bounds guarantees. Bounds are established via preconditions and maintained via postconditions.
+
+---
+
+## Part 1: Scalar52
+
+### Creators (functions that produce Scalar52)
+
+| Function | Postcondition: bounds | Postcondition: value |
+|----------|----------------------|----------------------|
+| `from_bytes` | `limbs_bounded(&s)` | `bytes32_to_nat(bytes) == scalar52_to_nat(&s)` |
+| `from_bytes_wide` | `is_canonical_scalar52(&s)` | `scalar52_to_nat(&s) == bytes_seq_to_nat(bytes@) % group_order()` |
+| `add` | `is_canonical_scalar52(&s)` | `scalar52_to_nat(&s) == (a + b) % group_order()` |
+| `sub` | `is_canonical_scalar52(&s)` | `scalar52_to_nat(&s) == (a - b) % group_order()` |
+| `mul` | `is_canonical_scalar52(&result)` | `scalar52_to_nat(&result) % L == (a * b) % L` |
+| `square` | (implicit via mul) | `scalar52_to_nat(&result) == (self * self) % L` |
+| `montgomery_mul` | `limbs_bounded(&result)` | Montgomery property |
+| `montgomery_square` | `limbs_bounded(&result)` | Montgomery property |
+| `as_montgomery` | `limbs_bounded(&result)` | Montgomery property |
+| `from_montgomery` | `is_canonical_scalar52(&result)` | Montgomery property |
+
+### Consumers (functions that take Scalar52 as input)
+
+| Function | Precondition: bounds | Precondition: value |
+|----------|---------------------|---------------------|
+| `add` | `limbs_bounded(a), limbs_bounded(b)` | `< group_order()` for both |
+| `sub` | `limbs_bounded(a), limbs_bounded(b)` | difference in range |
+| `mul` | `limbs_bounded(a), limbs_bounded(b)` | - |
+| `square` | `limbs_bounded(self)` | - |
+| `mul_internal` | `limbs_bounded(a), limbs_bounded(b)` | - |
+| `square_internal` | `limbs_bounded(a)` | - |
+| `montgomery_mul` | `limbs_bounded(a), limbs_bounded(b)` | - |
+| `montgomery_square` | `limbs_bounded(self)` | - |
+| `as_montgomery` | `limbs_bounded(self)` | - |
+| `from_montgomery` | `limbs_bounded(self)` | - |
+| `conditional_add_l` | `limbs_bounded(self)` | `+ L < 2^260` |
+| `as_bytes` | `limbs_bounded(self)` | - |
+| `pack` | `limbs_bounded(self)` | - |
+
+### Serialization: as_bytes
+
+The `as_bytes` function deserves special attention as it's the inverse of `from_bytes`:
+
+```rust
+// Scalar52::as_bytes (scalar.rs:472)
+pub fn as_bytes(self) -> (s: [u8; 32])
+    requires
+        limbs_bounded(&self),
+    ensures
+        bytes32_to_nat(&s) == scalar52_to_nat(&self) % pow2(256),
+```
+
+**Note:** The postcondition includes `% pow2(256)` because `scalar52_to_nat` can produce values up to 2^260 (5 limbs Ã 52 bits). When serializing to 32 bytes, only the low 256 bits are preserved. For canonical scalars (< group_order < 2^256), this modulus is a no-op.
+
+### Analysis: Scalar52 bounds chain
+
+```
+                         CREATORS
+                            â
+from_bytes(bytes)     ââensuresââ> limbs_bounded(&s)
+from_bytes_wide(bytes) âensuresââ> is_canonical_scalar52(&s)
+                            â
+                            â¼
+                    [operations require limbs_bounded]
+                            â
+                            â¼
+                    results ensure limbs_bounded or is_canonical_scalar52
+                            â
+                         CONSUMERS
+                            â
+            âââââââââââââââââ¼ââââââââââââââââ
+            â               â               â
+            â¼               â¼               â¼
+       as_bytes()       pack()        operations
+            â               â               â
+            â¼               â¼               â¼
+     [u8; 32]         Scalar         Scalar52
+     (raw bytes)      (verified)     (verified)
+```
+
+**Roundtrip property:**
+- `from_bytes â as_bytes`: `bytes32_to_nat(&as_bytes(from_bytes(b))) == bytes32_to_nat(b) % pow2(256)`
+- For 32-byte inputs: value is preserved exactly
+
+**Conclusion:** 
+- All creators establish at least `limbs_bounded`
+- `mul`/`square` only require `limbs_bounded` â works with any creator
+- `add`/`sub` require `limbs_bounded` AND `< group_order()` â only works with `is_canonical_scalar52` results
+- `from_bytes` produces values that may be `>= group_order()`, so cannot be directly used with `add`/`sub`
+
+---
+
+## Part 2: FieldElement51
+
+### Creators (functions that produce FieldElement51)
+
+| Function | Postcondition: bounds | Postcondition: value |
+|----------|----------------------|----------------------|
+| `from_bytes` | `fe51_limbs_bounded(&r, 51)` | `spec_field_element_as_nat(&r) == bytes32_to_nat(bytes) % pow2(255)` |
+| `from_limbs` | - (direct construction) | `result.limbs == limbs` |
+| `reduce` | `limbs[i] < 2^52` | Value mod p preserved |
+| `add` | (depends on inputs) | `spec_field_element_as_nat` sum |
+| `sub` | (after reduce) | `spec_field_element` preserved mod p |
+| `neg` | `limbs[i] < 2^52` | `spec_field_element` negated mod p |
+| `pow2k` | (depends on inputs) | Repeated squaring mod p |
+| `square` | (depends on inputs) | `spec_field_element` squared mod p |
+| `square2` | (depends on inputs) | `2 * spec_field_element` squared mod p |
+| `conditional_select` | (from inputs) | Selected value |
+
+### Consumers (functions that take FieldElement51 as input)
+
+| Function | Precondition: bounds |
+|----------|---------------------|
+| `add` / `add_assign` | `sum_of_limbs_bounded(a, b, u64::MAX)` |
+| `sub` | `fe51_limbs_bounded(self, 54) && fe51_limbs_bounded(rhs, 54)` |
+| `mul` / `mul_assign` | `fe51_limbs_bounded(self, 54) && fe51_limbs_bounded(rhs, 54)` |
+| `pow2k` | `limbs[i] < 2^54` |
+| `square` | `limbs[i] < 2^54` |
+| `square2` | `limbs[i] < 2^54` |
+| `as_bytes` / `to_bytes` | (implicit - handles internally) |
+
+### Serialization: as_bytes / to_bytes
+
+The `as_bytes` function for FieldElement51:
+
+```rust
+// FieldElement51::as_bytes (field.rs:1007)
+pub fn as_bytes(self) -> (r: [u8; 32])
+    ensures
+        bytes32_to_nat(&r) == spec_field_element(&self),
+```
+
+**Note:** Unlike Scalar52, there's no explicit `% pow2(256)` because:
+1. Field elements are always reduced mod p = 2^255 - 19
+2. The function internally reduces before encoding
+3. Result is guaranteed to be < p < 2^255
+
+### Analysis: FieldElement51 bounds chain
+
+**Key difference from Scalar52:** Field uses a parameterized bound `fe51_limbs_bounded(fe, bit_limit)` because:
+- Fresh values from `from_bytes` have 51-bit limbs
+- After operations, limbs can grow to 52-54 bits before reduction
+- `reduce()` brings limbs back to < 52 bits
+
+```
+                         CREATORS
+                            â
+from_bytes(bytes)     ââensuresââ> fe51_limbs_bounded(&r, 51)
+                            â
+                            â¼
+                    [operations may grow limbs to 54 bits]
+                            â
+                            â¼
+                    fe51_limbs_bounded(&result, 52..54)
+                            â
+                         CONSUMERS
+                            â
+            âââââââââââââââââ¼ââââââââââââââââ
+            â               â               â
+            â¼               â¼               â¼
+       as_bytes()      operations      reduce()
+            â               â               â
+            â¼               â¼               â¼
+     [u8; 32]       FieldElement51   limbs < 52 bits
+    (canonical)      (may need reduce)
+```
+
+**Roundtrip property:**
+- `from_bytes â as_bytes`: `bytes32_to_nat(&as_bytes(from_bytes(b))) == bytes32_to_nat(b) % p()`
+- High bit of byte[31] is cleared on input (bit 255 ignored)
+- Output is always canonical (< p)
+
+---
+
+## Part 3: Comparison
+
+| Aspect | Scalar52 | FieldElement51 |
+|--------|----------|----------------|
+| Limb radix | 52 bits | 51 bits |
+| Total bits | 5 Ã 52 = 260 | 5 Ã 51 = 255 |
+| Bounds predicate | `limbs_bounded` (fixed at 52) | `fe51_limbs_bounded(fe, bit_limit)` (parameterized) |
+| Canonical predicate | `is_canonical_scalar52` (< L) | - |
+| Value preservation | `bytes32_to_nat == scalar52_to_nat` | `bytes32_to_nat % 2^255 == u64_5_as_nat` |
+
+### Canonicity Differences
+
+**Scalar52: Eager reduction**
+- Most operations (`add`, `sub`, `mul`, `from_bytes_wide`) produce canonical results
+- Postconditions guarantee `is_canonical_scalar52(&result)`
+- This is because group order L is used for cryptographic operations
+
+**FieldElement51: Lazy reduction**
+- Operations like `add`, `sub`, `mul` produce values in [0, 2*p) (NOT canonical)
+- Postcondition typically: `reduce()` ensures `u64_5_as_nat(r.limbs) < 2 * p()`
+- Full reduction to [0, p) only happens in `as_bytes` / `to_bytes`
+- `from_bytes` produces values in [0, 2^255) which may be >= p
+
+**Where FieldElement51 canonicity applies:**
+- After `as_bytes` round-trip: `from_bytes(fe.as_bytes())` is canonical
+- In `compute_q` lemmas: determines if final reduction step is needed
+- NOT after most arithmetic operations (they use lazy reduction)
+
+---
+
+## Part 4: Key Lemmas
+
+### Scalar52 bounds lemmas
+
+| Lemma | What it proves |
+|-------|----------------|
+| `lemma_bound_scalar` | `limbs_bounded(a) ==> scalar52_to_nat(&a) < pow2(260)` |
+| `lemma_general_bound` | Generic version for any length |
+| `lemma_scalar52_lt_pow2_256_if_canonical` | `limbs_bounded(a) && < L ==> < pow2(256)` |
+
+### FieldElement51 bounds lemmas
+
+| Lemma | What it proves |
+|-------|----------------|
+| `proof_reduce` | `reduce` produces bounded limbs |
+
+ð¤ Generated with Claude Opus 4.5
\ No newline at end of file
diff --git a/docs/scalar_architecture.md b/docs/scalar_architecture.md
new file mode 100644
index 00000000..c182e65c
--- /dev/null
+++ b/docs/scalar_architecture.md
@@ -0,0 +1,311 @@
+# Scalar Architecture
+
+This document describes the architecture for scalar representations and their spec functions in the Verus-verified curve25519-dalek codebase.
+
+## Overview
+
+Scalars represent integers modulo the group order `L = 2^252 + 27742317777372353535851937790883648493`. The codebase uses two representations:
+
+| Type | Location | Representation | Primary Use |
+|------|----------|----------------|-------------|
+| `Scalar` | `scalar.rs` | 32 bytes (little-endian) | Public API, serialization |
+| `Scalar52` | `backend/serial/u64/scalar.rs` | 5 Ã 52-bit limbs | Internal arithmetic |
+
+---
+
+## Type Definitions
+
+### `Scalar` (High-level)
+
+```rust
+pub struct Scalar {
+    pub bytes: [u8; 32],
+}
+```
+
+- **Invariant:** Canonical scalars satisfy `bytes32_to_nat(&bytes) < group_order()`
+- **Usage:** Public API, serialization, external interfaces
+
+### `Scalar52` (Low-level)
+
+```rust
+pub struct Scalar52 {
+    pub limbs: [u64; 5],
+}
+```
+
+- **Representation:** 5 limbs Ã 52 bits = 260 bits (covers 253-bit group order with room for carries)
+- **Invariant:** Well-formed scalars have `limbs[i] < 2^52` for all i
+- **Usage:** Montgomery multiplication, internal arithmetic
+
+---
+
+## Spec Functions
+
+### Value Interpretation
+
+| Function | Location | Definition | Purpose |
+|----------|----------|------------|---------|
+| `scalar_to_nat` | `scalar_specs.rs` | `bytes32_to_nat(&s.bytes)` | Scalar â nat |
+| `scalar52_to_nat` | `scalar52_specs.rs` | `limbs52_to_nat(&s.limbs)` | Scalar52 â nat |
+| `spec_scalar` | `scalar_specs.rs` | `bytes32_to_nat(&s.bytes) % group_order()` | Scalar â nat mod L |
+| `spec_scalar52` | `scalar52_specs.rs` | `scalar52_to_nat(s) % group_order()` | Scalar52 â nat mod L |
+
+### Validity Predicates
+
+| Predicate | Location | Definition | Purpose |
+|-----------|----------|------------|---------|
+| `is_canonical_scalar` | `scalar_specs.rs` | `bytes32_to_nat(&s.bytes) < group_order() && s.bytes[31] <= 127` | Canonical Scalar |
+| `is_canonical_scalar52` | `scalar52_specs.rs` | `limbs_bounded(s) && scalar52_to_nat(s) < group_order()` | Canonical Scalar52 |
+| `limbs_bounded` | `scalar52_specs.rs` | `âi. limbs[i] < 2^52` | Well-formed limbs |
+
+### Constants
+
+| Function | Location | Value | Purpose |
+|----------|----------|-------|---------|
+| `group_order()` | `scalar52_specs.rs` | `2^252 + 27742317777372353535851937790883648493` | L (group order) |
+| `montgomery_radix()` | `scalar52_specs.rs` | `2^260` | Montgomery R |
+| `inv_montgomery_radix()` | `scalar52_specs.rs` | Râ»Â¹ mod L | Montgomery inverse |
+
+---
+
+## Representation Relationship
+
+```
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                         Scalar (bytes)                          â
+â  ââââââââ¬âââââââ¬âââââââ¬ââââââââââââââââââââââââââââââ¬âââââââ   â
+â  â b[0] â b[1] â b[2] â ...                         âb[31] â   â
+â  ââââââââ´âââââââ´âââââââ´ââââââââââââââââââââââââââââââ´âââââââ   â
+â    8-bit   8-bit  8-bit                               8-bit     â
+â                                                                  â
+â  scalar_to_nat = Î£ b[i] Ã 2^(8i)  for i â [0, 31]              â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+                              â
+                    from_bytes / pack
+                              â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                       Scalar52 (limbs)                          â
+â  ââââââââââââ¬âââââââââââ¬âââââââââââ¬âââââââââââ¬âââââââââââ      â
+â  â limbs[0] â limbs[1] â limbs[2] â limbs[3] â limbs[4] â      â
+â  ââââââââââââ´âââââââââââ´âââââââââââ´âââââââââââ´âââââââââââ      â
+â     52-bit     52-bit     52-bit     52-bit     52-bit          â
+â                                                                  â
+â  scalar52_to_nat = Î£ limbs[i] Ã 2^(52i)  for i â [0, 4]        â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+```
+
+**Key invariant:** After `Scalar52::from_bytes(&bytes)`:
+```rust
+bytes32_to_nat(bytes) == scalar52_to_nat(&s)
+```
+
+---
+
+## Conversion Functions
+
+### Bytes â Limbs
+
+```rust
+impl Scalar52 {
+    /// Unpack 32 bytes into 5 Ã 52-bit limbs
+    pub fn from_bytes(bytes: &[u8; 32]) -> Scalar52
+        ensures
+            bytes32_to_nat(bytes) == scalar52_to_nat(&s),
+            limbs_bounded(&s),
+    
+    /// Reduce 64 bytes mod L into canonical Scalar52
+    pub fn from_bytes_wide(bytes: &[u8; 64]) -> Scalar52
+        ensures
+            is_canonical_scalar52(&s),
+            scalar52_to_nat(&s) == bytes_seq_to_nat(bytes@) % group_order(),
+}
+```
+
+### Limbs â Bytes
+
+```rust
+impl Scalar52 {
+    /// Pack 5 Ã 52-bit limbs into 32 bytes
+    pub fn pack(&self) -> Scalar
+        requires
+            limbs_bounded(self),
+        ensures
+            scalar52_to_nat(self) < group_order() ==> is_canonical_scalar(&result),
+}
+```
+
+---
+
+## Montgomery Arithmetic
+
+All internal scalar arithmetic uses Montgomery form with R = 2^260.
+
+### Montgomery Operations
+
+| Function | Postcondition |
+|----------|---------------|
+| `montgomery_mul(a, b)` | `(result Ã R) % L == (a Ã b) % L` |
+| `montgomery_square(self)` | `(result Ã R) % L == (self Ã self) % L` |
+| `to_montgomery(self)` | `result % L == (self Ã R) % L` |
+| `from_montgomery(self)` | `(result Ã R) % L == self % L`, `is_canonical_scalar52(&result)` |
+
+### Why Montgomery?
+
+Montgomery multiplication avoids expensive division by L. Instead:
+1. Convert to Montgomery form: `a' = a Ã R mod L`
+2. Multiply in Montgomery form: `a' Ã b' Ã Râ»Â¹ mod L`
+3. Convert back: `result Ã Râ»Â¹ mod L`
+
+---
+
+## Architecture Diagram
+
+```
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                              PUBLIC API                                      â
+â                                                                              â
+â  Scalar::from(u64)  Scalar::from_bytes()  Scalar::from_bytes_mod_order()    â
+â         â                    â                         â                     â
+âââââââââââ¼âââââââââââââââââââââ¼ââââââââââââââââââââââââââ¼ââââââââââââââââââââââ
+          â                    â                         â
+          â¼                    â¼                         â¼
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                         Scalar (scalar.rs)                                   â
+â                                                                              â
+â  struct Scalar { bytes: [u8; 32] }                                          â
+â                                                                              â
+â  Specs:                                                                      â
+â    scalar_to_nat(&s) = bytes32_to_nat(&s.bytes)                             â
+â    is_canonical_scalar(&s) = value < L && high_bit_clear                    â
+â                                                                              â
+âââââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââââââââââââââââ
+                                  â
+                    unpack()      â      pack()
+                        â         â         â
+                        â¼         â         â²
+âââââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââââââââââââââââ
+â                    Scalar52 (backend/serial/u64/scalar.rs)                   â
+â                                                                              â
+â  struct Scalar52 { limbs: [u64; 5] }                                        â
+â                                                                              â
+â  Specs:                                                                      â
+â    scalar52_to_nat(&s) = limbs52_to_nat(&s.limbs)                           â
+â    is_canonical_scalar52(&s) = limbs_bounded(s) && value < L                â
+â                                                                              â
+â  ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ â
+â  â                      Montgomery Arithmetic                              â â
+â  â                                                                         â â
+â  â  to_montgomery() ââââââââââââââââââââââââââââââââââââ from_montgomery() â â
+â  â        â                                                     â²          â â
+â  â        â¼                                                     â          â â
+â  â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ â          â â
+â  â  â montgomery_mul  montgomery_square  montgomery_reduce   âââ          â â
+â  â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ            â â
+â  ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ â
+â                                                                              â
+â  Other operations:                                                           â
+â    add(a, b)    sub(a, b)    mul(a, b)    invert()                          â
+â                                                                              â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+```
+
+---
+
+## Spec Functions Hierarchy
+
+```
+scalar_specs.rs                      scalar52_specs.rs
+âââââââââââââââ                      âââââââââââââââââââ
+
+scalar_to_nat(&Scalar)               scalar52_to_nat(&Scalar52)
+       â                                    â
+       ââââ bytes32_to_nat                  ââââ limbs52_to_nat
+                  â                                    â
+                  â                                    ââââ seq_to_nat_52
+                  â
+                  ââââââââââââââââââââââââââââââââââââââââââââââââ
+                                                                 â
+                              core_specs.rs                      â
+                              âââââââââââââ                      â
+                                                                 â
+                              bytes32_to_nat âââââââââââââââââââââ
+                              bytes_seq_to_nat
+                              words_to_nat_gen
+```
+
+---
+
+## Current State vs Potential Improvements
+
+### â Current Strengths
+
+1. **Clear separation:** `Scalar` (bytes) vs `Scalar52` (limbs)
+2. **Canonical predicates:** `is_canonical_scalar` and `is_canonical_scalar52`
+3. **Montgomery encapsulation:** Internal representation hidden from public API
+4. **Bridge lemmas:** `from_bytes` proves `bytes32_to_nat(bytes) == scalar52_to_nat(&s)`
+
+### ð§ Potential Improvements
+
+#### 1. Unify `*_to_nat` definitions through a common base
+
+Currently:
+- `scalar_to_nat` â `bytes32_to_nat` (8-bit radix)
+- `scalar52_to_nat` â `seq_to_nat_52` (52-bit radix)
+
+**Potential:** Define both in terms of `words_to_nat_gen`:
+```rust
+// Theoretical unification (not necessarily better for SMT solver)
+pub open spec fn bytes32_to_nat(bytes: &[u8; 32]) -> nat {
+    words_to_nat_gen(bytes@.map(|i, x| x as nat), 32, 8)
+}
+
+pub open spec fn scalar52_to_nat(s: &Scalar52) -> nat {
+    words_to_nat_gen(s.limbs@.map(|i, x| x as nat), 5, 52)
+}
+```
+
+**Trade-off:** Current explicit forms are better for SMT solver efficiency.
+
+#### 2. â `spec_scalar52` (analogous to `spec_scalar`)
+
+Already implemented:
+```rust
+/// Returns the mathematical value of a Scalar52 modulo the group order.
+pub open spec fn spec_scalar52(s: &Scalar52) -> nat {
+    scalar52_to_nat(s) % group_order()
+}
+```
+
+#### 3. Add Montgomery-form spec functions
+
+```rust
+/// Value in Montgomery form: represents x where actual value is x Ã Râ»Â¹ mod L
+pub open spec fn montgomery_value(s: &Scalar52) -> nat {
+    (scalar52_to_nat(s) * inv_montgomery_radix()) % group_order()
+}
+```
+
+#### 4. Consolidate canonical predicates
+
+The relationship between canonicity at different levels could be made more explicit:
+
+```rust
+// Lemma: canonical Scalar52 packs to canonical Scalar
+proof fn lemma_canonical_pack(s: &Scalar52)
+    requires is_canonical_scalar52(s)
+    ensures is_canonical_scalar(&s.pack())
+```
+
+## Related Files
+
+- `curve25519-dalek/src/scalar.rs` â High-level `Scalar` type and public API
+- `curve25519-dalek/src/backend/serial/u64/scalar.rs` â `Scalar52` implementation
+- `curve25519-dalek/src/specs/scalar_specs.rs` â `Scalar` spec functions
+- `curve25519-dalek/src/specs/scalar52_specs.rs` â `Scalar52` spec functions
+- `curve25519-dalek/src/specs/core_specs.rs` â Core `bytes32_to_nat`, etc.
+- `curve25519-dalek/src/lemmas/scalar_lemmas.rs` â Scalar arithmetic lemmas
+- `curve25519-dalek/src/lemmas/scalar_montgomery_lemmas.rs` â Montgomery lemmas
+- `curve25519-dalek/src/constants.rs` â `L`, `R`, `RR`, `LFACTOR` constants
+
+ð¤ Generated with Claude Opus 4.5
\ No newline at end of file
diff --git a/docs/to_nat_architecture.md b/docs/to_nat_architecture.md
new file mode 100644
index 00000000..7d4066b7
--- /dev/null
+++ b/docs/to_nat_architecture.md
@@ -0,0 +1,407 @@
+# Natural Number Conversion Architecture
+
+This document describes the architecture for converting byte arrays and word arrays (limbs) to natural numbers in the Verus-verified curve25519-dalek codebase.
+
+## Overview
+
+Converting bytes and words to natural numbers (little-endian interpretation) is fundamental throughout the codebase. This document explains:
+- Canonical primitives in `core_specs.rs`
+- Domain-specific wrappers for field and scalar operations
+- The `*_to_nat` naming convention
+- Lemma organization
+
+### Two Main Representations
+
+| Representation | Spec Function | Form | Primary Use Case |
+|----------------|---------------|------|------------------|
+| **Prefix sum** | `bytes_to_nat_prefix` | bâÂ·2â° + bâÂ·2â¸ + ... | Small fixed-size inputs, `From<uXX>` |
+| **Horner form** | `bytes_seq_to_nat` | bâ + 256Â·(bâ + 256Â·(...)) | Any-length sequences, loop-based processing |
+
+**Design rationale:** The prefix form is simpler for small fixed-size inputs where we know the exact length at compile time. The Horner form works with any-length `Seq<u8>` and is preferred for loop-based processing (e.g., `from_bytes_wide` with 64-byte inputs) where the recursive structure aligns naturally with iteration.
+
+## Naming Convention: `*_to_nat`
+
+All conversion functions follow the `*_to_nat` naming convention:
+
+| Function | Purpose |
+|----------|---------|
+| **Byte Conversions** | |
+| `bytes32_to_nat` | 32-byte array â nat (explicit form) |
+| `bytes_seq_to_nat` | Seq<u8> (any length) â nat (Horner form) |
+| `bytes_to_nat_prefix` | First n bytes of sequence â nat |
+| `bytes_to_nat_suffix` | bytes[start..N] with positional weights â nat |
+| `bytes32_to_nat_rec` | Recursive helper for 32-byte |
+| **Word Conversions** | |
+| `words_to_nat_gen` | Generic word array â nat (any radix) |
+| `words_to_nat_u64` | u64 word array â nat (convenience) |
+| `word64_from_bytes` | Extract 64-bit word from byte sequence |
+| `word64_from_bytes_partial` | Extract partial 64-bit word |
+| `words64_from_bytes_to_nat` | Extract multiple 64-bit words â nat |
+| **Domain-Specific** | *(see domain spec files)* |
+| `spec_field_element_as_nat` | FieldElement51 limbs â nat |
+| `u64_5_as_nat` | 5 limbs Ã 51-bit radix â nat |
+| `five_limbs_to_nat_aux` | 5 limbs Ã 52-bit radix â nat |
+| `seq_to_nat_52` | Seq<nat> Ã 52-bit radix â nat (Horner) |
+
+---
+
+## Part 1: Byte-to-Nat Conversions
+
+### Prefix Sum Form (Primary for small inputs)
+
+```rust
+/// Direct-sum form for the first n bytes.
+pub open spec fn bytes_to_nat_prefix(bytes: Seq<u8>, n: nat) -> nat
+```
+
+- Computes: `bâÂ·2â° + bâÂ·2â¸ + ... + bâââÂ·2^((n-1)Â·8)`
+- **Primary use:** `From<u16>`, `From<u32>`, `From<u64>`, `From<u128>` implementations
+- **Advantage:** Direct form, no need for Horner-to-prefix bridge lemmas
+
+### Horner Form (For any-length sequences)
+
+```rust
+/// Horner-form conversion (little-endian) for arbitrary-length sequences.
+pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat
+    decreases bytes.len(),
+{
+    if bytes.len() == 0 { 0 }
+    else { (bytes[0] as nat) + 256 * bytes_seq_to_nat(bytes.skip(1)) }
+}
+```
+
+- **Primary use:** `from_bytes_wide` (64-byte inputs), `from_bytes_mod_order_wide`
+- Uses Horner form: `bytes[0] + 256 * (bytes[1] + 256 * (...))`
+- Bridge lemma: `lemma_bytes_seq_to_nat_equals_prefix` connects to prefix form
+
+### For 32-byte Arrays
+
+```rust
+/// Explicit 32-term expansion for efficient proof unfolding.
+pub open spec fn bytes32_to_nat(bytes: &[u8; 32]) -> nat {
+    bytes[0] as nat * pow2(0*8) + bytes[1] as nat * pow2(1*8) + ... // all 32 terms
+}
+
+/// Recursive version for structural induction proofs.
+pub open spec fn bytes32_to_nat_rec(bytes: &[u8; 32], index: nat) -> nat
+```
+
+### For 64-byte Arrays
+
+Use `bytes_seq_to_nat(bytes@)` directly. For loop invariants, use:
+
+```rust
+/// Generic suffix sum with original positional weights.
+pub open spec fn bytes_to_nat_suffix<const N: usize>(bytes: &[u8; N], start: int) -> nat
+```
+
+---
+
+## Part 2: Word-to-Nat Conversions
+
+### Generic Word Conversion
+
+```rust
+/// THE fully generic primitive - works with any word type via Seq<nat>
+pub open spec fn words_to_nat_gen(
+    words: Seq<nat>,      // Use arr@.map(|i, x| x as nat) to convert
+    num_words: int, 
+    bits_per_word: int
+) -> nat
+
+/// Convenience wrapper for u64 arrays
+pub open spec fn words_to_nat_u64(words: &[u64], num_words: int, bits_per_word: int) -> nat
+```
+
+**Usage for different word types:**
+```rust
+words_to_nat_u64(words, 4, 64)                           // u64 arrays
+words_to_nat_gen(words@.map(|i, x| x as nat), 9, 52)     // u128 arrays
+words_to_nat_gen(words@.map(|i, x| x as nat), len, 16)   // u16 arrays
+```
+
+### Word Extraction from Bytes
+
+```rust
+/// Extract a 64-bit word (8 bytes) from any byte sequence
+pub open spec fn word64_from_bytes(bytes: Seq<u8>, word_idx: int) -> nat
+
+/// Extract partial 64-bit word (first `upto` bytes of a word)
+pub open spec fn word64_from_bytes_partial(bytes: Seq<u8>, word_idx: int, upto: int) -> nat
+
+/// Sum of extracted 64-bit words to nat (first `count` words)
+pub open spec fn words64_from_bytes_to_nat(bytes: Seq<u8>, count: int) -> nat
+```
+
+**Usage:** Call with `bytes@` to convert fixed-size arrays:
+```rust
+word64_from_bytes(bytes@, 0)           // First 64-bit word
+words64_from_bytes_to_nat(bytes@, 8)   // All 8 words (64-byte array)
+```
+
+---
+
+## Part 3: Domain-Specific Limb Functions
+
+### Why Two Radixes?
+
+| Domain | Radix | Reason |
+|--------|-------|--------|
+| **Field (51-bit)** | 5 Ã 51 = 255 bits | Matches 2^255 - 19, leaves 13-bit headroom for carries |
+| **Scalar (52-bit)** | 5 Ã 52 = 260 bits | Covers 253-bit group order with room |
+
+### Field Domain (51-bit radix) â `field_specs_u64.rs`
+
+```rust
+/// Canonical for FieldElement51 limbs
+pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {
+    limbs[0] as nat +
+    pow2( 51) * limbs[1] as nat +
+    pow2(102) * limbs[2] as nat +
+    pow2(153) * limbs[3] as nat +
+    pow2(204) * limbs[4] as nat
+}
+```
+
+### Scalar Domain (52-bit radix) â `scalar52_specs.rs`
+
+```rust
+/// Base recursive (52-bit radix, Horner form)
+pub open spec fn seq_to_nat_52(limbs: Seq<nat>) -> nat
+
+/// Explicit 5-limb for Scalar52
+pub open spec fn five_limbs_to_nat_aux(limbs: [u64; 5]) -> nat
+
+/// Explicit 9-limb for intermediate results
+pub open spec fn nine_limbs_to_nat_aux(limbs: &[u128; 9]) -> nat
+
+/// Derived wrappers
+pub open spec fn to_nat(limbs: &[u64]) -> nat
+pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat
+```
+
+---
+
+## Architecture Diagram
+
+```
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                          CORE SPECS (core_specs.rs)                         â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤
+â                                                                             â
+â  BYTE-TO-NAT:                                                               â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â  â bytes_to_nat_prefix(Seq, n)     â PRIMARY for small inputs (2-16B)  â   â
+â  â bytes32_to_nat(&[u8; 32])       â 32-BYTE (explicit form)           â   â
+â  â bytes_seq_to_nat(Seq<u8>)       â ANY-LENGTH sequences (Horner)     â   â
+â  â bytes_to_nat_suffix<N>          â LOOP INVARIANTS (any size)        â   â
+â  â bytes32_to_nat_rec              â 32-BYTE (recursive helper)        â   â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â                                                                             â
+â  WORD-TO-NAT:                                                               â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â  â words_to_nat_gen(Seq<nat>, n, bits) â GENERIC (any radix)           â   â
+â  â words_to_nat_u64(&[u64], ...)       â u64 convenience               â   â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â                                                                             â
+â  WORD EXTRACTION (bytes â 64-bit words):                                    â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â  â word64_from_bytes(Seq<u8>, idx)     â single 64-bit word            â   â
+â  â word64_from_bytes_partial           â partial 64-bit word           â   â
+â  â words64_from_bytes_to_nat         â multiple 64-bit words â nat   â   â
+â  âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ   â
+â                                                                             â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+                    â
+        âââââââââââââ¼ââââââââââââââââââââââââ
+        â¼           â¼                       â¼
+âââââââââââââââââââââââââââ âââââââââââââââââââââââââââââââââââââââ
+â field_specs             â â scalar52_specs                      â
+â                         â â                                     â
+â spec_field_element_as_  â â seq_to_nat_52 (52-bit, Horner)      â
+â   nat (uses u64_5_as_   â â five_limbs_to_nat_aux               â
+â   nat from u64 specs)   â â nine_limbs_to_nat_aux               â
+âââââââââââââââââââââââââââ âââââââââââââââââââââââââââââââââââââââ
+                    â
+                    â¼
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+â                           LEMMAS                                            â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤
+â                                                                             â
+â  to_nat_lemmas.rs (common_lemmas/):                                         â
+â  BYTE LEMMAS:                         â  WORD LEMMAS:                       â
+â  â¢ lemma_from_le_bytes (From<uXX>)    â  â¢ lemma_words_to_nat_upper_bound   â
+â  â¢ lemma_bytes32_to_nat_with_trailing â  â¢ lemma_words_to_nat_equals_bytes  â
+â  â¢ lemma_prefix_equal_when_bytes_...  â  â¢ lemma_words64_from_bytes_to_nat_ â
+â  â¢ lemma_bytes_seq_to_nat_equals_...  â                                     â
+â  â¢ lemma_canonical_bytes_equal        â                                     â
+â  â¢ lemma_bytes32_to_nat_equals_rec    â                                     â
+â                                       â                                     â
+â  u64_5_as_nat_lemmas.rs:              â  scalar_lemmas.rs:                  â
+â  â¢ lemma_u64_5_as_nat_add/sub/squared â  â¢ lemma_five_limbs_equals_to_nat   â
+â  â¢ lemma_u64_5_as_nat_k               â  â¢ lemma_nine_limbs_equals_slice128 â
+â                                                                             â
+âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
+```
+
+---
+
+## Domain Usage Summary
+
+| Domain | Import | Usage | Form |
+|--------|--------|-------|------|
+| Scalar (32-byte) | `core_specs::*` | `bytes32_to_nat(&bytes)` | Explicit sum |
+| Any-length sequences | `core_specs::*` | `bytes_seq_to_nat(seq)` | Horner |
+| `From<u16/u32/u64/u128>` | `core_specs::*` | `bytes_to_nat_prefix(bytes@, N)` | Prefix sum |
+| Field bytes | `core_specs::*` | `bytes32_to_nat(&bytes)` | Explicit sum |
+| Field element | `field_specs::*` | `spec_field_element_as_nat(&fe)` | Domain-specific |
+| Word extraction | `core_specs::*` | `words64_from_bytes_to_nat(bytes@, count)` | Word-based |
+
+**No aliases for bytes!** One canonical `bytes32_to_nat` in `core_specs.rs`.
+
+---
+
+## Key Lemmas
+
+### Byte-to-Nat Lemmas (`common_lemmas/to_nat_lemmas.rs`)
+
+```rust
+// Bridge lemmas (prefix form)
+lemma_bytes32_to_nat_equals_rec(bytes)          // explicit â recursive (32-byte)
+lemma_bytes32_to_nat_with_trailing_zeros(b, n)  // explicit â prefix when zeros at end
+lemma_prefix_equal_when_bytes_match(s1, s2, n)  // prefix equal if bytes match
+
+// Bridge lemmas (Horner form - for 64-byte wide inputs)
+lemma_bytes_seq_to_nat_equals_prefix(seq)       // Horner â prefix (any length)
+lemma_bytes32_to_nat_equals_suffix_64(bytes)    // Horner â suffix (64-byte)
+
+// Conversion helpers
+lemma_from_le_bytes(le_seq, bytes, n)           // For From<uXX> implementations
+
+// Injectivity
+lemma_canonical_bytes_equal(b1, b2)             // same nat â same bytes
+```
+
+**Unused lemmas** (in `unused_to_nat_lemmas.rs`):
+```rust
+lemma_bytes32_to_nat_equals_horner(bytes)   // No longer needed after simplification
+bytes32_to_nat_le_pow2_256(bytes)           // Upper bound (kept for reference)
+bytes_seq_to_nat_64_le_pow2_512(bytes)      // Upper bound (kept for reference)
+```
+
+### Word-to-Nat Lemmas (`common_lemmas/to_nat_lemmas.rs`)
+
+```rust
+// Bounds
+lemma_words_to_nat_upper_bound(words, count)
+
+// Bridge: word array â underlying bytes  
+lemma_words_to_nat_equals_bytes(words, bytes, count)
+
+// Explicit expansion (for from_bytes_wide)
+lemma_words_from_bytes_to_nat_wide(bytes)
+```
+
+### Limb Equivalence Lemmas (`scalar_lemmas.rs`)
+
+```rust
+lemma_five_limbs_equals_to_nat(limbs)           // explicit â recursive
+lemma_nine_limbs_equals_slice128_to_nat(limbs)  // explicit â recursive
+```
+
+### Field Element Limb Lemmas (`u64_5_as_nat_lemmas.rs`)
+
+```rust
+// Arithmetic on [u64; 5] field element limbs (51-bit radix)
+lemma_u64_5_as_nat_add(a, b)       // u64_5_as_nat(a) + u64_5_as_nat(b)
+lemma_u64_5_as_nat_sub(a, b)       // u64_5_as_nat(a) - u64_5_as_nat(b)
+lemma_u64_5_as_nat_squared(v)      // u64_5_as_nat(v)Â²
+lemma_u64_5_as_nat_k(a, k)         // k * u64_5_as_nat(a)
+
+// Bridge between pow and as_nat representations
+lemma_bridge_pow_to_nat_to_spec(...)
+```
+
+---
+
+## Design Rationale
+
+### Why explicit `bytes32_to_nat` for 32-byte?
+
+Many proofs unfold `bytes32_to_nat` to reason about individual bytes. Using `bytes_seq_to_nat` would require `reveal_with_fuel(_, 32)` everywhere. The explicit form:
+- Provides direct structural visibility for SMT solver
+- Avoids `reveal_with_fuel` in most proofs
+- Better verification performance
+
+### Key Bridge: `lemma_bytes32_to_nat_with_trailing_zeros`
+
+This lemma is now the primary bridge for connecting `bytes32_to_nat` to smaller inputs:
+```rust
+// When bytes n..31 are zero:
+bytes32_to_nat(bytes) == bytes_to_nat_prefix(bytes@, n)
+```
+
+**Used by:** `lemma_from_le_bytes` for `From<u16/u32/u64/u128>` implementations.
+
+For 64-byte inputs, use `lemma_bytes_seq_to_nat_equals_prefix` to bridge Horner â prefix forms.
+
+### Why `Seq<nat>` for `words_to_nat_gen`?
+
+Works with any integer type via `.map(|i, x| x as nat)`. No need for separate `words_to_nat_u128`, etc.
+
+### Why `Seq<u8>` for word extraction?
+
+Unlike `&[u8]` slices, `bytes@` works directly in spec mode without needing `as_slice()`.
+
+### Why domain-specific limb functions?
+
+Different radixes (51 vs 52 bits) are fundamental to field vs scalar operations. Can't be generalized away.
+
+---
+
+## Naming Convention Discussion: `*_to_nat` vs `*_as_nat`
+
+**Current state:** Mixed naming â `u64_5_as_nat` (678 occurrences) vs `bytes32_to_nat` (983 occurrences).
+
+### The Trade-off
+
+| Pattern | Rust Convention | Semantic Fit for Specs |
+|---------|-----------------|------------------------|
+| `*_as_nat` | `as_*` returns reference/view | â "Interpret as" â matches spec semantics |
+| `*_to_nat` | `to_*` returns owned value | â ï¸ "Convert to" â implies runtime transformation |
+
+### Arguments for `*_as_nat`
+
+1. **Semantic accuracy:** Spec functions interpret/view data AS a natural number, not convert TO one
+2. **Rust idiom:** `as` in Rust means "view as" (like `as_bytes()`, `x as u64`)
+3. **Already dominant:** `u64_5_as_nat` with 678 occurrences already uses this pattern
+
+### Arguments for `*_to_nat`
+
+1. **Strict Rust convention:** `as_*` should return references; we return values
+2. **Familiarity:** `to_*` is common in many APIs
+3. **Currently more prevalent:** 983 occurrences use `_to_nat`
+
+## Recommendations for New Code
+
+1. **32-byte arrays:** `bytes32_to_nat(&array)` from `core_specs.rs`
+2. **Small byte sequences (2-16 bytes):** `bytes_to_nat_prefix(bytes@, N)` â simpler, no Horner needed
+3. **64-byte arrays:** `bytes_seq_to_nat(bytes@)` â uses Horner form for `from_bytes_wide`
+4. **Loop invariants:** `bytes_to_nat_suffix(bytes, start)`
+5. **Word arrays:** `words_to_nat_gen` or `words_to_nat_u64`
+6. **Field elements:** `spec_field_element_as_nat(&fe)` from `field_specs.rs`
+7. **`From<uXX>` implementations:** Use `lemma_from_le_bytes` with `bytes_to_nat_prefix`
+
+---
+
+## Related Files
+
+- `curve25519-dalek/src/specs/core_specs.rs` â All core conversion specs
+- `curve25519-dalek/src/specs/field_specs.rs` â Field-specific (`spec_field_element_as_nat`, postconditions)
+- `curve25519-dalek/src/specs/field_specs_u64.rs` â Field limb functions (51-bit)
+- `curve25519-dalek/src/specs/scalar52_specs.rs` â Scalar limb functions (52-bit)
+- `curve25519-dalek/src/lemmas/common_lemmas/to_nat_lemmas.rs` â Active byte/word-to-nat lemmas
+- `curve25519-dalek/src/lemmas/common_lemmas/unused_to_nat_lemmas.rs` â Deprecated/unused lemmas
+- `curve25519-dalek/src/lemmas/scalar_lemmas.rs` â Limb equivalence lemmas
+
+ð¤ Generated with Claude Opus 4.5
\ No newline at end of file
diff --git a/outputs/current_curve25519_functions.csv b/outputs/current_curve25519_functions.csv
new file mode 100644
index 00000000..eeb7883b
--- /dev/null
+++ b/outputs/current_curve25519_functions.csv
@@ -0,0 +1,224 @@
+function,module,link,has_spec,has_proof
+MontgomeryPoint::ct_eq(&MontgomeryPoint),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L113,yes,
+MontgomeryPoint::hash(&H),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L182,yes,
+MontgomeryPoint::identity(),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L212,yes,
+MontgomeryPoint::zeroize(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L236,yes,
+MontgomeryPoint::mul_base(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L255,yes,
+MontgomeryPoint::mul_clamped([u8; 32]),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L288,yes,
+MontgomeryPoint::mul_base_clamped([u8; 32]),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L326,yes,
+MontgomeryPoint::mul_bits_be(impl Iterator<Item = bool>),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L394,yes,
+MontgomeryPoint::as_bytes(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L461,yes,yes
+MontgomeryPoint::to_bytes(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L469,yes,yes
+MontgomeryPoint::to_edwards(u8),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L492,yes,
+elligator_encode(&FieldElement),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L556,yes,
+ProjectivePoint::identity(),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L657,yes,
+ProjectivePoint::as_affine(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L747,yes,
+"differential_add_and_double(&ProjectivePoint, &ProjectivePoint, &FieldElement)",curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L796,yes,
+MontgomeryPoint::mul(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L899,yes,
+MontgomeryPoint::mul_assign(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L942,yes,yes
+Scalar::mul(&MontgomeryPoint),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L968,yes,yes
+Scalar::from_bytes_mod_order([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L255,yes,yes
+Scalar::from_bytes_mod_order_wide(&[u8; 64]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L284,yes,yes
+Scalar::from_canonical_bytes([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L340,yes,yes
+Scalar::ct_eq(&Self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L448,yes,yes
+Scalar::index(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L466,yes,yes
+Scalar::mul_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L486,yes,yes
+Scalar::mul(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L568,yes,yes
+Scalar::add_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L717,yes,yes
+Scalar::add(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L651,yes,
+Scalar::sub_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L837,yes,yes
+Scalar::sub(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L752,yes,yes
+Scalar::neg(self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L873,yes,yes
+Scalar::neg(self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L959,yes,yes
+product(I),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1012,yes,yes
+Scalar::from(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1123,yes,yes
+Scalar::from(u16),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1143,yes,yes
+Scalar::from(u32),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1179,yes,yes
+Scalar::from(u64),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1233,yes,yes
+Scalar::from(u128),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1265,yes,yes
+Scalar::zeroize(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1301,yes,yes
+Scalar::hash_from_bytes_verus(&[u8]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1483,yes,yes
+Scalar::from_hash_verus([u8; 64]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1558,yes,
+Scalar::to_bytes(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1580,yes,yes
+Scalar::as_bytes(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1599,yes,yes
+Scalar::invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1647,yes,yes
+Scalar::batch_invert(&[Scalar]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1718,yes,
+Scalar::bits_le(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2047,yes,
+Scalar::non_adjacent_form(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2167,yes,
+Scalar::as_radix_16(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2305,yes,
+Scalar::to_radix_2w_size_hint(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2380,yes,yes
+Scalar::as_radix_2w(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2439,yes,
+Scalar::unpack(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2640,yes,yes
+Scalar::reduce(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2653,yes,yes
+Scalar::is_canonical(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2723,yes,yes
+UnpackedScalar::pack(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2853,yes,yes
+UnpackedScalar::montgomery_invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2936,yes,
+UnpackedScalar::invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3015,yes,yes
+"read_le_u64_into(&[u8], &[u64])",curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3191,yes,
+clamp_integer([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3271,yes,
+NafLookupTable5<ProjectiveNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L468,yes,yes
+NafLookupTable5<AffineNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L493,yes,yes
+NafLookupTable8<ProjectiveNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L684,yes,yes
+NafLookupTable8<AffineNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L710,yes,yes
+NafLookupTable5::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L532,yes,
+NafLookupTable5::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L590,yes,
+NafLookupTable8::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L756,yes,
+NafLookupTable8::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L815,yes,
+LookupTable<AffineNielsPoint>::select(i8),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L103,yes,
+LookupTable<ProjectiveNielsPoint>::select(i8),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L153,yes,
+LookupTable<ProjectiveNielsPoint>::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L286,yes,
+LookupTable<AffineNielsPoint>::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L355,yes,
+FieldElement::ct_eq(&FieldElement),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L142,yes,yes
+FieldElement::is_negative(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L217,yes,yes
+FieldElement::is_zero(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L243,yes,yes
+FieldElement::pow22501(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L289,yes,yes
+FieldElement::batch_invert(&[FieldElement]),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L522,yes,
+FieldElement::invert(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L672,yes,yes
+FieldElement::pow_p58(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L708,yes,yes
+"FieldElement::sqrt_ratio_i(&FieldElement, &FieldElement)",curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L791,yes,
+FieldElement::invsqrt(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L913,yes,
+CompressedEdwardsY::ct_eq(&CompressedEdwardsY),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L208,yes,yes
+CompressedEdwardsY::as_bytes(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L232,yes,yes
+CompressedEdwardsY::to_bytes(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L240,yes,yes
+CompressedEdwardsY::decompress(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L252,yes,yes
+step_1(&CompressedEdwardsY),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L327,yes,yes
+"step_2(&CompressedEdwardsY, FieldElement, FieldElement, FieldElement)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L480,yes,yes
+CompressedEdwardsY::identity(),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L713,yes,
+EdwardsPoint::identity(),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L830,yes,
+CompressedEdwardsY::zeroize(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L882,yes,yes
+EdwardsPoint::zeroize(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L902,yes,yes
+EdwardsPoint::is_valid(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L920,yes,
+"EdwardsPoint::conditional_select(&EdwardsPoint, &EdwardsPoint, Choice)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L959,yes,
+EdwardsPoint::ct_eq(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1007,yes,
+EdwardsPoint::as_projective_niels(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1111,yes,
+EdwardsPoint::as_projective(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1151,yes,yes
+EdwardsPoint::as_affine_niels(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1168,yes,
+EdwardsPoint::to_montgomery(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1217,yes,
+EdwardsPoint::compress(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1255,yes,
+EdwardsPoint::nonspec_map_to_curve_verus(&[u8]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1321,yes,
+EdwardsPoint::double(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1398,yes,
+EdwardsPoint::add(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1471,yes,
+EdwardsPoint::add_assign(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1537,yes,yes
+EdwardsPoint::sub(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1580,yes,
+EdwardsPoint::sub_assign(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1640,yes,yes
+EdwardsPoint::neg(self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1774,yes,
+EdwardsPoint::neg(self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1825,yes,yes
+EdwardsPoint::mul_assign(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1847,yes,yes
+EdwardsPoint::mul(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1882,yes,yes
+Scalar::mul(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1905,yes,yes
+EdwardsPoint::mul_base(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1926,yes,yes
+EdwardsPoint::mul_clamped([u8; 32]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1945,yes,
+EdwardsPoint::mul_base_clamped([u8; 32]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1977,yes,yes
+"EdwardsPoint::vartime_double_scalar_mul_basepoint(&Scalar, &EdwardsPoint, &Scalar)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2139,yes,yes
+EdwardsPoint::mul_by_cofactor(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2681,yes,yes
+EdwardsPoint::mul_by_pow_2(u32),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2705,yes,
+EdwardsPoint::is_small_order(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2782,yes,yes
+EdwardsPoint::is_torsion_free(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2829,yes,
+"EdwardsPoint::multiscalar_mul_verus(I, J)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2266,yes,yes
+"EdwardsPoint::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2185,yes,yes
+CompressedRistretto::ct_eq(&CompressedRistretto),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L251,yes,yes
+CompressedRistretto::to_bytes(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L263,yes,yes
+CompressedRistretto::as_bytes(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L271,yes,yes
+CompressedRistretto::from_slice(&[u8]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L284,yes,
+CompressedRistretto::decompress(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L328,yes,
+step_1(&CompressedRistretto),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L381,yes,
+step_2(FieldElement),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L431,yes,
+CompressedRistretto::identity(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L312,yes,yes
+RistrettoPoint::compress(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L650,yes,
+RistrettoPoint::double_and_compress_batch_verus(&[RistrettoPoint]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L919,yes,
+BatchCompressState::efgh(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L727,yes,yes
+BatchCompressState::from(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L745,yes,
+coset4(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1079,yes,yes
+elligator_ristretto_flavor(&FieldElement),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1110,yes,
+RistrettoPoint::hash_from_bytes_verus(&[u8]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1253,yes,yes
+from_uniform_bytes(&[u8; 64]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1324,yes,
+RistrettoPoint::from_hash_verus([u8; 64]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1302,yes,yes
+RistrettoPoint::identity(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1379,yes,
+RistrettoPoint::default(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1393,yes,yes
+RistrettoPoint::ct_eq(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1436,yes,
+RistrettoPoint::add(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1485,yes,yes
+RistrettoPoint::add_assign(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1508,yes,yes
+RistrettoPoint::sub(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1537,yes,yes
+RistrettoPoint::sub_assign(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1560,yes,yes
+RistrettoPoint::neg(self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1729,yes,yes
+RistrettoPoint::neg(self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1747,yes,yes
+RistrettoPoint::mul_assign(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1763,yes,yes
+RistrettoPoint::mul(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1787,yes,yes
+Scalar::mul(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1808,yes,yes
+RistrettoPoint::mul_base(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1830,yes,
+RistrettoBasepointTable::mul(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2130,yes,yes
+Scalar::mul(&RistrettoBasepointTable),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2151,yes,yes
+RistrettoBasepointTable::create(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2171,yes,yes
+RistrettoBasepointTable::basepoint(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2181,yes,yes
+"RistrettoPoint::conditional_select(&RistrettoPoint, &RistrettoPoint, Choice)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2219,yes,yes
+CompressedRistretto::zeroize(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2341,yes,yes
+RistrettoPoint::zeroize(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2351,yes,yes
+"RistrettoPoint::multiscalar_mul_verus(I, J)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1925,yes,yes
+"RistrettoPoint::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1979,yes,yes
+Scalar52::zeroize(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L105,yes,yes
+Scalar52::index(usize),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L117,yes,yes
+"m(u64, u64)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L139,yes,yes
+Scalar52::from_bytes(&[u8; 32]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L159,yes,yes
+Scalar52::from_bytes_wide(&[u8; 64]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L228,yes,yes
+Scalar52::as_bytes(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L472,yes,yes
+"Scalar52::add(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L523,yes,yes
+"Scalar52::sub(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L712,yes,yes
+"Scalar52::mul_internal(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L869,yes,yes
+Scalar52::square_internal(&Scalar52),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L930,yes,yes
+Scalar52::montgomery_reduce(&[u128; 9]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L963,yes,
+"Scalar52::mul(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1074,yes,yes
+Scalar52::square(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1124,yes,yes
+"Scalar52::montgomery_mul(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1178,yes,yes
+Scalar52::montgomery_square(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1192,yes,yes
+Scalar52::as_montgomery(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1206,yes,yes
+Scalar52::from_montgomery(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1240,yes,yes
+FieldElement51::zeroize(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L129,yes,yes
+FieldElement51::add_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L172,yes,yes
+FieldElement51::add(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L229,yes,yes
+FieldElement51::sub_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L285,yes,
+FieldElement51::sub(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L343,yes,yes
+FieldElement51::mul_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L447,yes,yes
+FieldElement51::mul(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L488,yes,
+FieldElement51::neg(self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L652,yes,yes
+"FieldElement51::conditional_assign(&FieldElement51, Choice)",curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L738,yes,yes
+FieldElement51::from_limbs([u64; 5]),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L774,yes,yes
+FieldElement51::negate(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L805,yes,yes
+FieldElement51::reduce([u64; 5]),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L861,yes,yes
+FieldElement51::as_bytes(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1015,yes,yes
+FieldElement51::pow2k(u32),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1138,yes,
+FieldElement51::square(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1311,yes,yes
+FieldElement51::square2(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1332,yes,yes
+"mul(&EdwardsPoint, &Scalar)",curve25519_dalek::backend::serial::scalar_mul::variable_base,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs#L29,yes,
+"mul(&Scalar, &EdwardsPoint, &Scalar)",curve25519_dalek::backend::serial::scalar_mul::vartime_double_base,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs#L42,yes,
+"Straus::multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::straus,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L453,yes,
+"Straus::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::straus,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L269,yes,
+"Pippenger::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::pippenger,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs#L219,yes,
+AffineNielsPoint::zeroize(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L208,yes,yes
+ProjectiveNielsPoint::zeroize(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L238,yes,yes
+ProjectiveNielsPoint::identity(),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L272,yes,yes
+AffineNielsPoint::identity(),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L295,yes,yes
+ProjectivePoint::is_valid(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L323,yes,
+"ProjectiveNielsPoint::conditional_assign(&Self, Choice)",curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L412,yes,
+"AffineNielsPoint::conditional_assign(&Self, Choice)",curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L458,yes,
+ProjectivePoint::as_extended(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L487,yes,
+CompletedPoint::as_projective(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L520,yes,yes
+CompletedPoint::as_extended(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L631,yes,
+ProjectivePoint::double(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L686,yes,
+EdwardsPoint::add(&ProjectiveNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L832,yes,
+EdwardsPoint::sub(&ProjectiveNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L932,yes,
+EdwardsPoint::add(&AffineNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1032,yes,
+EdwardsPoint::sub(&AffineNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1117,yes,
+ProjectiveNielsPoint::neg(self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1211,yes,
+AffineNielsPoint::neg(self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1272,yes,
+"load8_at(&[u8], usize)",curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L140,yes,yes
+bot_half(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1986,yes,yes
+top_half(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2006,yes,yes
+"square_multiply(&mut UnpackedScalar, usize, &UnpackedScalar)",curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2745,yes,yes
+part1(u128),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1017,yes,
+part2(u128),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1055,yes,yes
+EdwardsBasepointTable::create(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2400,yes,
+EdwardsBasepointTable::basepoint(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2430,yes,
+"EdwardsBasepointTable::mul_base(&self, &Scalar)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2510,yes,
+Scalar::sum(I),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1043,yes,yes
+EdwardsPoint::sum(I),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1735,yes,yes
+RistrettoPoint::sum(I),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1648,yes,yes
diff --git a/outputs/current_using_main_seed.csv b/outputs/current_using_main_seed.csv
new file mode 100644
index 00000000..b5a686ba
--- /dev/null
+++ b/outputs/current_using_main_seed.csv
@@ -0,0 +1,224 @@
+function,module,link,has_spec,has_proof
+MontgomeryPoint::ct_eq(&MontgomeryPoint),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L113,yes,
+MontgomeryPoint::hash(&H),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L182,yes,
+MontgomeryPoint::identity(),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L212,yes,
+MontgomeryPoint::zeroize(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L236,yes,
+MontgomeryPoint::mul_base(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L255,yes,
+MontgomeryPoint::mul_clamped([u8; 32]),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L288,yes,
+MontgomeryPoint::mul_base_clamped([u8; 32]),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L326,yes,
+MontgomeryPoint::mul_bits_be(impl Iterator<Item = bool>),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L394,yes,
+MontgomeryPoint::as_bytes(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L461,yes,yes
+MontgomeryPoint::to_bytes(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L469,yes,yes
+MontgomeryPoint::to_edwards(u8),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L492,yes,
+elligator_encode(&FieldElement),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L556,yes,
+ProjectivePoint::identity(),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L657,yes,
+ProjectivePoint::as_affine(&self),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L747,yes,
+"differential_add_and_double(&ProjectivePoint, &ProjectivePoint, &FieldElement)",curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L796,yes,
+MontgomeryPoint::mul(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L899,yes,
+MontgomeryPoint::mul_assign(&Scalar),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L942,yes,yes
+Scalar::mul(&MontgomeryPoint),curve25519_dalek::montgomery,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L968,yes,yes
+Scalar::from_bytes_mod_order([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L255,yes,yes
+Scalar::from_bytes_mod_order_wide(&[u8; 64]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L284,yes,yes
+Scalar::from_canonical_bytes([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L340,yes,yes
+Scalar::ct_eq(&Self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L448,yes,yes
+Scalar::index(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L466,yes,yes
+Scalar::mul_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L486,yes,yes
+Scalar::mul(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L568,yes,yes
+Scalar::add_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L717,yes,yes
+Scalar::add(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L651,yes,
+Scalar::sub_assign(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L837,yes,yes
+Scalar::sub(&Scalar),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L752,yes,yes
+Scalar::neg(self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L873,yes,yes
+Scalar::neg(self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L959,yes,yes
+product(I),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1012,yes,yes
+Scalar::from(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1123,yes,yes
+Scalar::from(u16),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1143,yes,yes
+Scalar::from(u32),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1179,yes,yes
+Scalar::from(u64),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1233,yes,yes
+Scalar::from(u128),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1265,yes,yes
+Scalar::zeroize(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1301,yes,yes
+Scalar::hash_from_bytes(&[u8]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1457,ext,
+Scalar::from_hash(D),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1533,ext,
+Scalar::to_bytes(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1580,yes,yes
+Scalar::as_bytes(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1599,yes,yes
+Scalar::invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1647,yes,yes
+Scalar::batch_invert(&[Scalar]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1718,yes,
+Scalar::bits_le(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2047,yes,
+Scalar::non_adjacent_form(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2167,yes,
+Scalar::as_radix_16(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2305,yes,
+Scalar::to_radix_2w_size_hint(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2380,yes,yes
+Scalar::as_radix_2w(usize),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2439,yes,
+Scalar::unpack(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2640,yes,yes
+Scalar::reduce(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2653,yes,yes
+Scalar::is_canonical(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2723,yes,yes
+UnpackedScalar::pack(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2853,yes,yes
+UnpackedScalar::montgomery_invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2936,yes,
+UnpackedScalar::invert(&self),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3015,yes,yes
+"read_le_u64_into(&[u8], &[u64])",curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3191,yes,
+clamp_integer([u8; 32]),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3271,yes,
+NafLookupTable5<ProjectiveNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L468,yes,yes
+NafLookupTable5<AffineNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L493,yes,yes
+NafLookupTable8<ProjectiveNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L684,yes,yes
+NafLookupTable8<AffineNielsPoint>::select(usize),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L710,yes,yes
+NafLookupTable5::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L532,yes,
+NafLookupTable5::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L590,yes,
+NafLookupTable8::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L756,yes,
+NafLookupTable8::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L815,yes,
+LookupTable<AffineNielsPoint>::select(i8),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L103,yes,
+LookupTable<ProjectiveNielsPoint>::select(i8),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L153,yes,
+LookupTable<ProjectiveNielsPoint>::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L286,yes,
+LookupTable<AffineNielsPoint>::from(&EdwardsPoint),curve25519_dalek::window,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L355,yes,
+FieldElement::ct_eq(&FieldElement),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L142,yes,yes
+FieldElement::is_negative(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L217,yes,yes
+FieldElement::is_zero(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L243,yes,yes
+FieldElement::pow22501(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L289,yes,yes
+FieldElement::batch_invert(&[FieldElement]),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L522,yes,
+FieldElement::invert(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L672,yes,yes
+FieldElement::pow_p58(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L708,yes,yes
+"FieldElement::sqrt_ratio_i(&FieldElement, &FieldElement)",curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L791,yes,
+FieldElement::invsqrt(&self),curve25519_dalek::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L913,yes,
+CompressedEdwardsY::ct_eq(&CompressedEdwardsY),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L208,yes,yes
+CompressedEdwardsY::as_bytes(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L232,yes,yes
+CompressedEdwardsY::to_bytes(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L240,yes,yes
+CompressedEdwardsY::decompress(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L252,yes,yes
+step_1(&CompressedEdwardsY),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L327,yes,yes
+"step_2(&CompressedEdwardsY, FieldElement, FieldElement, FieldElement)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L480,yes,yes
+CompressedEdwardsY::identity(),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L713,yes,
+EdwardsPoint::identity(),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L830,yes,
+CompressedEdwardsY::zeroize(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L882,yes,yes
+EdwardsPoint::zeroize(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L902,yes,yes
+EdwardsPoint::is_valid(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L920,yes,
+"EdwardsPoint::conditional_select(&EdwardsPoint, &EdwardsPoint, Choice)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L959,yes,
+EdwardsPoint::ct_eq(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1007,yes,
+EdwardsPoint::as_projective_niels(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1111,yes,
+EdwardsPoint::as_projective(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1151,yes,yes
+EdwardsPoint::as_affine_niels(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1168,yes,
+EdwardsPoint::to_montgomery(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1217,yes,
+EdwardsPoint::compress(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1255,yes,
+EdwardsPoint::nonspec_map_to_curve(&[u8]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1289,ext,
+EdwardsPoint::double(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1398,yes,
+EdwardsPoint::add(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1471,yes,
+EdwardsPoint::add_assign(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1537,yes,yes
+EdwardsPoint::sub(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1580,yes,
+EdwardsPoint::sub_assign(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1640,yes,yes
+EdwardsPoint::neg(self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1774,yes,
+EdwardsPoint::neg(self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1825,yes,yes
+EdwardsPoint::mul_assign(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1847,yes,yes
+EdwardsPoint::mul(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1882,yes,yes
+Scalar::mul(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1905,yes,yes
+EdwardsPoint::mul_base(&Scalar),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1926,yes,yes
+EdwardsPoint::mul_clamped([u8; 32]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1945,yes,
+EdwardsPoint::mul_base_clamped([u8; 32]),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1977,yes,yes
+"EdwardsPoint::vartime_double_scalar_mul_basepoint(&Scalar, &EdwardsPoint, &Scalar)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2139,yes,yes
+EdwardsPoint::mul_by_cofactor(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2681,yes,yes
+EdwardsPoint::mul_by_pow_2(u32),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2705,yes,
+EdwardsPoint::is_small_order(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2782,yes,yes
+EdwardsPoint::is_torsion_free(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2829,yes,
+"EdwardsPoint::multiscalar_mul_verus(I, J)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2266,yes,yes
+"EdwardsPoint::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2185,yes,yes
+CompressedRistretto::ct_eq(&CompressedRistretto),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L251,yes,yes
+CompressedRistretto::to_bytes(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L263,yes,yes
+CompressedRistretto::as_bytes(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L271,yes,yes
+CompressedRistretto::from_slice(&[u8]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L284,yes,
+CompressedRistretto::decompress(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L328,yes,
+step_1(&CompressedRistretto),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L381,yes,
+step_2(FieldElement),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L431,yes,
+CompressedRistretto::identity(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L312,yes,yes
+RistrettoPoint::compress(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L650,yes,
+RistrettoPoint::double_and_compress_batch(I),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L850,ext,
+BatchCompressState::efgh(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L727,yes,yes
+BatchCompressState::from(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L745,yes,
+coset4(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1079,yes,yes
+elligator_ristretto_flavor(&FieldElement),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1110,yes,
+hash_from_bytes(&[u8]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1225,ext,
+from_hash(D),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1275,ext,
+from_uniform_bytes(&[u8; 64]),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1324,yes,
+RistrettoPoint::identity(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1379,yes,
+RistrettoPoint::default(),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1393,yes,yes
+RistrettoPoint::ct_eq(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1436,yes,
+RistrettoPoint::add(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1485,yes,yes
+RistrettoPoint::add_assign(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1508,yes,yes
+RistrettoPoint::sub(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1537,yes,yes
+RistrettoPoint::sub_assign(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1560,yes,yes
+RistrettoPoint::neg(self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1729,yes,yes
+RistrettoPoint::neg(self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1747,yes,yes
+RistrettoPoint::mul_assign(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1763,yes,yes
+RistrettoPoint::mul(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1787,yes,yes
+Scalar::mul(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1808,yes,yes
+RistrettoPoint::mul_base(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1830,yes,
+RistrettoBasepointTable::mul(&Scalar),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2130,yes,yes
+Scalar::mul(&RistrettoBasepointTable),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2151,yes,yes
+RistrettoBasepointTable::create(&RistrettoPoint),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2171,yes,yes
+RistrettoBasepointTable::basepoint(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2181,yes,yes
+"RistrettoPoint::conditional_select(&RistrettoPoint, &RistrettoPoint, Choice)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2219,yes,yes
+CompressedRistretto::zeroize(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2341,yes,yes
+RistrettoPoint::zeroize(&self),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2351,yes,yes
+"RistrettoPoint::multiscalar_mul(I, J)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1882,ext,
+"RistrettoPoint::optional_multiscalar_mul(I, J)",curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1898,ext,
+Scalar52::zeroize(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L105,yes,yes
+Scalar52::index(usize),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L117,yes,yes
+"m(u64, u64)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L139,yes,yes
+Scalar52::from_bytes(&[u8; 32]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L159,yes,yes
+Scalar52::from_bytes_wide(&[u8; 64]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L228,yes,yes
+Scalar52::as_bytes(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L472,yes,yes
+"Scalar52::add(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L523,yes,yes
+"Scalar52::sub(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L712,yes,yes
+"Scalar52::mul_internal(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L869,yes,yes
+Scalar52::square_internal(&Scalar52),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L930,yes,yes
+Scalar52::montgomery_reduce(&[u128; 9]),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L963,yes,
+"Scalar52::mul(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1074,yes,yes
+Scalar52::square(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1124,yes,yes
+"Scalar52::montgomery_mul(&Scalar52, &Scalar52)",curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1178,yes,yes
+Scalar52::montgomery_square(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1192,yes,yes
+Scalar52::as_montgomery(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1206,yes,yes
+Scalar52::from_montgomery(&self),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1240,yes,yes
+FieldElement51::zeroize(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L129,yes,yes
+FieldElement51::add_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L172,yes,yes
+FieldElement51::add(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L229,yes,yes
+FieldElement51::sub_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L285,yes,
+FieldElement51::sub(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L343,yes,yes
+FieldElement51::mul_assign(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L447,yes,yes
+FieldElement51::mul(&FieldElement51),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L488,yes,
+FieldElement51::neg(self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L652,yes,yes
+"FieldElement51::conditional_assign(&FieldElement51, Choice)",curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L738,yes,yes
+FieldElement51::from_limbs([u64; 5]),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L774,yes,yes
+FieldElement51::negate(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L805,yes,yes
+FieldElement51::reduce([u64; 5]),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L861,yes,yes
+FieldElement51::as_bytes(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1015,yes,yes
+FieldElement51::pow2k(u32),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1138,yes,
+FieldElement51::square(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1311,yes,yes
+FieldElement51::square2(&self),curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1332,yes,yes
+"mul(&EdwardsPoint, &Scalar)",curve25519_dalek::backend::serial::scalar_mul::variable_base,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs#L29,yes,
+"mul(&Scalar, &EdwardsPoint, &Scalar)",curve25519_dalek::backend::serial::scalar_mul::vartime_double_base,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs#L42,yes,
+"Straus::multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::straus,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L453,yes,
+"Straus::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::straus,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L269,yes,
+"Pippenger::optional_multiscalar_mul_verus(I, J)",curve25519_dalek::backend::serial::scalar_mul::pippenger,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs#L219,yes,
+AffineNielsPoint::zeroize(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L208,yes,yes
+ProjectiveNielsPoint::zeroize(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L238,yes,yes
+ProjectiveNielsPoint::identity(),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L272,yes,yes
+AffineNielsPoint::identity(),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L295,yes,yes
+ProjectivePoint::is_valid(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L323,yes,
+"ProjectiveNielsPoint::conditional_assign(&Self, Choice)",curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L412,yes,
+"AffineNielsPoint::conditional_assign(&Self, Choice)",curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L458,yes,
+ProjectivePoint::as_extended(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L487,yes,
+CompletedPoint::as_projective(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L520,yes,yes
+CompletedPoint::as_extended(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L631,yes,
+ProjectivePoint::double(&self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L686,yes,
+EdwardsPoint::add(&ProjectiveNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L832,yes,
+EdwardsPoint::sub(&ProjectiveNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L932,yes,
+EdwardsPoint::add(&AffineNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1032,yes,
+EdwardsPoint::sub(&AffineNielsPoint),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1117,yes,
+ProjectiveNielsPoint::neg(self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1211,yes,
+AffineNielsPoint::neg(self),curve25519_dalek::backend::serial::curve_models,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1272,yes,
+"load8_at(&[u8], usize)",curve25519_dalek::backend::serial::u64::field,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L140,yes,yes
+bot_half(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1986,yes,yes
+top_half(u8),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2006,yes,yes
+"square_multiply(&mut UnpackedScalar, usize, &UnpackedScalar)",curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2745,yes,yes
+part1(u128),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1017,yes,
+part2(u128),curve25519_dalek::backend::serial::u64::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1055,yes,yes
+EdwardsBasepointTable::create(&EdwardsPoint),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2400,yes,
+EdwardsBasepointTable::basepoint(&self),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2430,yes,
+"EdwardsBasepointTable::mul_base(&self, &Scalar)",curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2510,yes,
+Scalar::sum(I),curve25519_dalek::scalar,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1043,yes,yes
+EdwardsPoint::sum(I),curve25519_dalek::edwards,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1735,yes,yes
+RistrettoPoint::sum(I),curve25519_dalek::ristretto,https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1648,yes,yes
